# File: .\config.py

ACTIVE_PLAYERS = {
    "Molly Does": ("3-Point Molly", True),
    "Dolly Don't": ("3-Point Dolly", True),
    "Easy Line": ("Pass-Line", False),
    "Line Odds": ("Pass-Line w/ Odds", True),
    "Field Newby": ("Field", False),
    "Crosstopher": ("Iron Cross", True),
    "Insider": ("Inside", False),
    "All Across": ("Across", False),
    "Easy Place": ("Place 68", False),
    "Layla": ("Lay Outside", False),
    "Double Hop": ("Double Aces", False),
    "3-2-1 Blast": ("Three-Two-One", True),
    "Regress-Press": ("RegressHalfPress", True),
}

# Add a new configuration entry for session mode
DICE_MODE = "live"  # Options: "live" or "history"

# House Rules Configuration
HOUSE_RULES = {
    "field_bet_payout_2": (2, 1),  # 2:1 payout for 2
    "field_bet_payout_12": (3, 1),  # 3:1 payout for 12
    "table_minimum": 10,  # Minimum bet amount
    "table_maximum": 5000,  # Maximum bet amount
    "come_odds_working_on_come_out": False,  # Whether Come odds bets are working during the come-out roll
    "leave_bets_working": False,  # Non-contract bets follow the puck
    "leave_winning_bets_up": True,  # If it pays, it stays
}

DICE_TEST_PATTERNS = {
    "point_7_out": [
        (3, 3),  # point set
        (4, 1),  # random roll
        (5, 2),  # point = 7 out - DP wins
    ],
    "point_hit": [
        (3, 3),  # point = 6
        (6, 6),  # No change
        (3, 3),  # point hit → DP loses
    ],
    "front_line_winner": [
        (2, 5),  # front line winner
    ],
}


# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Ensure the output directory exists
    os.makedirs(os.path.dirname(output_file), exist_ok=True)

    # Delete the output file if it already exists
    if os.path.exists(output_file):
        os.remove(output_file)

    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, dirs, files in os.walk(directory):
            # Exclude the 'vend' directory
            if 'venv' in dirs:
                dirs.remove('venv')  # This prevents os.walk from traversing into 'vend'

            for file in files:
                file_path = os.path.join(root, file)

                # Ignore Python files in the output directory itself
                if file.endswith('.py') and not file_path.startswith(os.path.dirname(output_file)):
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory
output_directory = os.path.join(os.getcwd(), 'output')
output_file = os.path.join(output_directory, 'combined_files.txt')

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")

# File: .\main.py

import os
from craps.single_session import run_single_session

def main():
    # Optional test pattern via environment variable
    pattern_name = None # "point_hit"

    # Run the single session
    stats = run_single_session(pattern_name=pattern_name)

if __name__ == "__main__":
    main()


# File: .\setup.py

from setuptools import setup, find_packages

setup(
    name="craps_simulator",
    version="0.1",
    packages=find_packages(),
)

# File: .\craps\base_strategy.py

from abc import ABC, abstractmethod
from typing import List, Optional, TYPE_CHECKING
from craps.bet import Bet
from craps.player import Player
from craps.game_state import GameState

if TYPE_CHECKING:
    from craps.table import Table

class BaseStrategy(ABC):
    """Abstract base class for all betting strategies."""

    def __init__(self, name: str):
        self.name = name  # Strategy name for tracking

    @abstractmethod
    def place_bets(self, game_state: GameState, player: Player, table: "Table") -> List[Bet]:
        """Determine which bets to place at the start of a roll."""
        pass

    def adjust_bets(self, game_state: GameState, player: Player, table: "Table") -> Optional[List[Bet]]:
        """Modify existing bets (e.g., adding odds, pressing bets)."""
        return None  # Default to no adjustments

    def remove_bets(self, game_state: GameState, player: Player, table: "Table") -> Optional[List[Bet]]:
        """Remove bets when necessary (e.g., conservative strategies)."""
        return None  # Default to no bet removal
    
    def turn_off_bets(self, game_state: GameState, player: Player, table: "Table") -> Optional[List[Bet]]:
        """Disable bets without removing them."""
        return None

    def turn_on_bets(self, game_state: GameState, player: Player, table: "Table") -> Optional[List[Bet]]:
        """Re-enable previously turned-off bets."""
        return None

    def on_new_shooter(self) -> None:
        """Optional hook called at the start of a new shooter."""
        pass

    def notify_payout(self, amount: int) -> None:
        """Optional hook called when a player wins a payout (excluding original bet)."""
        pass

    def notify_roll(self, game_state: "GameState", player: "Player", table: "Table") -> None:
        """Optional hook called after a roll is resolved."""
        pass
    
    def reset_shooter_state(self) -> None:
        """Optional hook for regression-based strategies to reset between modes."""
        pass

    def __str__(self) -> str:
        return f"{self.name} Strategy"


# File: .\craps\bet.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, List, Optional, Tuple, Union
from craps.rules import BET_RULES
import logging

if TYPE_CHECKING:
    from craps.player import Player  # Prevent circular imports
    from craps.rules_engine import RulesEngine  # Ensure correct type hint for resolve method

class Bet:
    """Represents a single bet in the game of Craps."""

    VALID_PHASES: List[str] = ["come-out", "point"]  # Ensures class-level definition

    def __init__(
        self,
        bet_type: str,
        amount: int,
        owner: Player,
        payout_ratio: Tuple[int, int],  # Updated to a tuple
        locked: bool = False,
        vig: bool = False,  # Updated to a boolean
        unit: int = 1,
        valid_phases: Optional[List[str]] = None,
        number: Optional[Union[int, Tuple[int, int]]] = None,  # ✅ Now supports tuples for Hop bets
        parent_bet: Optional[Bet] = None,
        linked_bet: Optional["Bet"] = None,
        is_contract_bet: bool = False,
        hits: int = 0,
    ) -> None:
        """
        Initializes a Bet.

        :param number: The number associated with the bet (e.g., 6 for Place 6 or (2,5) for Hop bets).
        """
        self.bet_type: str = bet_type
        self.amount: int = amount
        self.owner: Player = owner
        self.payout_ratio: Tuple[int, int] = payout_ratio  # Ensuring payout is stored as a ratio tuple
        self.locked: bool = locked
        self.vig: bool = vig  # Vig is now a boolean
        self.unit: int = unit
        self.valid_phases: List[str] = valid_phases if valid_phases is not None else self.VALID_PHASES
        self.number: Optional[Union[int, Tuple[int, int]]] = number  # ✅ Now supports both int and tuple
        self.status: str = "active"
        self.parent_bet: Optional[Bet] = parent_bet
        self.is_contract_bet: bool = is_contract_bet  # Whether the bet is a contract bet
        self.linked_bet: Optional[Bet] = linked_bet
        self.resolved_payout: int = 0
        self.hits: int = 0

    def validate_bet(self, phase: str, table_minimum: int, table_maximum: int) -> bool:
        """
        Validate the bet based on the game phase, table limits, and bet type.

        :param phase: The current game phase ("come-out" or "point").
        :param table_minimum: The table's minimum bet amount.
        :param table_maximum: The table's maximum bet amount.
        :return: True if the bet is valid, False otherwise.
        """
        # Check if the bet can be placed during the current phase
        if phase not in self.valid_phases:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet cannot be placed during the {phase} phase.")
            return False

        # Determine the category the bet belongs to
        bet_category = next(
            (
                category
                for category, config in BET_RULES.items()
                if isinstance(config, dict) and self.bet_type in {
                    k for k in config.keys()
                    if isinstance(config[k], dict)  # Only consider actual bet definitions
                }
            ),
            None
        )
        
        # Check table minimum unless it's an 'Other Bets' category
        if bet_category != "Other Bets" and self.amount < table_minimum:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} is below the table minimum of ${table_minimum}.")
            return False

        # Check table maximum
        if self.amount > table_maximum:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} exceeds the table maximum of ${table_maximum}.")
            return False

        # Check unit multiple validity for Place/Buy
        if self.bet_type in ["Place", "Buy"]:
            if self.amount % self.unit != 0:
                logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} must be a multiple of ${self.unit}.")
                return False

        return True

    def resolve(self, rules_engine: RulesEngine, dice_outcome: Tuple[int, int], phase: str, point: Optional[int]) -> None:
        """
        Resolve the bet based on the dice outcome, phase, and point.
        Delegates resolution logic to the RulesEngine.

        :param rules_engine: The RulesEngine instance to use for resolution.
        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        self.resolved_payout = rules_engine.resolve_bet(self, dice_outcome, phase, point)

    def is_resolved(self) -> bool:
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def payout(self) -> int:
        """
        Calculate the payout for the bet.
        - Contract bets return original bet amount + winnings.
        - Non-contract bets return only winnings.
        """
        if self.status != "won":
            return 0  # No payout if the bet was lost

        if self.resolved_payout:
            return self.resolved_payout
        numerator, denominator = self.payout_ratio
        return (self.amount * numerator) // denominator

    def __str__(self) -> str:
        """Return a string representation of the bet."""
        if self.number is not None:
            return f"{self.owner.name}'s {self.bet_type} {self.number} bet"
        else:
            return f"{self.owner.name}'s {self.bet_type} bet"


# File: .\craps\bet_adjusters.py

"""
Bet Adjusters Module
=====================
This module defines a base class `BetAdjuster` and a growing library of concrete bet adjustment behaviors
used to manage post-roll bet modifications such as pressing, collecting, regressing, etc.

| Class Name                | Behavior Summary                                        |
|--------------------------|---------------------------------------------------------|
| `PressAdjuster`          | Full press after win (add full winnings to bet)         |
| `RegressAdjuster`        | Reduce the bet by a set number of units                 |
"""

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING, List, Optional
from enum import Enum

class PressStyle(Enum):
    HALF = "half"
    FULL = "full"
    POWER = "power"
    N_UNIT = "n_unit"

if TYPE_CHECKING:
    from craps.bet import Bet
    from craps.table import Table
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player

class BetAdjuster(ABC):
    """Abstract base class for bet adjustment behaviors."""

    @abstractmethod
    def adjust(self, bet: "Bet", table: "Table", rules_engine: "RulesEngine") -> None:
        pass
    
    def on_new_shooter(self, game_state: "GameState", player: "Player", table: "Table") -> None:
        """Optional hook called after every roll."""
        pass

    def notify_roll(self, game_state: "GameState", player: "Player", table: "Table") -> None:
        """Optional hook called after every roll."""
        pass

    def notify_payout(self, amount: int) -> None:
        """Optional hook called when a player wins a payout (not including original bet)."""
        pass

class RegressAdjuster(BetAdjuster):
    """
    Adjusts a Place bet downward based on a regression progression.

    Given a unit progression (e.g. [20, 10, 5]) and a current hit count,
    this adjuster determines the proper unit level and adjusts the bet
    amount accordingly—rounded to standard Place bet units.

    Example:
    - If hit_count = 1 and unit_levels = [20, 10, 5], unit = 10
    - Bet on 6 → target = 10 * 6 = $60
    - Bet on 5 → target = 10 * 5 = $50
    """

    def __init__(self, unit_levels: List[int], hit_count: int) -> None:
        self.unit_levels = unit_levels
        self.hit_count = hit_count

    def adjust(self, bet: "Bet", table: "Table", rules_engine: "RulesEngine") -> None:
        # Determine the proper unit level based on hit count
        level_index = min(self.hit_count - 1, len(self.unit_levels) - 1)
        unit_multiplier = self.unit_levels[level_index]

        if not isinstance(bet.number, int):
            return  # Skip unsupported types

        unit_base = rules_engine.get_bet_unit("Place", bet.number)
        target_amount = unit_multiplier * unit_base

        if bet.amount > target_amount:
            bet.amount = target_amount
            
class PressAdjuster(BetAdjuster):
    def __init__(self, style: PressStyle = PressStyle.HALF, n_units: int = 1) -> None:
        self.style = style
        self.n_units = n_units

    def adjust(self, bet: "Bet", table: "Table", rules_engine: "RulesEngine") -> None:
        if bet.status != "won" or bet.resolved_payout == 0:
            return

        unit = bet.unit
        winnings = bet.resolved_payout
        additional = 0

        if self.style == PressStyle.HALF:
            additional = (winnings // 2) // unit * unit
        elif self.style == PressStyle.FULL:
            additional = (winnings // unit) * unit
        elif self.style == PressStyle.POWER:
            additional = ((winnings + unit - 1) // unit) * unit
        elif self.style == PressStyle.N_UNIT and self.n_units:
            additional = self.n_units * unit

        bet.amount += additional


# File: .\craps\common.py

import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from typing import Optional, List, Tuple, Union
from config import HOUSE_RULES
from craps.house_rules import HouseRules
from craps.log_manager import LogManager
from craps.play_by_play import PlayByPlay
from craps.rules_engine import RulesEngine
from craps.player import Player
from craps.bet import Bet
from craps.session_initializer import InitializeSession
from craps.lineup import PlayerLineup

class CommonTableSetup:
    """Common setup for all craps tests, now using InitializeSession for consistency."""

    def __init__(self) -> None:
        """Initialize the table, players, and other components for testing."""

        # ✅ Create instances for required objects
        house_rules = HouseRules(HOUSE_RULES)
        play_by_play = PlayByPlay()
        log_manager = LogManager()
        rules_engine = RulesEngine()
        player_lineup = PlayerLineup(house_rules, None, play_by_play, rules_engine)

        # ✅ Use these in InitializeSession
        session_initializer = InitializeSession(
            dice_mode="live",
            house_rules=house_rules,
            play_by_play=play_by_play,
            log_manager=log_manager,
            rules_engine=rules_engine,
            player_lineup=player_lineup
        )

        session_data = session_initializer.prepare_session(num_shooters=10, num_players=1)

        if session_data is None:
            raise RuntimeError("Failed to initialize common test session.")

        self.house_rules, self.table, self.roll_history_manager, _, self.play_by_play, self.stats, self.game_state = session_data

        # ✅ Setup Player
        self.player_name = "Alice"
        self.initial_balance = 1000
        self.rules_engine = RulesEngine()
        self.player = Player(name=self.player_name, strategy_name=None, initial_balance=self.initial_balance)

        # ✅ Setup Gamestate
        self.game_state.set_table(self.table)

    def place_bet(self, bet_type: str, amount: int, phase: str = "come-out", number: Optional[Union[int, Tuple[int, int]]] = None) -> Bet:
        """
        Place a bet on the table for the player.

        :param bet_type: The type of bet (e.g., "Field", "Pass Line").
        :param amount: The amount of the bet.
        :param phase: The current game phase ("come-out" or "point").
        :param number: The number associated with the bet (e.g., 6 for Place 6 or (2,5) for Hop bets).
        :return: The created bet.
        """
        if bet_type == "Come Odds":
            come_bet = next(
                (bet for bet in self.table.bets if bet.bet_type == "Come" and bet.owner == self.player), None
            )
            if come_bet is None or come_bet.number is None:
                raise ValueError("Cannot place Come Odds bet without an active Come bet with a number.")
            number = come_bet.number

        bet = self.rules_engine.create_bet(bet_type, amount, self.player, number=number)
        self.table.place_bet(bet, phase)
        return bet

    def simulate_roll(self, dice_outcome: Tuple[int, int], phase: str = "come-out", point: Optional[int] = None) -> List[Bet]:
        """
        Simulate a dice roll and resolve bets on the table.

        :param dice_outcome: The result of the dice roll (e.g., (3, 4)).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        :return: A list of resolved bets.
        """
        self.table.check_bets(dice_outcome, phase, point)
        return self.table.settle_resolved_bets()

    def reset_table(self) -> None:
        """Reset the table and player for a new test."""
        self.table.bets = []  # Clear all bets
        self.player.balance = self.initial_balance  # Reset player balance


# File: .\craps\dice.py

import csv
import random
import os
from typing import Optional, List, Dict, Tuple, cast
from collections import deque

class Dice:
    def __init__(self, roll_history_file: Optional[str] = None) -> None:
        """
        Initialize the Dice class.
        
        :param roll_history_file: Path to a CSV file containing roll history. If None, rolls are random.
        """
        self.values: Tuple[int, int] = (1, 1)  # Ensure this is a fixed-size tuple
        self.roll_history_file: Optional[str] = roll_history_file
        self.roll_history: List[Dict[str, int | Tuple[int, int]]] = []
        self.current_roll_index: int = 0
        self.forced_rolls: deque[Tuple[int, int]] = deque()

        if self.roll_history_file:
            self._load_roll_history()

    def _load_roll_history(self) -> None:
        """Load roll history from a CSV file."""
        if not self.roll_history_file:
            return  # Prevent passing None to open()

        if not os.path.exists(self.roll_history_file):
            raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found.")

        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to proper types
                dice_list = row["dice"].strip('[]').split(', ')
                if len(dice_list) != 2:
                    raise ValueError(f"Invalid dice format in roll history: {row['dice']}")
                
                dice: Tuple[int, int] = (int(dice_list[0]), int(dice_list[1]))  # Ensure exactly two values
                total: int = int(row["total"])
                shooter_num: int = int(row["shooter_num"])
                self.roll_history.append({
                    "dice": dice,
                    "total": total,
                    "shooter_num": shooter_num
                })

    def roll(self) -> Tuple[int, int]:
        """Forced Rolls used for testing"""
        if self.forced_rolls:
            self.values = self.forced_rolls.popleft()
            return self.values
        """Roll the dice. If roll history is loaded, use the next roll from the history."""
        if self.roll_history:
            if self.current_roll_index >= len(self.roll_history):
                raise IndexError("No more rolls in the history.")
            roll = self.roll_history[self.current_roll_index]
            dice = cast(Tuple[int, int], roll["dice"])
            if len(dice) != 2:
                raise ValueError(f"Invalid dice format in roll history: {roll['dice']}")

            self.values = dice  # Ensure it's a valid (int, int) tuple
            self.current_roll_index += 1
        else:
            """ Generate random rolls if no history is loaded """
            self.values = (random.randint(1, 6), random.randint(1, 6))  # Ensure it's a tuple
        
        return self.values


# File: .\craps\game_state.py

from typing import Optional, Any, Tuple, Set
from colorama import Fore, Style
from craps.player import Player

class GameState:
    def __init__(self, stats: Any, play_by_play: Optional[Any] = None) -> None:
        """
        Initialize the game state.

        :param stats: The Statistics object for recording game data.
        :param play_by_play: The PlayByPlay instance for logging messages.
        """
        self._point: Optional[int] = None  # Encapsulated point
        self.previous_point: Optional[int] = None  # Track the last point before changes
        self.stats = stats
        self.play_by_play = play_by_play
        self.shooter: Optional[Player] = None  # Store current shooter (now a Player)
        self.small_hits: Set[int] = set()
        self.tall_hits: Set[int] = set()

    @property
    def point(self) -> Optional[int]:
        """Get the current point."""
        return self._point

    @point.setter
    def point(self, value: Optional[int]) -> None:
        """Set the point while tracking the previous point."""
        if self._point != value:
            self.previous_point = self._point  # Store previous point before change
            self._point = value  # Update point

    @property
    def phase(self) -> str:
        """Determine the game phase based on whether a point is set."""
        return "point" if self._point else "come-out"

    @property
    def puck_on(self) -> bool:
        """Check if the puck should be 'ON' (point is set)."""
        return self._point is not None

    def set_table(self, table: Any) -> None:
        """Set the table reference."""
        self.table = table

    def assign_new_shooter(self, shooter: Player, shooter_num: int) -> None:
        """
        Assigns a new shooter and resets their stats.

        :param shooter: The new shooter for the game.
        """
        self.shooter = shooter
        self.shooter_num = shooter_num
        self.shooter.is_shooter = True  # Mark player as the shooter
        self.reset_ats_tracking()
        
        if self.play_by_play:
            self.play_by_play.write("==============================================================================")
            self.play_by_play.write(f"🎲🎲 Shooter #{shooter_num}: {self.shooter.name} steps up!")

    def reset_ats_tracking(self) -> None:
        """Resets number hit tracking for All/Tall/Small bets."""
        self.small_hits.clear()
        self.tall_hits.clear()
        
    def record_number_hit(self, total: int) -> None:
        """
        Track number hit for All Tall Small logic.
        Called after every roll (excluding 7s).
        """
        if total in range(2, 7):
            self.small_hits.add(total)
        elif total in range(8, 13):
            self.tall_hits.add(total)

    def check_ats_completion(self) -> dict[str, bool]:
        """
        Return whether each component of ATS is completed.
        Used by resolver logic to determine wins.
        """
        return {
            "small_complete": all(n in self.small_hits for n in range(2, 7)),
            "tall_complete": all(n in self.tall_hits for n in range(8, 13)),
            "all_complete": all(n in self.small_hits for n in range(2, 7)) and
                            all(n in self.tall_hits for n in range(8, 13)),
        }

    def clear_shooter(self) -> None:
        """
        Clears the current shooter when a new shooter is needed.
        """
        if self.shooter:
            self.shooter.is_shooter = False
        self.shooter = None

    def update_state(self, dice_outcome: Tuple[int, int]) -> str:
        """
        Update the game state based on the dice outcome.

        :param dice_outcome: The result of the dice roll (e.g., (3, 4)).
        :return: A message describing the state change.
        """
        total = sum(dice_outcome)
        message = "  No change in game state."
        
        # Update ATS tracking
        if total != 7:
            self.record_number_hit(total)

        if self.phase == "come-out":
            if total in [7, 11]:  # Natural win
                self.point = None  # Reset to come-out phase
                message = f"  ✅ 7-Winner: Pass Line bets win! → Puck OFF."
            elif total in [2, 3, 12]:  # Craps loss
                self.point = None  # Stay in come-out phase
                message = f"  ☄️ Craps: Pass Line bets lose! → Puck OFF."
            else:  # Set the point
                self.point = total
                message = f"  🎯 Point Set to {total} → Puck ON"
        else:  # Point phase
            if total == self.point:  # Point hit, pass line wins
                self.stats.record_point_number_roll()
                self.point = None  # Reset b ck to come-out
                message = f"  ✅ Point Hit: {total} — Pass Line bets win! → Puck OFF"
            elif total == 7:  # Seven out, pass line loses
                self.stats.record_seven_out()
                self.point = None  # Reset back to come-out
                self.reset_ats_tracking()  # Clear tracked numbers on 7-out
                message = f"  🛑 7-Out: Pass Line bets lose! → Puck OFF."

        return message
    
    def clear_point(self) -> None:
        """Clears the current point and resets phase to 'come-out'."""
        self.point = None



# File: .\craps\house_rules.py

from typing import Any

class HouseRules:
    """Class representing house rules for payouts and table limits."""

    def __init__(self, config: dict[str, Any]) -> None:
        """
        Initialize the HouseRules with configuration from config.py.

        :param config: A dictionary containing house rules configuration.
        """
        self.table_minimum: int = config.get("table_minimum", 10)  # Default to $10
        self.table_maximum: int = config.get("table_maximum", 5000)  # Default to $5000
        
        # ✅ Sessuib behavioral toggles from config
        self.come_odds_working_on_come_out: bool = config.get("come_odds_working_on_come_out", False)
        self.leave_bets_working: bool = config.get("leave_bets_working", False)
        self.leave_winning_bets_up: bool = config.get("leave_winning_bets_up", True)

    def set_table_limits(self, minimum: int, maximum: int) -> None:
        """Set the table limits."""
        self.table_minimum = minimum
        self.table_maximum = maximum


# File: .\craps\lineup.py

from typing import Dict, Optional, List, Any, TYPE_CHECKING
from craps.strategies.pass_line_strategy import PassLineStrategy
from craps.strategies.pass_line_odds_strategy import PassLineOddsStrategy
from craps.strategies.place_strategy import PlaceBetStrategy
from craps.strategies.field_strategy import FieldBetStrategy
from craps.strategies.iron_cross_strategy import IronCrossStrategy
from craps.strategies.three_point_molly_strategy import ThreePointMollyStrategy
from craps.strategies.three_point_dolly_strategy import ThreePointDollyStrategy
from craps.strategies.double_hop_strategy import DoubleHopStrategy
from craps.strategies.three_two_one_strategy import ThreeTwoOneStrategy
from craps.strategies.place_reggression_strategy import PlaceRegressionStrategy
from craps.strategies.regress_then_press_strategy import RegressThenPressStrategy
from craps.strategies.lay_strategy import LayBetStrategy
from craps.strategies.adjuster_only_strategy import AdjusterOnlyStrategy
from craps.bet_adjusters import PressAdjuster, PressStyle
from craps.rules_engine import RulesEngine

if TYPE_CHECKING:
    from craps.player import Player

class PlayerLineup:
    """Class to manage the lineup of players and their strategies."""

    def __init__(self, house_rules: Any, table: Any, play_by_play: Any, rules_engine: RulesEngine) -> None:
        """
        Initialize the player lineup.

        :param house_rules: The HouseRules object for table limits and payouts.
        :param table: The Table object for placing bets.
        :param play_by_play: The PlayByPlay instance for logging game actions.
        :param rules_engine: The RulesEngine instance for bet validation.
        """
        self.house_rules = house_rules
        self.table = table
        self.play_by_play = play_by_play
        self.rules_engine = rules_engine

        # ✅ Store actual Player instances
        self.players: List["Player"] = []

        # Define all supported strategies
        self.all_strategies: Dict[str, Any] = {
            "Pass-Line": PassLineStrategy(bet_amount=self.house_rules.table_minimum, table=self.table),
            "Pass-Line w/ Odds": PassLineOddsStrategy(table=self.table, rules_engine=self.rules_engine, odds_multiple="1x"),  # str or int
            "Field": FieldBetStrategy(min_bet=self.house_rules.table_minimum),
            "Iron Cross": IronCrossStrategy(table=self.table, min_bet=self.house_rules.table_minimum, play_by_play=self.play_by_play, rules_engine=self.rules_engine),
            "3-Point Molly": ThreePointMollyStrategy(table=self.table, bet_amount=self.house_rules.table_minimum, odds_type="1x"),
            "3-Point Dolly": ThreePointDollyStrategy(table=self.table, bet_amount=self.house_rules.table_minimum, odds_type="1x"),
            "Inside": PlaceBetStrategy(table=self.table, rules_engine=self.rules_engine, numbers_or_strategy="inside",),
            "Across": PlaceBetStrategy(table=self.table, rules_engine=self.rules_engine, numbers_or_strategy="across",),
            "Place 68": PlaceBetStrategy(table=self.table, numbers_or_strategy=[6, 8], rules_engine=self.rules_engine),
            "Double Aces": DoubleHopStrategy(base_bet=1, hop_target=(1, 1), rules_engine=rules_engine),
            "Three-Two-One": ThreeTwoOneStrategy(rules_engine=self.rules_engine, min_bet=self.house_rules.table_minimum, odds_type="1x"),
            "RegressHalfPress": RegressThenPressStrategy(regression_strategy=PlaceRegressionStrategy(high_unit=10,low_unit=3, regression_factor=2, regress_units=5),press_style = PressStyle.HALF),
            "Lay Outside": LayBetStrategy(table=self.table, rules_engine=self.rules_engine, numbers_or_strategy="Outside"),
        }

    def add_player(self, player: "Player") -> None:
        """Adds a Player instance to the lineup."""
        self.players.append(player)

    def get_active_players_list(self) -> List["Player"]:
        """Retrieve a list of active player objects."""
        return self.players  # ✅ Return actual Player instances
    
    def get_strategy_for_player(self, player: "Player") -> Optional[Any]:
        """Retrieve the strategy for a given player."""
        return player.betting_strategy if player in self.players else None

    def should_odds_be_working(self, player: "Player") -> bool:
        """
        Determine if the player's strategy wants Come/Place/Lay odds working on a come-out roll.
        """
        strategy = self.get_strategy_for_player(player)
        if strategy and hasattr(strategy, "should_come_odds_be_working"):
            return strategy.should_come_odds_be_working()
        return False

    def get_bet_amount(self, player: "Player") -> int:
        """
        Retrieve the bet amount for a given player.
        Defaults to the house table minimum if not explicitly set.
        """
        strategy = self.get_strategy_for_player(player)
        if strategy and hasattr(strategy, "bet_amount"):
            return strategy.bet_amount
        return self.house_rules.table_minimum  # ✅ Default to table min

    def assign_strategies(self, players: List["Player"]) -> None:
        """
        Assigns betting strategies to players based on their name and adds them to the lineup.
        """
        for player in players:
            print(f"  🧪 Checking: {player.name} (strategy: {getattr(player, 'strategy_name', 'N/A')})")
            if player.strategy_name in self.all_strategies:
                player.betting_strategy = self.all_strategies[player.strategy_name]
                self.add_player(player)
            else:
                raise ValueError(f"No strategy found for player '{player.name}'")


# File: .\craps\log_manager.py

import logging
import os

class LogManager:
    """Handles logging for the game."""

    def __init__(self, log_file: str = "output/simulation.log") -> None:
        """Initialize the LogManager with file logging."""
        self.log_file = log_file

        # ✅ Set up logging to append instead of overwrite
        logging.basicConfig(
            filename=self.log_file,  # ✅ Logs to file
            filemode="a",  # ✅ "a" means append instead of delete
            level=logging.INFO,
            format="%(asctime)s - %(message)s",
        )
        self.logger = logging.getLogger("CrapsSim")

    def log(self, message: str) -> None:
        """Log a message to the file and console."""
        self.logger.info(message)

    def delete_log_file(self) -> None:
        """No longer deletes the log file, just a placeholder."""
        pass  # ✅ No deletion, just appends to the existing file


# File: .\craps\player.py

from typing import List, Union, Optional, Any, Tuple, TYPE_CHECKING
from craps.bet import Bet
from craps.play_by_play import PlayByPlay
import random

if TYPE_CHECKING:
    from craps.table import Table
    
class Player:
    def __init__(self, name: str, strategy_name: Optional[str] = None, initial_balance: int = 500, betting_strategy: Optional[Any] = None):
        """
        Initialize a player.

        :param name: The name of the player.
        :param initial_balance: The initial bankroll of the player.
        :param betting_strategy: The betting strategy used by the player.
        """
        self.name: str = name
        self.strategy_name: str = strategy_name or name
        self.balance: int = initial_balance
        self.betting_strategy: Any = betting_strategy
        self.is_shooter: bool = False

    def place_bet(self, bet: Union[Bet, List[Bet]], table: "Table", phase: str, play_by_play: PlayByPlay) -> bool:
        """
        Place a bet (or multiple bets) on the table and deduct the amount from the player's balance.

        :param bet: The bet(s) to place.
        :param table: The table to place the bet on.
        :param phase: The current game phase ("come-out" or "point").
        :param play_by_play: The PlayByPlay instance for logging messages.
        :return: True if the bet(s) were placed successfully, False otherwise.
        """
        bets: List[Bet] = [bet] if not isinstance(bet, list) else bet

        for b in bets:
            if hasattr(b, 'parent_bet') and b.parent_bet is not None:
                if b.parent_bet.owner != self:
                    raise ValueError("Cannot place odds bet on another player's bet")
                if not table.has_bet(b.parent_bet):
                    raise ValueError("Parent bet must be on the table before placing odds")

        total_amount: int = sum(b.amount for b in bets)

        if total_amount > self.balance:
            message: str = f"  ❌ {self.name} has insufficient funds to place ${total_amount} in bets."
            if play_by_play:
                play_by_play.write(message)
            return False

        for b in bets:
            if not table.place_bet(b, phase):
                message = f"  ❌ Failed to place {b.bet_type} bet for {self.name}"
                if play_by_play:
                    play_by_play.write(message)
                return False

            if play_by_play:
                risk = self.get_total_at_risk(table)

                # 🧩 Compose the bet label
                if b.bet_type in ["Place", "Buy", "Lay", "Hardways", "Hop"] and b.number is not None:
                    bet_label = f"{b.bet_type} {b.number}"
                else:
                    bet_label = b.bet_type

                # 🧩 Add parent info if this is an odds or linked bet
                parent_info = ""
                if hasattr(b, "parent_bet") and b.parent_bet:
                    parent_info = f" (odds on {b.parent_bet.bet_type})"

                message = (
                    f"  💰 Bet placed: {self.name}'s ${b.amount} {bet_label} bet{parent_info} "
                    f"(Status: {b.status}). Bankroll: ${self.balance} (w/ ${risk} on the table)"
                )
                play_by_play.write(message)

        return True

    def receive_payout(self, payout: int, play_by_play: PlayByPlay) -> None:
        """
        Add the payout amount to the player's bankroll.

        :param payout: The payout amount.
        """
        self.balance += payout

    def has_active_bet(self, table: "Table", bet_type: str, number: Optional[int] = None) -> bool:
        """
        Check if the player has an active bet of a specific type and number on the table.

        :param table: The table to check for active bets.
        :param bet_type: The type of bet to check for (e.g., "Pass Line", "Place").
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :return: True if the player has an active bet of the specified type and number, False otherwise.
        """
        return any(
            bet.owner == self and bet.bet_type == bet_type and (number is None or bet.number == number)
            for bet in table.bets
        )

    def roll_dice(self) -> Tuple[int, int]:
        """
        Roll the dice if this player is the shooter.

        :return: A tuple representing the dice roll (e.g., (3, 4)).
        """
        if self.is_shooter:
            return random.randint(1, 6), random.randint(1, 6)
        else:
            raise ValueError(f"{self.name} is not the shooter and cannot roll dice.")

    def reset_shooter(self) -> None:
        """
        Reset the shooter status when a new round begins.
        """
        self.is_shooter = False

    def has_odds_bets(self, table: "Table") -> bool:
        """Check if the player has any active Come Odds bets."""
        return any(bet.bet_type == "Come Odds" and bet.status == "active" for bet in table.bets if bet.owner == self)

    def update_come_odds_status(self, table: "Table", should_work: bool) -> None:
        """Update the status of the player's Come Odds bets based on strategy preference."""
        for bet in table.bets:
            if bet.owner == self and bet.bet_type == "Come Odds":
                bet.status = "active" if should_work else "inactive"

    def get_total_at_risk(self, table: "Table") -> int:
        """Return the total amount this player has at risk on the table."""
        return sum(bet.amount for bet in table.bets if bet.owner == self and bet.status == "active")
    
    def win_bet(self, bet: Bet, play_by_play: Optional[Any] = None) -> None:
        """Handle a winning bet: update bankroll and optionally log result."""
        winnings = bet.payout()
        self.balance += winnings

        if play_by_play:
            play_by_play.write(
                f"  ⚡{bet} WON ${winnings}! New Bankroll: ${self.balance}" 
            )

    def lose_bet(self, bet: Bet, play_by_play: Optional[Any] = None) -> None:
        self.balance -= bet.amount  # This line was missing!
        if play_by_play:
            play_by_play.write(
                f"  ❌ {bet} LOST ${bet.amount}. New Bankroll: ${self.balance}"
            )


# File: .\craps\player_setup.py

from config import ACTIVE_PLAYERS
from craps.player import Player
from typing import List

class SetupPlayers:
    def __init__(self) -> None:
        """Initialize player setup."""
        self.active_players: dict[str, tuple[str, bool]] = ACTIVE_PLAYERS

    def setup(self) -> List[Player]:
        """
        Create and return a list of active players based on ACTIVE_PLAYERS settings.
        Returns an empty list if none are active — caller should handle that case.
        """
        players: List[Player] = [
            Player(name=player_name, strategy_name=strategy_name, initial_balance=500)
            for player_name, (strategy_name, enabled) in self.active_players.items() if enabled
        ]

        return players


# File: .\craps\play_by_play.py

import os
import logging
from typing import Optional

class PlayByPlay:
    def __init__(self, output_folder: str = "output", play_by_play_file: str = "play_by_play.txt") -> None:
        """
        Initialize the PlayByPlay writer.

        :param output_folder: The folder where the play-by-play file will be saved.
        :param play_by_play_file: The name of the play-by-play file.
        """
        self.output_folder: str = output_folder
        self.play_by_play_file: str = os.path.join(output_folder, play_by_play_file)
        self.ensure_output_folder_exists()

    def ensure_output_folder_exists(self) -> None:
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def write(self, message: str) -> None:
        """
        Write a pre-formatted message (with embedded Colorama colors) to the play-by-play file.

        :param message: The message to write.
        """
        with open(self.play_by_play_file, "a", encoding="utf-8") as file:
            file.write(message + "\n")

    def clear_play_by_play_file(self) -> None:
        """Clear the play-by-play file if it exists."""
        if os.path.exists(self.play_by_play_file):
            # Ensure the file is closed before attempting to delete it
            for handler in logging.root.handlers[:]:
                handler.close()
                logging.root.removeHandler(handler)
            os.remove(self.play_by_play_file)
            print(f"Deleted existing play-by-play file: {self.play_by_play_file}")


# File: .\craps\roll_history_manager.py

import os
import csv
from typing import List, Dict, Any, Optional

class RollHistoryManager:
    def __init__(self, output_folder: str = "output", roll_history_file: str = "single_session_roll_history.csv") -> None:
        self.output_folder: str = output_folder
        self.roll_history_file: str = os.path.join(output_folder, roll_history_file)

    def ensure_output_folder_exists(self) -> None:
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def delete_roll_history_file(self) -> None:
        """Delete the roll history file if it exists."""
        if os.path.exists(self.roll_history_file):
            os.remove(self.roll_history_file)
            print(f"Deleted existing roll history file: {self.roll_history_file}")

    def save_roll_history(self, roll_history: List[Dict[str, Any]]) -> None:
        """
        Save the roll history to a CSV file.

        :param roll_history: A list of dictionaries representing the roll history.
        """
        self.ensure_output_folder_exists()
        with open(self.roll_history_file, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ["shooter_num", "roll_number", "dice", "total", "phase", "point"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            # Write the header
            writer.writeheader()

            # Write the roll history
            for roll in roll_history:
                writer.writerow(roll)

        print(f"Roll history saved to: {self.roll_history_file}")

    def load_roll_history(self) -> List[Dict[str, Any]]:
        """
        Load the roll history from a CSV file.

        :return: A list of dictionaries representing the roll history.
        """
        if not os.path.exists(self.roll_history_file):
            raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found.")

        roll_history: List[Dict[str, Any]] = []
        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to integers
                row["roll_number"] = int(row["roll_number"])
                row["shooter_num"] = int(row["shooter_num"])
                row["dice"] = [int(die) for die in row["dice"].strip('[]').split(', ')]
                row["total"] = int(row["total"])
                roll_history.append(row)

        print(f"Roll history loaded from: {self.roll_history_file}")
        return roll_history

    def prepare_for_session(self, dice_mode: str) -> None:
        """
        Prepare for the session based on the session mode.

        :param dice_mode: The session mode ("live" or "history").
        :raises FileNotFoundError: If the roll history file is missing in history mode.
        """
        self.validate_dice_mode(dice_mode)
        self.ensure_output_folder_exists()

        if dice_mode == "live":
            self.delete_roll_history_file()
            print("Running session in 'live' mode with random rolls.")
        elif dice_mode == "history":
            if not os.path.exists(self.roll_history_file):
                raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found. Please run in 'live' mode first.")
            print(f"Running session in 'history' mode using roll history from: {self.roll_history_file}")

    def validate_dice_mode(self, dice_mode: str) -> None:
        """
        Validate the session mode.

        :param dice_mode: The session mode ("live" or "history").
        :raises ValueError: If the session mode is invalid.
        """
        if dice_mode not in ["live", "history"]:
            raise ValueError(f"Invalid dice_mode '{dice_mode}'. Must be 'live' or 'history'.")

    def get_roll_history_file(self, dice_mode: str) -> Optional[str]:
        """
        Get the roll history file based on the session mode.

        :param dice_mode: The session mode ("live" or "history").
        :return: The roll history file path if in "history" mode, otherwise None.
        """
        return self.roll_history_file if dice_mode == "history" else None


# File: .\craps\rules.py

from typing import Tuple, Optional

# ================================
# Bet Rules (Grouped by Category)
# ================================
BET_RULES = {
    "Line Bets": {
        "is_contract_bet": True,
        "valid_numbers": None,
        "Pass Line": {
            "linked_bet": "Pass Line Odds",
            "valid_phases": ["come-out"],
            "payout_ratio": "Even Money",
            "resolution": {
                "come_out_win": [7, 11],
                "come_out_lose": [2, 3, 12],
                "point_win": ["point_made"],
                "point_lose": [7]
            },
        },
        "Don't Pass": {
            "linked_bet": "Don't Pass Odds",
            "valid_phases": ["come-out"],
            "payout_ratio": "Even Money",
            "barred_numbers": [12],
            "resolution": {
                "come_out_win": [2, 3],
                "come_out_lose": [7, 11],
                "point_win": [7],
                "point_lose": ["point_made"]
            },
        },
        "Come": {
            "linked_bet": "Come Odds",
            "valid_phases": ["point"],
            "payout_ratio": "Even Money",
            "resolution": {
                "come_out_win": [7, 11],
                "come_out_lose": [2, 3, 12],
                "point_win": ["number_hit"],
                "point_lose": [7],
                "moves_on_roll": True,
            }
        },
        "Don't Come": {
            "linked_bet": "Don't Come Odds",
            "valid_phases": ["point"],
            "payout_ratio": "Even Money",
            "barred_numbers": [12],
            "resolution": {
                "come_out_win": [2, 3],
                "come_out_lose": [7, 11],
                "point_win": [7],
                "point_lose": ["number_hit"],
                "moves_on_roll": True,
            }
        },    },
    "Odds Bets": {
        "is_contract_bet": False,
        "valid_numbers": None,
        "Pass Line Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "True Odds",
            "resolution": {
                "point_win": ["point_made"],
                "point_lose": [7],
            }
        },
        "Don't Pass Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "Don't True Odds",
            "resolution": {
                "point_win": [7],
                "point_lose": ["point_made"],
            }
        },
        "Come Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "True Odds",
            "resolution": {
                "point_win": ["number_hit"],
                "point_lose": [7],
            }
        },
        "Don't Come Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "Don't True Odds",
            "resolution": {
                "point_win": [7],
                "point_lose": ["number_hit"],
            }
        },
    },
    "Place Bets": {
        "is_contract_bet": False,
        "valid_numbers": [4, 5, 6, 8, 9, 10],
        "Place": {
            "linked_bet": None,
            "valid_phases": ["point"],
            "payout_ratio": "Place Odds",
            "resolution": {
                "point_win": ["number_hit"],
                "point_lose": [7],
            }
        },
        "Don't Place": {
            "linked_bet": None,
            "valid_phases": ["point"],
            "payout_ratio": "Don't Place Odds",
            "resolution": {
                "point_win": [7],
                "point_lose": ["number_hit"],
            }
        },
        "Buy": {
            "linked_bet": None,
            "valid_phases": ["point"],
            "payout_ratio": "True Odds",
            "has_vig": True,
            "resolution": {
                "point_win": ["number_hit"],
                "point_lose": [7],
            }
        },
        "Lay": {
            "linked_bet": None,
            "valid_phases": ["point"],
            "payout_ratio": "Don't True Odds",
            "has_vig": True,
            "resolution": {
                "point_win": [7],
                "point_lose": ["number_hit"],
            }
        }
    },
    "Field Bets": {
        "is_contract_bet": False,
        "always_working": True,
        "valid_numbers": None,
        "Field": {
            "linked_bet": None,
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Field",
            "resolution": {
                "come_out_win": [2, 3, 4, 9, 10, 11, 12],
                "come_out_lose": [5, 6, 7, 8],
                "point_win": [2, 3, 4, 9, 10, 11, 12],
                "point_lose": [5, 6, 7, 8],
            }
        },
    },
    "Other Bets": {
        "is_contract_bet": False,
        "valid_numbers": None,
        "Proposition": {
            "valid_numbers": [2, 3, 7, 11, 12],
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Proposition",
            "resolution": {
                "come_out_win": ["number_hit"],
                "come_out_lose": ["any_other"], 
                "point_win": ["number_hit"],
                "point_lose": ["any_other"],
            },
        },
        "Hardways": {
            "valid_numbers": [4, 6, 8, 10],
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Hardways",
            "resolution": {
                "come_out_win": ["hardway_win"],
                "come_out_lose": ["hardway_lose"],
                "point_win": ["hardway_win"],
                "point_lose": ["hardway_lose"],
            },
        },
        "Hop": {
            "valid_numbers": [
                (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6),
                (2, 2), (2, 3), (2, 4), (2, 5), (2, 6),
                (3, 3), (3, 4), (3, 5), (3, 6),
                (4, 4), (4, 5), (4, 6),
                (5, 5), (5, 6),
                (6, 6)
            ],
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Hop",
            "resolution": {
                "come_out_win": ["hop_win"],
                "come_out_lose": ["hop_lose"],
                "point_win": ["hop_win"],
                "point_lose": ["hop_lose"],
            },
        },
        "All Tall Small Bets": {
            "is_contract_bet": False,
            "valid_numbers": None,
            "Small": {
                "linked_bet": None,
                "valid_phases": ["come-out"],
                "payout_ratio": (34, 1),
                "resolution": {
                    "win_condition": ["small_complete"],
                    "lose_condition": [7],
                },
            },
            "Tall": {
                "linked_bet": None,
                "valid_phases": ["come-out"],
                "payout_ratio": (34, 1),
                "resolution": {
                    "win_condition": ["tall_complete"],
                    "lose_condition": [7],
                },
            },
            "All": {
                "linked_bet": None,
                "valid_phases": ["come-out"],
                "payout_ratio": (175, 1),
                "resolution": {
                    "win_condition": ["all_complete"],
                    "lose_condition": [7],
                },
            },
        },
    }
}

# ================================
# Payout Ratios (Now a Function)
# ================================

BET_PAYOUT = {
    "Even Money": {
        "default": (1, 1)
    },
    "True Odds": {
        4: (2, 1),
        5: (3, 2),
        6: (6, 5),
        8: (6, 5),
        9: (3, 2),
        10: (2, 1),
    },
    "Place Odds": {
        4: (9, 5),
        5: (7, 5),
        6: (7, 6),
        8: (7, 6),
        9: (7, 5),
        10: (9, 5),
    },
    "Don't True Odds": {
        4: (1, 2),
        5: (2, 3),
        6: (5, 6),
        8: (5, 6),
        9: (2, 3),
        10: (1, 2),
    },
    "Don't Place Odds": {
        4: (5, 9),
        5: (5, 7),
        6: (6, 7),
        8: (6, 7),
        9: (5, 7),
        10: (5, 9),
    },
    "Field": {
        2: (2, 1),
        3: (1, 1),
        4: (1, 1),
        9: (1, 1),
        10: (1, 1),
        11: (1, 1),
        12: (3, 1),
    },
    "Proposition": {
        2: (30, 1),
        3: (15, 1),
        7: (4, 1),
        11: (15, 1),
        12: (30, 1),
    },
    "Hardways": {
        4: (8, 1),
        6: (10, 1),
        8: (10, 1),
        10: (8, 1),
    },
    "Hop": {
        (1, 1): (30, 1),
        (1, 2): (15, 1),
        (1, 3): (15, 1),
        (2, 2): (30, 1),
        (2, 3): (15, 1),
        (2, 4): (15, 1),
        (3, 3): (30, 1),
        (3, 4): (15, 1),
        (3, 5): (15, 1),
        (4, 4): (30, 1),
        (4, 5): (15, 1),
        (4, 6): (15, 1),
        (5, 5): (30, 1),
        (5, 6): (15, 1),
        (6, 6): (30, 1),
    }
}
ODDS_MULTIPLIERS = {
    "1x": {4: 1, 5: 1, 6: 1, 8: 1, 9: 1, 10: 1},
    "2x": {4: 2, 5: 2, 6: 2, 8: 2, 9: 2, 10: 2},
    "1x-2x-3x": {4: 1, 5: 2, 6: 3, 8: 3, 9: 2, 10: 1},
    "3x-4x-5x": {4: 3, 5: 4, 6: 5, 8: 5, 9: 4, 10: 3},
    "10x": {4: 10, 5: 10, 6: 10, 8: 10, 9: 10, 10: 10},
    "20x": {4: 20, 5: 20, 6: 20, 8: 20, 9: 20, 10: 20},
    "100x": {4: 100, 5: 100, 6: 100, 8: 100, 9: 100, 10: 100},
}


# File: .\craps\rules_engine.py

from typing import List, Optional, Dict, Any, Tuple, Union
from craps.rules import BET_RULES, BET_PAYOUT
from craps.bet import Bet
from craps.game_state import GameState

class RulesEngine:
    """A rules engine for handling bets based on the rules defined in rules.py."""

    @staticmethod
    def get_bet_rules(bet_type: str) -> Dict[str, Any]:
        """
        Retrieve the rules for a given bet type, including category-level attributes.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Field", "Hardways").
        :return: A dictionary containing the rules for the bet.
        """
        for category, bets in BET_RULES.items():
            if isinstance(bets, dict) and bet_type in bets:
                bet_rules = bets[bet_type].copy() if isinstance(bets[bet_type], dict) else {}
                category_rules = {k: v for k, v in bets.items() if not isinstance(v, dict)}
                return {**category_rules, **bet_rules}

        raise ValueError(f"Unknown bet type: {bet_type}")

    @staticmethod
    def get_linked_bet_type(bet_type: str) -> Optional[str]:
        """Returns the linked bet type, if any (e.g., Pass Line → Pass Line Odds)."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # ✅ Unified retrieval
        return bet_rules.get("linked_bet")

    @staticmethod
    def get_minimum_bet(bet_type: str, table: Any, number: int | None = None) -> int:
        """Returns the correct minimum bet amount for a given bet type based on table rules."""
        table_min = table.house_rules.table_minimum
        table_max = table.house_rules.table_maximum
        bet_rules = RulesEngine.get_bet_rules(bet_type) 
        
        # 🟢 **Base Minimum Bet: All bets must be at least $1**
        min_bet = 1

        # 🟢 **Line & Field Bets: Must be within table min & max**
        if bet_rules.get("is_contract_bet", False) or bet_type == "Field":
            min_bet = max(table_min, min_bet)  # Ensure at least table minimum
            return min(table_max, min_bet)  # Ensure it doesn't exceed table max

        # 🟢 **Prop, Hop, Hardways, Odds Bets: Can be as low as $1**
        elif bet_rules.get("valid_numbers") is not None and bet_type in ["Proposition", "Hardways", "Hop", "Odds"]:
            return min_bet  # No additional constraints

        # 🟢 **Place & Don't Place Bets: Special Case for 6 & 8**
        elif bet_type in ["Place", "Buy", "Lay"]:
            if number in [6, 8]:
                return table_min + (table_min // 5)  # $12 for $10 table minimum
            else:
                return table_min

        # 🟢 **Odds on 5 & 9: Must be Even for Correct Payouts**
        elif bet_type in ["Pass Line Odds", "Don't Pass Odds", "Come Odds", "Don't Come Odds"] and bet_rules.get("valid_numbers") == [5, 9]:
            return max(2, (table_min // 2) * 2)  # Round up to the nearest even number

        return min_bet  # Default minimum bet

    @staticmethod
    def get_bet_unit(bet_type: str, number: Optional[Union[int, Tuple[int, int]]]) -> int:
        if bet_type == "Place":
            if number in [6, 8]:
                return 6
            elif number in [5, 9, 4, 10]:
                return 5
            else:
                raise ValueError(f"Invalid Place number: {number}")
        # Add additional bet types as needed
        return 1  # Default fallback

    @staticmethod
    def create_bet(bet_type: str, amount: int, owner: Any, number: Optional[Union[int, Tuple[int, int]]] = None, parent_bet: Optional[Bet] = None) -> Bet:
        """Create a bet based on the bet type."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # ✅ Unified retrieval

        if not bet_rules:
            raise ValueError(f"Unknown bet type: {bet_type}")

        # ✅ Check if the number is valid for this bet type (supports both int and tuple)
        valid_numbers = bet_rules.get("valid_numbers")  # Can be None, a list of ints, or a list of tuples

        if valid_numbers is None and number is not None and bet_type not in ["Come Odds", "Don't Come Odds"]:
            raise ValueError(f"{bet_type} bet should not have a number")
        if valid_numbers and number not in valid_numbers:
            raise ValueError(f"Invalid number {number} for bet type {bet_type}")

        if valid_numbers:
            if isinstance(valid_numbers[0], tuple):  # ✅ If the rule expects tuples (e.g., Hop bets)
                if not isinstance(number, tuple) or number not in valid_numbers:
                    raise ValueError(f"Invalid tuple {number} for bet type {bet_type}")
            elif not isinstance(number, int) or number not in valid_numbers:  # ✅ If the rule expects a single number
                raise ValueError(f"Invalid number {number} for bet type {bet_type}")

        payout_ratio: Tuple[int, int] = RulesEngine.get_payout_ratio(bet_type, number) or (1, 1)

        return Bet(
            bet_type=bet_type,
            amount=amount,
            owner=owner,
            payout_ratio=payout_ratio,
            valid_phases=bet_rules["valid_phases"],
            number=number,
            parent_bet=parent_bet,
            is_contract_bet=bet_rules.get("is_contract_bet", False),
            vig=bet_rules.get("has_vig", False),
            unit = RulesEngine.get_bet_unit(bet_type, number),
        )

    @staticmethod
    def can_make_bet(bet_type: str, phase: str, number: Optional[int] = None) -> bool:
        """Check if a bet can be placed in the given phase and with a specific number."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # ✅ Get the rules
        
        # ✅ Check valid phases (no change)
        if phase not in bet_rules["valid_phases"]:
            return False

        # ✅ Only check valid numbers **if the bet type has them defined**
        valid_numbers = bet_rules.get("valid_numbers")  # Get the valid numbers list
        if valid_numbers is not None and number is not None and number not in valid_numbers:
            return False  # ❌ Reject invalid numbers

        return True  # ✅ Bet is valid

    @staticmethod
    def can_turn_on(bet_type: str, phase: str) -> bool:
        """Determine if a bet of the given type can be turned on during the current phase."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # ✅ Unified retrieval
        return bet_rules.get("can_turn_on", False)
    
    @staticmethod
    def can_remove_bet(bet_type: str) -> bool:
        """
        Determine if a bet of the given type can be removed.
        Contract bets cannot be removed once placed.
        """
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # ✅ Fetch all bet rules in one go
        return not bet_rules.get("is_contract_bet", False)  # ❌ Contract bets cannot be removed

    @staticmethod
    def get_payout_ratio(bet_type: str, number: Optional[Union[int, Tuple[int, int]]] = None) -> Tuple[int, int]:
        """Get the payout ratio for a bet based on its type and number (if applicable)."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)
        payout_key = bet_rules.get("payout_ratio")

        # Ensure payout_key exists and its value in BET_PAYOUT is a dictionary
        if payout_key in BET_PAYOUT:
            payout_data = BET_PAYOUT[payout_key]
            if isinstance(payout_data, dict):
                # Case 1: If no number is provided, return the default payout ratio
                if number is None:
                    return payout_data.get("default", (1, 1))

                # Case 2: If number is an integer (e.g., True Odds, Place Bets)
                if isinstance(number, int):
                    return payout_data.get(number, payout_data.get("default", (1, 1)))

                # Case 3: If number is a tuple (e.g., Hop bets)
                if isinstance(number, tuple):
                    return payout_data.get(number, payout_data.get("default", (1, 1)))

        raise ValueError(f"Invalid payout type {payout_key} for bet {bet_type} (number={number})")

    @staticmethod
    def resolve_bet(bet: Bet, dice_outcome: Tuple[int, int], phase: str, point: Optional[int]) -> int:
        """
        Resolves a bet based on the dice outcome, phase, and point.
        Uses a structured approach based on bet categories.
        """
        total = sum(dice_outcome)
        is_pair = dice_outcome[0] == dice_outcome[1]
        sorted_dice = tuple(sorted(dice_outcome))
        bet_rules = RulesEngine.get_bet_rules(bet.bet_type)  # ✅ Unified retrieval
        resolution_rules = bet_rules["resolution"]
        phase_key = phase.replace("-", "_")
        winning_numbers = resolution_rules.get(f"{phase_key}_win", [])
        losing_numbers = resolution_rules.get(f"{phase_key}_lose", [])

        # ✅ Only resolve ACTIVE bets
        if bet.status != "active":
            return 0
        
        # 🎯 **1. LINE BETS (Pass Line, Don't Pass, Come, Don't Come)**
        if bet_rules.get("is_contract_bet", False):
            # 🏆 **Come/Don't Come Special Case - Handle First Roll**
            if bet.bet_type in ["Come", "Don't Come"]:
                if bet.number is None:  # Come bet in come-out mode
                    come_out_win = resolution_rules.get("come_out_win", [])
                    come_out_lose = resolution_rules.get("come_out_lose", [])
                    barred = bet_rules.get("barred_numbers", [])

                    if total in come_out_win:
                        bet.status = "won"
                    elif total in come_out_lose:
                        bet.status = "lost"
                    elif total in barred:
                        pass # Bet is barred on this number
                    else:
                        bet.number = total  # Bet moved to number
                else:  # Come bet in point mode
                    if "number_hit" in winning_numbers and total == bet.number:
                        bet.status = "won"
                    elif total in winning_numbers:
                        bet.status = "won"
                    elif "number_hit" in losing_numbers and total == bet.number:
                        bet.status = "lost"
                    elif total in losing_numbers:
                        bet.status = "lost"

            else:  # Pass Line / Don't Pass logic
                # Win conditions
                if "number_hit" in winning_numbers and bet.number is not None and total == bet.number:
                    bet.status = "won"
                elif "point_made" in winning_numbers and point is not None and total == point:
                    bet.status = "won"
                elif total in winning_numbers:
                    bet.status = "won"

                # Loss conditions
                elif "number_hit" in losing_numbers and bet.number is not None and total == bet.number:
                    bet.status = "lost"
                elif "point_made" in losing_numbers and point is not None and total == point:
                    bet.status = "lost"
                elif total in losing_numbers:
                    bet.status = "lost"

        ### 🎯 **2. FIELD BETS**
        elif bet.bet_type == "Field":
            if total in winning_numbers:
                bet.status = "won"
                bet.number = total
            elif total in losing_numbers:
                bet.status = "lost"

        ### 🎯 **3. PLACE, BUY, LAY BETS (Follow Rule Definitions)**
        elif bet.bet_type in ("Place", "Buy", "Lay"):
            winning_numbers = resolution_rules.get(f"{phase_key}_win", [])
            losing_numbers = resolution_rules.get(f"{phase_key}_lose", [])

            # ✅ Win if the rolled total matches the "number_hit" or is in "point_win"
            if "number_hit" in winning_numbers and total == bet.number:
                bet.status = "won"
            elif total in winning_numbers:
                bet.status = "won"

            # ✅ Lose if total is in "point_lose"
            elif "number_hit" in losing_numbers and total == bet.number:
                bet.status = "lost"
            elif total in losing_numbers:
                bet.status = "lost"
                
        ### 🎯 **4. PROPOSITION BETS**
        elif bet.bet_type == "Proposition":
            if "number_hit" in resolution_rules.get(f"{phase_key}_win", []) and total == bet.number:
                bet.status = "won"
            elif "any_other" in resolution_rules.get(f"{phase_key}_lose", []) and total != bet.number:
                bet.status = "lost"

        ### 🎯 **5. HARDWAYS**
        elif bet.bet_type == "Hardways":
            if "hardway_win" in resolution_rules.get(f"{phase_key}_win", []):
                if total == bet.number and is_pair:
                    bet.status = "won"

            if "hardway_lose" in resolution_rules.get(f"{phase_key}_lose", []):
                if total == 7 or (total == bet.number and not is_pair):  # ✅ Easy way loses
                    bet.status = "lost"

        ### 🎯 **6. HOP BETS**
        elif bet.bet_type == "Hop":
            hop_payouts = BET_PAYOUT.get("Hop", {})

            if not isinstance(hop_payouts, dict):
                raise TypeError(f"Expected dict for Hop payouts, got {type(hop_payouts)}")

            # Normalize dice order for lookup
            sorted_dice = tuple(sorted(dice_outcome))

            # Ensure bet.number is a tuple and check both (X, Y) and (Y, X)
            if isinstance(bet.number, tuple):
                if sorted_dice == tuple(sorted(bet.number)):
                    bet.status = "won"
                else:
                    bet.status = "lost"

        ### 🎯 **7. ODDS BETS**
        elif bet.bet_type in ["Pass Line Odds", "Come Odds", "Don't Pass Odds", "Don't Come Odds"]:
            if bet.parent_bet and bet.parent_bet.status == "won":
                bet.status = "won"

                # 🧠 Assign number based on parent for correct payout ratio
                if bet.number is None:
                    if bet.parent_bet.bet_type == "Pass Line":
                        bet.number = point  # Set to the current point
                    elif bet.parent_bet.bet_type == "Come":
                        bet.number = bet.parent_bet.number  # Set to the come number

            elif bet.parent_bet and bet.parent_bet.status == "lost":
                bet.status = "lost"

        ### 🎯 **Calculate Payout if Won**
        payout = RulesEngine.calculate_payout(bet, total) if bet.status == "won" else 0
        return payout

    @staticmethod
    def calculate_payout(bet: Bet, roll: Optional[int] = None) -> int:
        """
        Calculate the payout for a resolved bet.
        """
        if bet.status != "won":
            return 0  # ✅ No payout if the bet didn't win

        # Ensure the correct roll value is used for bets that depend on it (e.g., Field)
        number = roll if bet.bet_type == "Field" else bet.number

        # ✅ Field bets should only request payout if they actually won
        field_payouts = BET_PAYOUT.get("Field", {})

        if not isinstance(field_payouts, (dict, list, set)):
            raise TypeError(f"Expected dict, list, or set for Field payouts, got {type(field_payouts)}")

        if bet.bet_type == "Field" and number not in field_payouts:
            return 0  # ✅ If the number isn't a winning Field number, payout is $0

        payout_ratio = RulesEngine.get_payout_ratio(bet.bet_type, number)
        numerator, denominator = payout_ratio
        profit = (bet.amount * numerator) // denominator

        return profit

    @staticmethod
    def has_vig(bet_type: str) -> bool:
        """Determine if a bet of the given type has a vig (commission)."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # ✅ Unified retrieval
        return bet_rules.get("vig", False)

    @staticmethod
    def get_odds_multiplier(odds_type: str, point: Optional[int] = None) -> Optional[int]:
        """Retrieve the odds multiplier from the rules based on the specified odds type and point number."""
        from craps.rules import ODDS_MULTIPLIERS  # Ensure we're always using the latest rules
        
        if odds_type not in ODDS_MULTIPLIERS:
            raise ValueError(f"Unknown odds type: {odds_type}")

        multiplier_data = ODDS_MULTIPLIERS[odds_type]

        if isinstance(multiplier_data, dict):
            return multiplier_data.get(point) if point is not None else None
        return multiplier_data  # Return the multiplier directly if it's a flat value

    @staticmethod
    def is_odds_eligible(bet: Bet, game_state: GameState) -> bool:
        if not bet.linked_bet:
            return False

        base_type = bet.linked_bet.bet_type
        if base_type == "Pass Line":
            return game_state.phase == "point"
        if base_type == "Come":
            return game_state.phase == "point" and bet.linked_bet.number is not None
        if base_type == "Don't Pass":
            return game_state.phase == "point"
        if base_type == "Don't Come":
            return game_state.phase == "point" and bet.linked_bet.number is not None
        return False


# File: .\craps\session_initializer.py

from typing import Tuple, Optional
from craps.house_rules import HouseRules
from craps.table import Table
from craps.roll_history_manager import RollHistoryManager
from craps.log_manager import LogManager
from craps.play_by_play import PlayByPlay
from craps.rules_engine import RulesEngine
from craps.statistics import Statistics
from craps.game_state import GameState
from craps.lineup import PlayerLineup
from craps.statistics_report import StatisticsReport
class InitializeSession:
    def __init__(
        self, 
        dice_mode: str, 
        house_rules: HouseRules,
        play_by_play: PlayByPlay, 
        rules_engine: RulesEngine, 
        player_lineup: PlayerLineup,
        log_manager: Optional[LogManager] = None
    ) -> None:
        """
        Initialize the session.

        :param dice_mode: The session mode ("live" or "history").
        :param house_rules: The HouseRules instance of the session.
        :param play_by_play: The PlayByPlay instance for logging session messages.
        :param rules_engine: The RulesEngine instance to use for the session.
        :param log_manager: The LogManager instance for managing session logs.
        """
        self.dice_mode: str = dice_mode
        self.house_rules: HouseRules = house_rules
        self.roll_history_manager: RollHistoryManager = RollHistoryManager()
        self.log_manager = log_manager or LogManager()
        self.play_by_play: PlayByPlay = play_by_play
        self.rules_engine: RulesEngine = rules_engine
        self.player_lineup: PlayerLineup = player_lineup

    def prepare_session(
        self, num_shooters: int, num_players: int
    ) -> Optional[Tuple[HouseRules, Table, RollHistoryManager, LogManager, PlayByPlay, Statistics, GameState]]:
        """Prepare the session based on the session mode."""
        try:
            self.roll_history_manager.prepare_for_session(self.dice_mode)
        except (ValueError, FileNotFoundError) as e:
            print(f"Error: {e}")
            return None

        table = Table(self.house_rules, self.play_by_play, self.rules_engine, self.player_lineup)

        # Initialize Statistics and GameState
        stats = Statistics(self.house_rules.table_minimum, num_shooters, num_players)
        game_state = GameState(stats, play_by_play=self.play_by_play)
        game_state.set_table(table)

        # Delete the existing log file before starting the session
        self.log_manager.delete_log_file()

        # Clear the play-by-play file before starting the session
        self.play_by_play.clear_play_by_play_file()

        # Clear the Statistics Report before starting the session        
        StatisticsReport().clear_statistics_file()

        return self.house_rules, table, self.roll_history_manager, self.log_manager, self.play_by_play, stats, game_state


# File: .\craps\session_manager.py

from typing import Optional, Any
from config import HOUSE_RULES, ACTIVE_PLAYERS, DICE_TEST_PATTERNS
from craps.house_rules import HouseRules
from craps.log_manager import LogManager
from craps.play_by_play import PlayByPlay
from craps.rules_engine import RulesEngine
from craps.session_initializer import InitializeSession
from craps.lineup import PlayerLineup
from craps.dice import Dice
from craps.table import Table
from craps.roll_history_manager import RollHistoryManager
from craps.statistics import Statistics
from craps.game_state import GameState
from craps.player import Player


class SessionManager:
    def __init__(self) -> None:
        self.house_rules: Optional[HouseRules] = None
        self.table: Optional[Table] = None
        self.roll_history_manager: Optional[RollHistoryManager] = None
        self.log_manager: Optional[LogManager] = None
        self.play_by_play: Optional[PlayByPlay] = None
        self.rules_engine: Optional[RulesEngine] = None
        self.stats: Optional[Statistics] = None
        self.game_state: Optional[GameState] = None
        self.player_lineup: Optional[PlayerLineup] = None
        self.dice: Optional[Dice] = None
        self.initialized: bool = False
        self.locked: bool = False
        self.shooter_index: int = 0
        self.roll_history: list[dict[str, Any]] = []

    def setup_session(
        self,
        house_rules_dict: Optional[dict[str, Any]] = None,
        num_shooters: int = 10,
        num_players: int = 0,
        session_mode: str = "interactive",
        dice_mode: str = "live",
        roll_history_file: Optional[str] = None,
        pattern_name: Optional[str] = None
    ) -> bool:
        """
        Initializes core game components and prepares the session.
        """
        self.house_rules = HouseRules(house_rules_dict or HOUSE_RULES)
        self.play_by_play = PlayByPlay()
        self.log_manager = LogManager()
        self.rules_engine = RulesEngine()
        self.player_lineup = PlayerLineup(self.house_rules, None, self.play_by_play, self.rules_engine)

        # ✅ Initialize Dice
        if dice_mode == "history" and roll_history_file:
            self.dice = Dice(roll_history_file)
        else:
            self.dice = Dice()
            if dice_mode == "pattern" and pattern_name in DICE_TEST_PATTERNS:
                self.dice.forced_rolls.extend(DICE_TEST_PATTERNS[pattern_name])

        # ✅ Initialize Session
        session_initializer = InitializeSession(
            dice_mode=dice_mode,
            house_rules=self.house_rules,
            play_by_play=self.play_by_play,
            log_manager=self.log_manager,
            rules_engine=self.rules_engine,
            player_lineup=self.player_lineup
        )

        session_data = session_initializer.prepare_session(num_shooters, num_players)

        if session_data is None:
            return False

        (
            self.house_rules,
            self.table,
            self.roll_history_manager,
            self.log_manager,
            self.play_by_play,
            self.stats,
            self.game_state
        ) = session_data

        self.initialized = True
        return True

    def add_players_from_config(self) -> int:
        """
        Add players based on the ACTIVE_PLAYERS dict in config.py.
        UI or CLI setup should modify this config ahead of time.
        """
        if not self.player_lineup:
            raise RuntimeError("Session must be initialized before adding players.")

        players = [
            Player(name=player_name, strategy_name=strategy_name)
            for player_name, (strategy_name, enabled) in ACTIVE_PLAYERS.items() if enabled
        ]

        self.player_lineup.assign_strategies(players)
        return len(players)

    def lock_session(self) -> None:
        """
        Lock the session to prevent further changes to players or rules.
        """
        if not self.initialized:
            raise RuntimeError("Session must be initialized before it can be locked.")
        self.locked = True
        
        if not self.player_lineup or not self.play_by_play:
            raise RuntimeError("SessionManager is missing required components.")

    def accept_bets(self) -> int:
        if not self.locked:
            raise RuntimeError("Session must be locked before accepting bets.")
        if not self.play_by_play or not self.game_state or not self.table or not self.player_lineup:
            return 0

        self.play_by_play.write("  ---------- Place Your Bets! -------------")
        total_bets = 0

        for player in self.player_lineup.get_active_players_list():
            if not player.betting_strategy:
                continue

            bets = player.betting_strategy.place_bets(
                game_state=self.game_state,
                player=player,
                table=self.table
            )

            if bets:
                success = player.place_bet(
                    bets,
                    table=self.table,
                    phase=self.game_state.phase,
                    play_by_play=self.play_by_play
                )
                if success:
                    total_bets += len(bets) if isinstance(bets, list) else 1

        return total_bets

    def roll_dice(self) -> tuple[int, int]:
        if not (self.dice and self.stats and self.table and self.play_by_play and self.roll_history_manager and self.game_state and self.player_lineup):
            raise RuntimeError("SessionManager missing required components for rolling dice.")

        outcome = self.dice.roll()
        total = sum(outcome)

        players = self.player_lineup.get_active_players_list()
        shooter = players[self.shooter_index % len(players)]
        self.stats.update_rolls(total=total, table_risk=self.table.total_risk())
        self.stats.update_shooter_stats(shooter)

        roll_number = self.stats.session_rolls
        roll_message = f"  🎲 Roll #{roll_number} → {outcome} = {total}"
        self.play_by_play.write(roll_message)

        self.roll_history.append({
            "shooter_num": self.shooter_index + 1,
            "roll_number": roll_number,
            "dice": outcome,
            "total": total,
            "phase": self.game_state.phase,
            "point": self.game_state.point
        })

        return outcome
    
    def resolve_bets(self, outcome: tuple[int, int]) -> None:
        if not (self.table and self.game_state and self.stats and self.play_by_play and self.house_rules):
            raise RuntimeError("Missing components for resolving bets.")

        # Step 1: Check active bets
        self.table.check_bets(outcome, self.game_state.phase, self.game_state.point)

        # Step 2: Settle resolved bets
        resolved_bets = self.table.settle_resolved_bets()

        # Step 3: Update win/loss stats
        for bet in resolved_bets:
            self.stats.update_win_loss(bet)

            # Step 4: Notify strategy if bet won
            if bet.status == "won":
                payout = bet.resolved_payout
                strategy = getattr(bet.owner, "betting_strategy", None)
                if strategy and hasattr(strategy, "notify_payout"):
                    strategy.notify_payout(payout)

        # Step 5: Remove winning bets based on house rules
        for bet in resolved_bets:
            if bet.status == "won" and bet in self.table.bets:
                if bet.is_contract_bet or not self.house_rules.leave_winning_bets_up:
                    self.table.bets.remove(bet)
        
        # Step 6: Update game state
        previous_phase = self.game_state.phase
        state_message = self.game_state.update_state(outcome)
        self.play_by_play.write(state_message)

    def adjust_bets(self) -> None:
        """Let each strategy adjust bets after resolution (before next roll)."""
        if not self.game_state or not self.player_lineup or not self.table:
            raise RuntimeError("Missing game components for adjusting bets.")

        for player in self.player_lineup.get_active_players_list():
            strategy = getattr(player, "betting_strategy", None)
            if strategy and hasattr(strategy, "adjust_bets"):
                strategy.adjust_bets(self.game_state, player, self.table)

    def is_seven_out(self, outcome: tuple[int, int]) -> bool:
        return (
            self.game_state is not None
            and self.game_state.phase == "point"
            and sum(outcome) == 7
        )

    def handle_seven_out(self) -> None:
        if not self.stats or not self.game_state or not self.player_lineup:
            return

        self.stats.record_seven_out()
        self.game_state.clear_shooter()

        for player in self.player_lineup.get_active_players_list():
            strategy = getattr(player, "betting_strategy", None)
            if strategy and hasattr(strategy, "on_new_shooter"):
                strategy.on_new_shooter()

        self.assign_next_shooter()

    def assign_next_shooter(self) -> None:
        if not self.game_state or not self.player_lineup:
            return

        players = self.player_lineup.get_active_players_list()
        if not players:
            return

        next_shooter = players[self.shooter_index % len(players)]
        self.game_state.assign_new_shooter(next_shooter, self.shooter_index + 1)


# File: .\craps\simulation_manager.py

from typing import List
from craps.single_session import run_single_session
from craps.house_rules import HouseRules
from craps.statistics import Statistics
from craps.view_log import InteractiveLogViewer
class SimulationManager:
    def __init__(self, house_rules: HouseRules, num_tables: int, num_shooters: int, strategies: List):
        """
        Initialize the SimulationManager.
        
        :param house_rules: The HouseRules object for payout rules and limits.
        :param num_tables: The number of tables to simulate.
        :param num_shooters: The number of shooters per session.
        :param strategies: A list of betting strategies to evaluate.
        """
        self.house_rules = house_rules
        self.num_tables = num_tables
        self.num_shooters = num_shooters
        self.strategies = strategies
        self.stats = Statistics(house_rules.table_minimum, num_shooters, len(strategies))

    def run_simulation(self, num_sessions: int) -> None:
        """Run multiple sessions and collect statistics."""
        for _ in range(num_sessions):
            for _ in range(self.num_tables):
                stats = run_single_session(self.house_rules, self.strategies, num_shooters=self.num_shooters)
                self.stats.merge(stats)  # Merge session stats into overall stats

        # View the statistics report
        log_viewer = InteractiveLogViewer()
        log_viewer.view("output/statistics_report.txt")
        self.stats.print_shooter_report()


# File: .\craps\single_session.py

from typing import List, Optional, Any
from config import HOUSE_RULES, DICE_TEST_PATTERNS
from craps.dice import Dice
from craps.statistics import Statistics
from craps.house_rules import HouseRules
from craps.log_manager import LogManager
from craps.session_initializer import InitializeSession
from craps.rules_engine import RulesEngine
from craps.play_by_play import PlayByPlay
from craps.player_setup import SetupPlayers
from craps.lineup import PlayerLineup
from craps.statistics_report import StatisticsReport
from craps.view_log import InteractiveLogViewer
from craps.visualizer import Visualizer
import os

def run_single_session(
    house_rules: Optional[HouseRules] = None,
    strategies: Optional[List[Any]] = None,
    num_shooters: Optional[int] = 10, 
    roll_history_file: Optional[str] = None,
    pattern_name: Optional[str] = None) -> Statistics:
    """
    Run a single session of craps and log the roll history.
    """
    # ✅ Set the house_rules
    if house_rules is None:
        house_rules = HouseRules(HOUSE_RULES)

    # Set dice mode
    dice = Dice(roll_history_file) if roll_history_file and os.path.exists(roll_history_file) else Dice()
    if pattern_name and pattern_name in DICE_TEST_PATTERNS:
        dice.forced_rolls.extend(DICE_TEST_PATTERNS[pattern_name])

        # ✅ Initialize session-level objects
    rules_engine = RulesEngine()
    play_by_play = PlayByPlay()
    log_manager = LogManager()
    player_lineup = PlayerLineup(house_rules, None, play_by_play, rules_engine)

    # ✅ Initialize players via SetupPlayers
    strategies = strategies or []
    players = SetupPlayers().setup()

    # ✅ Validate players exist
    if not players:
        play_by_play.clear_play_by_play_file()
        play_by_play.write("⚠️ No active players configured. Exiting session early.")
        return Statistics(
            table_minimum=house_rules.table_minimum,
            num_shooters=num_shooters or 10,
            num_players=0
        )
    
    # ✅ Assign player strategies
    player_lineup.assign_strategies(players)
    
    # ✅ Initialize the Session
    session_initializer = InitializeSession(
        dice_mode="live",
        house_rules=house_rules,
        play_by_play=play_by_play,
        log_manager=log_manager,
        rules_engine=rules_engine,
        player_lineup=player_lineup
    )
    
    session_data = session_initializer.prepare_session(
        num_shooters or 10,  # ✅ Default if None
        len(strategies or [])  # ✅ Safe check for None
    )

    if session_data is None:
        raise RuntimeError("Failed to initialize session.")

    house_rules, table, roll_history_manager, log_manager, play_by_play, stats, game_state = session_data
    
    # ✅ Set num_players now that players are loaded
    stats.num_players = len(players)

    # ✅ Initialize bankroll & at_risk history
    stats.initialize_bankroll_history(players)
    stats.initialize_at_risk_history(players)

    # ✅ Initialize roll history
    roll_history = []

    # ✅ Initialize player stats...   
    stats.initialize_player_stats(players)

    # ✅ Simulate shooters
    if num_shooters is None:
        num_shooters = 10

    for shooter_num in range(1, num_shooters + 1):
        player_index = (shooter_num - 1) % len(players)  # ✅ Safe calculation
        shooter = players[player_index]

        # Assign new shooter via GameState
        game_state.assign_new_shooter(shooter, shooter_num)

        # Inform strategies of new shooter
        for player in players:
            strategy = getattr(player, "betting_strategy", None)
            if strategy and hasattr(strategy, "on_new_shooter"):
                strategy.on_new_shooter()

        while True:
            # Allow all players to place bets
            play_by_play.write(f"  ---------- Place Your Bets! -------------")
            for player in players:
                bets = player.betting_strategy.place_bets(game_state, player, table)
                if bets:
                    player.place_bet(bets, table, game_state.phase, play_by_play)

            # Roll the dice and resolve bets
            outcome = dice.roll()  # Now returns Tuple[int, int]
            total = sum(outcome)
            stats.update_rolls(total=total, table_risk=table.total_risk())
            stats.update_shooter_stats(shooter)

            # Log the roll
            roll_message = f"  🎲 Roll #{stats.session_rolls} → {outcome} = {total}"
            play_by_play.write(roll_message)

            # Log the roll to the history
            roll_history.append({
                "shooter_num": shooter_num,
                "roll_number": stats.session_rolls,
                "dice": outcome,
                "total": total,
                "phase": game_state.phase,
                "point": game_state.point
            })

            # Check bets on the table
            table.check_bets(outcome, game_state.phase, game_state.point)

            # Settle resolved bets & update stats & notify strategies of payout
            resolved_bets = table.settle_resolved_bets()
            for bet in resolved_bets:
                stats.update_win_loss(bet)
                if bet.status == "won":
                    payout = bet.resolved_payout
                    strategy = getattr(bet.owner, "betting_strategy", None)
                    if strategy and hasattr(strategy, "notify_payout"):
                        strategy.notify_payout(payout)
            
            # 🧼 Remove winning bets that must come down (contract or per house rules)
            for bet in resolved_bets:
                if bet.status == "won" and bet in table.bets:
                    if bet.is_contract_bet or not house_rules.leave_winning_bets_up:
                        table.bets.remove(bet)
                        
            # Update the game state
            previous_phase = game_state.phase
            state_message = game_state.update_state(outcome)
            play_by_play.write(state_message)
            
            # 💡 Adjust bets after resolution (if strategy supports it)
            for player in players:
                if hasattr(player.betting_strategy, "adjust_bets"):
                    player.betting_strategy.adjust_bets(game_state, player, table)

            # 🧼 For remaining Place/Buy/Lay bets, set status based on puck + house rules
            for bet in table.bets:
                strategy = getattr(bet.owner, "betting_strategy", None)
                is_turned_off = getattr(strategy, "turned_off", False)

                if bet.bet_type == "Field":
                    bet.status = "active"
                
                elif bet.bet_type in ["Place", "Buy", "Lay"]:
                    if (game_state.phase == "point" or house_rules.leave_bets_working) and not is_turned_off:
                        bet.status = "active"
                    else:
                        bet.status = "inactive"
                
                elif bet.bet_type in ["Hop", "Hardways", "Proposition"]:
                    if bet.status == "won":
                        bet.status = "active"

            # 🛠️ Log current player bets
            for player in players:
                remaining_bets = [b for b in table.bets if b.owner == player]
                if remaining_bets:
                    summary = ", ".join(
                        f"{b.bet_type} {b.number} (${b.amount} {b.status})" for b in remaining_bets
                    )
                    bet_total = sum(b.amount for b in remaining_bets)
                    play_by_play.write(f"  📊 {player.name}'s remaining bets: {summary} | Total on table: ${bet_total} Bankroll: {player.balance}")

            # Update player bankrolls & risk history in statistics
            stats.update_player_bankrolls(players)
            stats.update_player_risk(players, table)

            # ✅ Handle "Point Made" (shooter stays)
            if previous_phase == "point" and total == game_state.point:
                game_state.clear_point()
                continue  # Shooter keeps shooting

            # ✅ Handle 7-Out (shooter ends)
            if previous_phase == "point" and total == 7:
                stats.record_seven_out()
                game_state.clear_shooter()  # Reset shooter status

                # Inform the strategies of a 7-out
                for player in players:
                    if hasattr(player.betting_strategy, "on_new_shooter"):
                        player.betting_strategy.on_new_shooter()

                break  # Next shooter

    # ✅ Wrap up Session
    stats.roll_history = roll_history
    stats.update_player_stats(players)
    statistics_report = StatisticsReport()
    statistics_report.write_statistics(stats)
    
    # View the play-by-play log
    log_viewer = InteractiveLogViewer()
    log_viewer.view(play_by_play.play_by_play_file)
    
    # View the statistics report
    log_viewer = InteractiveLogViewer()
    log_viewer.view("output/statistics_report.txt")

    # Visualize player bankrolls (only if there are players and rolls)
    if stats.num_players == 0 or stats.session_rolls == 0:
        print("⚠️ No data to visualize — skipping charts.")
    else:
        visualizer = Visualizer(stats)
        visualizer.visualize_bankrolls()

    return stats


# File: .\craps\statistics.py

import logging
from typing import List, Dict, Any, Optional

class Statistics:
    def __init__(self, table_minimum: int, num_shooters: int, num_players: int) -> None:
        self.table_minimum: int = table_minimum
        self.num_shooters: int = num_shooters
        self.num_players: int = num_players
        self.session_rolls: int = 0
        self.total_amount_bet: int = 0
        self.total_amount_won: int = 0
        self.total_amount_lost: int = 0
        self.session_highest_bankroll: int = 0
        self.session_lowest_bankroll: int = 1_000_000
        self.total_house_win_loss: int = 0
        self.total_player_win_loss: int = 0
        self.player_bankrolls: List[int] = []
        self.highest_bankroll: int = 0
        self.lowest_bankroll: int = 1_000_000
        self.max_table_risk: int = 0
        self.total_sevens: int = 0
        self.shooter_stats: Dict[int, Dict[str, Any]] = {}
        self.player_stats: Dict[str, Dict[str, Any]] = {}
        self.shooter: Optional[Any] = None
        self.shooter_num: Optional[int] = None
        self.roll_history: List[Dict[str, Any]] = []

        # For visualization
        self.roll_numbers: List[int] = [0]  # Start with roll 0
        self.bankroll_history: Dict[str, List[int]] = {}  # Track bankroll history for each player
        self.at_risk_history: Dict[str, List[int]] = {}  # Track at_risk history for each player
        self.seven_out_rolls: List[int] = []  # Track rolls where a 7-out occurs
        self.point_number_rolls: List[int] = []  # Track rolls where a point number (4, 5, 6, 8, 9, 10) is rolled
        
    def initialize_player_stats(self, players: List[Any]) -> None:
        """Initialize player statistics with their starting bankroll."""
        for player in players:
            self.player_stats[player.name] = {
                "initial_bankroll": player.balance,
                "final_bankroll": player.balance,
                "net_win_loss": 0,
                "bets_settled": 0,
                "bets_won": 0,
                "highest_bankroll": player.balance,
                "lowest_bankroll": player.balance,
            }
            
    def update_player_stats(self, players: List[Any]) -> None:
        """Update player statistics at the end of the session."""
        for player in players:
            if player.name in self.player_stats:
                self.player_stats[player.name]["final_bankroll"] = player.balance
                self.player_stats[player.name]["net_win_loss"] = (
                    player.balance - self.player_stats[player.name]["initial_bankroll"]
                )
    
    def set_shooter(self, shooter: Any, shooter_num: int) -> None:
        """Set the current shooter and their turn number."""
        self.shooter = shooter
        self.shooter_num = shooter_num  # Track the shooter's turn number
        if shooter_num not in self.shooter_stats:
            self.shooter_stats[shooter_num] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "shooter_rolls": 0,
            }
            
    def initialize_bankroll_history(self, players: List[Any]) -> None:
        """Initialize bankroll history with the starting bankroll for each player."""
        for player in players:
            self.bankroll_history[player.name] = [player.balance]  # Roll 0: initial bankroll

    def initialize_at_risk_history(self, players: List[Any]) -> None:
        """Initialize at_risk history as zero for each player."""
        for player in players:
            self.at_risk_history[player.name] = [0]  # Roll 0: initial risk

    def merge(self, other_stats: "Statistics") -> None:
        """Merge statistics from another session."""
        self.session_rolls += other_stats.session_rolls
        self.total_house_win_loss += other_stats.total_house_win_loss
        self.total_player_win_loss += other_stats.total_player_win_loss
        self.player_bankrolls.extend(other_stats.player_bankrolls)
        self.highest_bankroll = max(self.highest_bankroll, other_stats.highest_bankroll)
        self.lowest_bankroll = min(self.lowest_bankroll, other_stats.lowest_bankroll)
        self.roll_numbers.extend(other_stats.roll_numbers)
        self.seven_out_rolls.extend(other_stats.seven_out_rolls)
        self.point_number_rolls.extend(other_stats.point_number_rolls)

        # Merge shooter stats
        for shooter_name, stats in other_stats.shooter_stats.items():
            if shooter_name not in self.shooter_stats:
                self.shooter_stats[shooter_name] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "shooter_rolls": 0,
                }
            self.shooter_stats[shooter_name]["points_rolled"] += stats["points_rolled"]
            self.shooter_stats[shooter_name]["rolls_before_7_out"].extend(stats["rolls_before_7_out"])
            self.shooter_stats[shooter_name]["shooter_rolls"] += stats["shooter_rolls"]

        # Merge bankroll history
        for player, bankrolls in other_stats.bankroll_history.items():
            if player not in self.bankroll_history:
                self.bankroll_history[player] = []
            self.bankroll_history[player].extend(bankrolls)
        
        # Merge at_risk history
        for player, at_risks in other_stats.at_risk_history.items():
            if player not in self.at_risk_history:
                self.at_risk_history[player] = []
            self.at_risk_history[player].extend(at_risks)

    def update_rolls(self, total: Optional[int] = None, table_risk: Optional[int] = None) -> None:
        """Increment the roll count and optionally record roll total and table risk."""
        self.session_rolls += 1
        self.roll_numbers.append(self.session_rolls)
        
        if total is not None:
            self.last_roll_total = total

        if total == 7:
            self.total_sevens += 1

        if table_risk is not None:
            self.max_table_risk = max(self.max_table_risk, table_risk)

    def update_win_loss(self, bet: Any) -> None:
        """
        Update the house and player win/loss based on the resolved bet.

        :param bet: The resolved bet.
        """
        if bet.status in ("won", "lost"):
            self.total_amount_bet += bet.amount

            player_stats = self.player_stats.get(bet.owner.name)
            if player_stats:
                player_stats["bets_settled"] += 1
                if bet.status == "won":
                    self.total_amount_won += bet.payout()
                    player_stats["bets_won"] += 1
                elif bet.status == "lost":
                    self.total_amount_lost += bet.amount
    
    def update_player_bankrolls(self, players: List[Any]) -> None:
        """Update player bankrolls and track highest/lowest bankroll."""
        self.player_bankrolls = [player.balance for player in players]
        self.highest_bankroll = max(self.player_bankrolls)
        self.lowest_bankroll = min(self.player_bankrolls)

        for player in players:
            if player.name not in self.bankroll_history:
                self.bankroll_history[player.name] = []
            self.bankroll_history[player.name].append(player.balance)
            
            if player.name in self.player_stats:
                stats = self.player_stats[player.name]
                stats["highest_bankroll"] = max(stats["highest_bankroll"], player.balance)
                stats["lowest_bankroll"] = min(stats["lowest_bankroll"], player.balance)
            
            if player.balance > self.session_highest_bankroll:
                self.session_highest_bankroll = player.balance
            if player.balance < self.session_lowest_bankroll:
                self.session_lowest_bankroll = player.balance

    def update_player_risk(self, players: List[Any], table: Any) -> None:
        """Update the amount at risk for each player this roll."""
        for player in players:
            at_risk = sum(b.amount for b in table.bets if b.owner == player and b.status == "active")
            if player.name not in self.at_risk_history:
                self.at_risk_history[player.name] = []
            self.at_risk_history[player.name].append(at_risk)

    def record_seven_out(self) -> None:
        """Record the roll number where a 7-out occurs."""
        self.seven_out_rolls.append(self.session_rolls)
        if self.shooter and self.shooter_num is not None:  # Ensure shooter_num is an int
            if self.shooter_num not in self.shooter_stats:
                self.shooter_stats[self.shooter_num] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "shooter_rolls": 0,
                }
            self.shooter_stats[self.shooter_num]["rolls_before_7_out"].append(self.shooter.current_roll_count)
            self.shooter.current_roll_count = 0
        
    def record_point_number_roll(self) -> None:
        """Record the roll number where a point number (4, 5, 6, 8, 9, 10) is rolled."""
        self.point_number_rolls.append(self.session_rolls)
        if self.shooter and self.shooter_num is not None:  # Ensure shooter_num is an int
            if self.shooter_num not in self.shooter_stats:
                self.shooter_stats[self.shooter_num] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "shooter_rolls": 0,
                }
            self.shooter_stats[self.shooter_num]["points_rolled"] += 1

    def update_shooter_stats(self, shooter: Any) -> None:
        """Update shooter statistics."""
        if self.shooter_num is None:
            return  # Avoid indexing with None

        if self.shooter_num not in self.shooter_stats:
            self.shooter_stats[self.shooter_num] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "shooter_rolls": 0,
            }
        self.shooter_stats[self.shooter_num]["shooter_rolls"] = shooter.current_roll_count
        self.shooter_stats[self.shooter_num]["rolls_before_7_out"].append(shooter.rolls_before_7_out)

    def print_shooter_report(self) -> None:
        """Print a report summarizing each shooter's performance."""
        logging.info("\n=== Shooter Performance Report ===")
        for shooter_num, stats in self.shooter_stats.items():
            total_points_rolled = stats["points_rolled"]
            shooter_rolls = stats["shooter_rolls"]
            rolls_before_7_out = stats["rolls_before_7_out"]
            avg_rolls_before_7_out = (
                sum(rolls_before_7_out) / len(rolls_before_7_out)
                if rolls_before_7_out else 0
            )

            logging.info(
                f"  Shooter #{shooter_num}: {shooter_rolls} rolls "
                f"({total_points_rolled} points made, "
                f"{len(rolls_before_7_out)} 7-outs, "
                f"avg rolls before 7-out: {avg_rolls_before_7_out:.2f})"
            )

    def average_rolls_per_shooter(self) -> float:
        """Average number of rolls per shooter."""
        if self.num_shooters == 0:
            return 0.0
        return self.session_rolls / self.num_shooters

    def estimated_session_time_minutes(self, rolls_per_hour: int = 90) -> int:
        """Estimate session duration in minutes."""
        if rolls_per_hour <= 0:
            return 0
        return int((self.session_rolls / rolls_per_hour) * 60)

    def house_take(self) -> int:
        """Total house profit."""
        return self.total_amount_lost - self.total_amount_won

    def house_edge(self) -> float:
        """Effective house edge as a percentage of total amount bet."""
        if self.total_amount_bet == 0:
            return 0.0
        return (self.house_take() / self.total_amount_bet) * 100

    def get_estimated_session_time(self) -> str:
        total_minutes = round((self.session_rolls / 90) * 60)
        rounded_minutes = int(round(total_minutes / 15.0) * 15)
        hours = rounded_minutes // 60
        minutes = rounded_minutes % 60
        if hours and minutes:
            return f"{hours} hr {minutes} min"
        elif hours:
            return f"{hours} hr"
        else:
            return f"{minutes} min"

    def record_table_risk(self, table_risk: int) -> None:
        self.max_table_risk = max(self.max_table_risk, table_risk)

    def record_roll_total(self, total: int) -> None:
        if total == 7:
            self.total_sevens += 1

    def seven_roll_ratio(self) -> float:
        if self.session_rolls == 0:
            return 0.0
        return self.total_sevens / self.session_rolls


# File: .\craps\statistics_report.py

import os
from craps.statistics import Statistics

class StatisticsReport:
    def __init__(self, filepath: str = "output/statistics_report.txt") -> None:
        self.filepath = filepath
        self.clear_statistics_file()

    def clear_statistics_file(self) -> None:
        if os.path.exists(self.filepath):
            os.remove(self.filepath)

    def write(self, line: str) -> None:
        with open(self.filepath, "a", encoding="utf-8") as f:
            f.write(line + "\n")

    def write_statistics(self, stats: "Statistics") -> None:
        self.write_player_statistics(stats)
        self.write_session_statistics(stats)
    
    def write_player_statistics(self, stats: "Statistics") -> None:
        self.write("\n=============================================")
        self.write("🧑‍🤝‍🧑 Player Performance Report\n")

        for name, data in stats.player_stats.items():
            net = data["net_win_loss"]
            result = "Won" if net >= 0 else "Lost"
            sign = "+" if net >= 0 else "-"
            max_at_risk = max(stats.at_risk_history.get(name, [0]))

            # Derived stat
            settled = data["bets_settled"]
            won = data["bets_won"]
            win_rate = (won / settled * 100) if settled > 0 else 0.0

            self.write(f"🎲 {name}")
            self.write(f"  📥 Initial Bankroll: ${data['initial_bankroll']}")
            self.write(f"  📤 Final Bankroll:   ${data['final_bankroll']}")
            self.write(f"  📊 Net Result:       {sign}${abs(net)} ({result})")
            self.write(f"  🎯 Bets Settled:     {settled}")
            self.write(f"  ✅ Bets Won:         {won} ({win_rate:.1f}% win rate)")
            self.write(f"  🔥 Max At-Risk:      ${max_at_risk}")
            self.write(f"  🔺 Highest Bankroll: ${data['highest_bankroll']}")
            self.write(f"  🔻 Lowest Bankroll:  ${data['lowest_bankroll']}\n")

    def write_session_statistics(self, stats: "Statistics") -> None:
        self.write(f"=============================================")
        self.write("📊 Simulation Statistics")
        self.write(f"📌 Table Minimum: ${stats.table_minimum}")
        self.write(f"👥 Number of Players: {stats.num_players}")
        self.write(f"🎯 Number of Shooters: {stats.num_shooters}")
        self.write(f"⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋⚋")
        self.write(f"🎲 Session Rolls: {stats.session_rolls}")
        self.write(f"🧮 Rolls per Shooter: {stats.session_rolls / stats.num_shooters:.2f}")
        self.write(f"⏱️ Estimated Session Time: {stats.get_estimated_session_time()}")
        self.write(f"📉 Max Table Risk: ${stats.max_table_risk}")
        self.write(f"💸 Total Amount Bet: ${stats.total_amount_bet}")
        self.write(f"💰 Total Amount Won: ${stats.total_amount_won}")
        self.write(f"❌ Total Amount Lost: ${stats.total_amount_lost}")
        self.write(f"🏦 House Take: ${stats.total_amount_lost - stats.total_amount_won}")
        house_edge = ((stats.total_amount_lost - stats.total_amount_won) / stats.total_amount_bet * 100
                    if stats.total_amount_bet else 0.0)
        self.write(f"🎲 House Edge: {house_edge:.2f}%")
        self.write(f"😈 Total 7s Rolled: {stats.total_sevens}")
        self.write(f"🎯 7-Roll Ratio (SRR): {stats.seven_roll_ratio():.2f}")
        self.write(f"🔺 Highest Bankroll During Session: ${stats.session_highest_bankroll}")
        self.write(f"🔻 Lowest Bankroll During Session: ${stats.session_lowest_bankroll}")


# File: .\craps\table.py

from typing import List, Optional, Tuple, TYPE_CHECKING
from craps.bet import Bet
from craps.play_by_play import PlayByPlay
from craps.house_rules import HouseRules
from craps.rules_engine import RulesEngine
from craps.lineup import PlayerLineup

if TYPE_CHECKING:
    from craps.player import Player
    
class Table:
    def __init__(self, house_rules: HouseRules, play_by_play: PlayByPlay, rules_engine: RulesEngine, player_lineup: PlayerLineup) -> None:
        """
        Initialize the table.

        :param house_rules: The HouseRules object for payout rules and limits.
        :param play_by_play: The PlayByPlay instance for logging.
        :param rules_engine: The RulesEngine instance for resolving bets.
        """
        self.house_rules = house_rules
        self.play_by_play = play_by_play
        self.rules_engine = rules_engine  # Use the passed RulesEngine
        self.player_lineup = player_lineup
        self.bets: List[Bet] = []  # All bets on the table
        self.unit = self.house_rules.table_minimum // 5  # Unit for Place/Buy bets

    def get_rules_engine(self) -> RulesEngine:
            """Expose RulesEngine for other classes to query."""
            return self.rules_engine
    
    def has_bet(self, bet: Bet) -> bool:
        """
        Check if a specific bet is on the table.

        :param bet: The bet to check for.
        :return: True if the bet is on the table, False otherwise.
        """
        return bet in self.bets

    def reactivate_inactive_bets(self) -> None:
        """
        Reactivate inactive Place bets when the point is set.
        """
        reactivated_bets = []
        for bet in self.bets:
            if bet.bet_type.startswith("Place") and bet.status == "inactive":
                bet.status = "active"
                reactivated_bets.append(f"{bet.owner.name}'s {bet.bet_type}")

        if reactivated_bets:
            message = f"{', '.join(reactivated_bets)} are now ON."
            self.play_by_play.write(message)

    def place_bet(self, bet: Bet, phase: str) -> bool:
        """
        Place a bet on the table after validating it.

        :param bet: The bet to place.
        :param phase: The current game phase ("come-out" or "point").
        :return: True if the bet was placed successfully, False otherwise.
        """
        # Validate the bet before placing it
        if not bet.validate_bet(phase, self.house_rules.table_minimum, self.house_rules.table_maximum):
            message = f"  ❌ Invalid bet: {bet}"
            self.play_by_play.write(message)
            return False

        # Place the bet on the table
        bet.resolved_payout = 0  # Reset in case reused
        self.bets.append(bet)
        return True

    def check_bets(self, dice_outcome: Tuple[int, int], phase: str, point: Optional[int]) -> List[Bet]:
        """
        Check and resolve all bets on the table based on the dice outcome, phase, and point.

        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        :return: List of bets that were resolved (won/lost)
        """
        resolved_bets: List[Bet] = []

        for bet in self.bets:
            # Skip bets that are inactive (e.g., 3-2-1 turned off Place bets)
            if bet.status == "inactive":
                continue
            
            # Track Come/Don't Come movement
            original_number = bet.number
            original_status = bet.status

            bet.resolve(self.rules_engine, dice_outcome, phase, point)

            if bet.status != original_status and bet.status in ("won", "lost"):
                resolved_bets.append(bet)

            # 🎯 Movement message for Come/Don't Come bets
            if (
                bet.bet_type in ["Come", "Don't Come"]
                and original_number is None
                and bet.number is not None
                and bet.status == "active"
            ):
                self.play_by_play.write(f"  ⏫ {bet.owner.name}'s {bet.bet_type} bet moves to the {bet.number}.")
            elif bet.status == "push":
                self.play_by_play.write(f"  ⏸️ {bet.owner.name}'s {bet.bet_type} bet was barred and did not move.")

        return resolved_bets
    
    def settle_resolved_bets(self) -> List[Bet]:
        """
        Settle resolved bets by paying winners, removing losers, and resetting status.
        - Winning bets are paid and Player bankroll increased by winnings.
        - Losing bets are removed & Player bankroll reduced by bet amount.
        - Contract bets are returned to the player if they win and removed if they lose.
        - Linked odds bets follow the resolution of their parent bet.
        - Whether bets should stay working and/or to leave winning bets up controlled by HOUSE RULES.
        - Winners that remain on the table will keep status='won' temporarily (for stats),
        and are flipped to 'active' afterward by caller.
        """
        settled_bets: List[Bet] = []

        for bet in list(self.bets):
            # Skip odds bets — handled when parent resolves
            if bet.parent_bet is not None:
                continue

            # ✅ Handle Lost Bets
            if bet.status == "lost":
                bet.hits = 0
                bet.owner.lose_bet(bet, self.play_by_play)
                self.bets.remove(bet)
                settled_bets.append(bet)

                # Also settle attached odds bets
                for attached in list(self.bets):
                    if attached.parent_bet == bet:
                        attached.owner.lose_bet(attached, self.play_by_play)
                        self.bets.remove(attached)
                        settled_bets.append(attached)

            # ✅ Handle Winning Bets
            elif bet.status == "won":
                bet.hits += 1
                bet.owner.win_bet(bet, self.play_by_play)
                settled_bets.append(bet)

                # Also settle attached odds bets
                for attached in list(self.bets):
                    if attached.parent_bet == bet:
                        attached.owner.win_bet(attached, self.play_by_play)
                        self.bets.remove(attached)
                        settled_bets.append(attached)

        return settled_bets
    
    def get_active_players(self) -> List["Player"]:
        """Retrieve all active players at the table."""
        return self.player_lineup.get_active_players_list()

    def notify_players_of_point_hit(self) -> None:
        """
        Notifies each player that the point was hit and asks if they want their Come/Place/Lay Odds working on the next come-out roll.
        """
        for player in self.player_lineup.get_active_players_list():
            if player.has_odds_bets(self):
                should_work = self.player_lineup.should_odds_be_working(player)
                player.update_come_odds_status(self, should_work)

    def has_odds_bet(self, linked_bet: Bet) -> bool:
        return any(
            b for b in self.bets
            if b.bet_type.endswith("Odds") and b.linked_bet == linked_bet
        )

    def total_risk(self) -> int:
        """Calculate total amount risked on the table for the current roll."""
        return sum(bet.amount for bet in self.bets)


# File: .\craps\view_log.py

import subprocess
from abc import ABC, abstractmethod
import os
import sys

class LogViewer(ABC):
    """
    Abstract base class for log viewers.
    """

    @abstractmethod
    def view(self, log_file: str) -> None:
        """
        View the log file.
        
        :param log_file: Path to the log file.
        """
        pass


class InteractiveLogViewer(LogViewer):
    """
    Concrete class for interactive log viewing.
    """

    def view(self, log_file: str) -> None:
        """
        Open the log file interactively.
        
        :param log_file: Path to the log file.
        """
        # Check if the log file exists
        if not os.path.exists(log_file):
            print(f"Log file '{log_file}' not found.")
            return

        # Handle Windows and Unix-like systems differently
        if sys.platform == "win32":
            # Windows: Use Python to print the file contents
            try:
                with open(log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        print(line, end='')
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")
        else:
            # Unix-like systems: Use `less -R`
            try:
                subprocess.run(['less', '-R', log_file])
            except FileNotFoundError:
                print("'less' command not found. Falling back to plain text viewing.")
                self._view_plain_text(log_file)
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")

    def _view_plain_text(self, log_file: str) -> None:
        """
        Fallback method to view the log file as plain text.
        
        :param log_file: Path to the log file.
        """
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")


class PlainTextLogViewer(LogViewer):
    """
    Concrete class for plain text log viewing.
    """

    def view(self, log_file: str) -> None:
        """
        Print the log file to the console.
        
        :param log_file: Path to the log file.
        """

        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")

# File: .\craps\visualizer.py

import matplotlib.pyplot as plt
from typing import Any
import os

class Visualizer:
    def __init__(self, stats: Any) -> None:
        """
        Initialize the Visualizer.

        :param stats: The statistics object containing bankroll history and roll numbers.
        """
        self.stats = stats

    def visualize_bankrolls(self) -> None:
        """Visualize player bankrolls over time."""
        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.stats.bankroll_history.items():
            if len(bankrolls) != len(self.stats.roll_numbers):
                min_length = min(len(bankrolls), len(self.stats.roll_numbers))
                bankrolls = bankrolls[:min_length]
                at_risk = self.stats.at_risk_history.get(player, [0] * min_length)[:min_length]
                roll_numbers = self.stats.roll_numbers[:min_length]
            else:
                roll_numbers = self.stats.roll_numbers
                at_risk = self.stats.at_risk_history.get(player, [0] * len(roll_numbers))

            # Draw the baseline
            # Draw horizontal line for player's starting bankroll
            initial_bankroll = self.stats.player_stats.get(player, {}).get("initial_bankroll", 500)
            plt.axhline(
                y=initial_bankroll,
                color="black",
                linestyle="-",
                linewidth=1.2,
                alpha=0.6,
                zorder=1
            )
            
            # Draw bankroll line
            line, = plt.plot(roll_numbers, bankrolls, label=player)

            # Draw "at risk" shaded area beneath bankroll
            color = line.get_color()
            plt.fill_between(roll_numbers,
                             [b - r for b, r in zip(bankrolls, at_risk)],
                             bankrolls,
                             color=color,
                             alpha=0.2,
                             label="_nolegend_")

        # Only show the legend label once per type
        seven_out_shown = False
        for roll in self.stats.seven_out_rolls:
            plt.axvline(
                x=roll,
                color='red',
                linestyle='--',
                alpha=0.5,
                label='_nolegend_'
            )
            seven_out_shown = True

        point_roll_shown = False
        for roll in self.stats.point_number_rolls:
            plt.axvline(
                x=roll,
                color='green',
                linestyle=':',
                alpha=0.5,
                label='_nolegend_'
            )
            point_roll_shown = True

        last_roll = self.stats.roll_numbers[-1]
        plt.xlim(left=0, right=last_roll)

        x_ticks = list(range(0, last_roll + 1, 10))
        if len(x_ticks) >= 2:
            next_to_last_tick = x_ticks[-2]
            if (last_roll - next_to_last_tick) <= 3 and (last_roll % 10 != 0):
                x_ticks.pop(-2)

        if last_roll not in x_ticks:
            x_ticks.append(last_roll)

        plt.xticks(x_ticks)
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)

        # Save figure to /output/session_visualizer.png
        os.makedirs("output", exist_ok=True)
        plt.savefig("output/session_visualizer.png")

        # Also display it
        plt.show()


# File: .\craps\__init__.py



# File: .\craps\strategies\adjuster_only_strategy.py

from typing import List, Optional, TYPE_CHECKING
from craps.bet import Bet
from craps.base_strategy import BaseStrategy
from craps.bet_adjusters import BetAdjuster

if TYPE_CHECKING:
    from craps.table import Table
    from craps.player import Player
    from craps.game_state import GameState

class AdjusterOnlyStrategy(BaseStrategy):
    """
    Generic wrapper strategy that delegates adjust_bets() to a BetAdjuster.
    Used when bet placement is handled by another strategy.
    """

    def __init__(self, name: str, adjuster: BetAdjuster):
        super().__init__(name)
        self.adjuster = adjuster
        self.last_game_state: Optional["GameState"] = None
        self.last_player: Optional["Player"] = None
        self.last_table: Optional["Table"] = None

    def place_bets(self, game_state: "GameState", player: "Player", table: "Table") -> List[Bet]:
        return []

    def adjust_bets(self, game_state: "GameState", player: "Player", table: "Table") -> Optional[List[Bet]]:
        self.last_game_state = game_state
        self.last_player = player
        self.last_table = table

        updated: List[Bet] = []
        for bet in table.bets:
            if bet.owner == player and bet.bet_type == "Place" and bet.status == "won":
                self.adjuster.adjust(bet, table, table.rules_engine)
                updated.append(bet)
        return updated if updated else None

    def on_new_shooter(self) -> None:
        """Reset internal state if adjuster supports it."""
        if self.last_game_state and self.last_player and self.last_table:
            self.adjuster.on_new_shooter(self.last_game_state, self.last_player, self.last_table)


# File: .\craps\strategies\double_hop_strategy.py

from __future__ import annotations
from typing import TYPE_CHECKING, List, Optional
from craps.bet import Bet
from craps.base_strategy import BaseStrategy
from craps.bet_adjusters import PressStyle, PressAdjuster

if TYPE_CHECKING:
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.table import Table

class DoubleHopStrategy(BaseStrategy):
    def __init__(self, hop_target: tuple[int, int], rules_engine: RulesEngine, base_bet: int) -> None:
        super().__init__("Double Hop")
        self.hop_target = hop_target
        self.rules_engine = rules_engine
        self.base_bet = base_bet
        self.pressed_once = False  # <-- track press state
        self.press_adjuster = PressAdjuster(style=PressStyle.FULL)

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        bet = self.rules_engine.create_bet("Hop", self.base_bet, player, self.hop_target)
        return [bet]

    def adjust_bets(self, game_state: GameState, player: Player, table: Table) -> Optional[List[Bet]]:
        updated = []

        for bet in table.bets:
            if bet.owner == player and bet.bet_type == "Hop" and bet.number == self.hop_target:
                if bet.status == "won":
                    if bet.hits == 1:
                        self.press_adjuster.adjust(bet, table, self.rules_engine)  # ✅ First hit → press it
                        updated.append(bet)
                    elif bet.hits >= 2:
                        bet.amount = self.base_bet  # ✅ Reset on second win
                        updated.append(bet)

        return updated if updated else None

# File: .\craps\strategies\field_strategy.py

from __future__ import annotations
from typing import TYPE_CHECKING, List
from craps.base_strategy import BaseStrategy

if TYPE_CHECKING:
    from craps.rules_engine import RulesEngine  # Prevents circular imports
    from craps.game_state import GameState
    from craps.player import Player
    from craps.table import Table
    from craps.bet import Bet

class FieldBetStrategy(BaseStrategy):
    """Betting strategy for Field bets."""
    
    def __init__(self, min_bet: int) -> None:
        """
        Initialize the Field Bet strategy.
        
        :param min_bet: The minimum bet amount for the table.
        """
        super().__init__("Field")
        self.min_bet: int = min_bet

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        """
        Place a Field bet during the point roll if no active bet exists.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :param table: The table where bets are placed.
        :return: A Field bet if one does not already exist, otherwise None.
        """
        # Check if the player already has an active Field bet
        if player.has_active_bet(table, "Field"):
            return []  # No new bet to place

        # Use RulesEngine to create a Field bet
        rules_engine = table.get_rules_engine()
        return [rules_engine.create_bet("Field", self.min_bet, player)]


# File: .\craps\strategies\free_odds_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, List, Optional
from craps.bet import Bet
from craps.game_state import GameState

if TYPE_CHECKING:
    from craps.player import Player
    from craps.table import Table

class FreeOddsStrategy:
    """Betting strategy for Free Odds on any active bet."""

    def __init__(self, table: Table, odds_type: Optional[str] = None) -> None:
        """
        Initialize the Free Odds strategy.

        :param table: The table instance to use for rules validation.
        :param odds_type: The type of odds to use (e.g., "3x-4x-5x").
        """
        self.table = table
        self.odds_type = odds_type

    def get_odds_bet(self, game_state: GameState, player: Player, table: Table) -> Optional[List[Bet]]:
        """
        Place Free Odds bets on any active bets for the player.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :return: A list of odds bets to place, or None if no bets are placed.
        """
        if game_state.phase != "point" or not self.odds_type:
            return None  # No odds bets if there's no point or no odds strategy

        bets = []
        rules_engine = table.rules_engine

        # Retrieve active Pass Line or Come bets belonging to the player
        active_bets = [bet for bet in table.bets if bet.owner == player]

        for active_bet in active_bets:
            if active_bet.is_contract_bet:
                # Determine the relevant point number
                if active_bet.bet_type in ["Pass Line", "Don't Pass"]:
                    point_number = game_state.point
                elif active_bet.bet_type in ["Come", "Don't Come"]:
                    point_number = active_bet.number if isinstance(active_bet.number, int) else None
                else:
                    point_number = None

                multiplier = rules_engine.get_odds_multiplier(self.odds_type, point_number)

                if multiplier is None:
                    continue  # Skip if no valid multiplier

                # Determine the correct odds bet amount
                odds_amount = min(active_bet.amount * multiplier, player.balance)

                # Create the odds bet using the Rules Engine
                bets.append(rules_engine.create_bet(
                    f"{active_bet.bet_type} Odds",
                    odds_amount,
                    player,
                    parent_bet=active_bet
                ))

        return bets if bets else None


# File: .\craps\strategies\iron_cross_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, Optional, List
from craps.bet import Bet
from craps.base_strategy import BaseStrategy

if TYPE_CHECKING:
    from craps.table import Table  # Prevents circular imports
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.play_by_play import PlayByPlay
    from craps.base_strategy import BaseStrategy
class IronCrossStrategy(BaseStrategy):
    """Betting strategy for Iron Cross."""

    def __init__(self, table: Table, rules_engine: RulesEngine, min_bet: int, play_by_play: PlayByPlay) -> None:
        """
        Initialize the Iron Cross strategy.

        :param table: The table object to determine minimum bets.
        :param rules_engine: The RulesEngine instance from the table.
        :param min_bet: The minimum bet amount for the table.
        :param play_by_play: The play-by-play logging instance.
        """
        super().__init__("Iron Cross")
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine
        self.min_bet: int = min_bet
        self.play_by_play: PlayByPlay = play_by_play

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        """
        Place bets for the Iron Cross strategy.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :param table: The table where the bet will be placed.
        :return: A list of bets to place, or None if no bets are placed.
        """
        
        rules_engine = self.rules_engine

        if game_state.phase == "come-out":
            # Place a Pass Line bet during the come-out roll if no active bet exists
            if not any(bet.owner == player and bet.bet_type == "Pass Line" for bet in table.bets):
                return [rules_engine.create_bet("Pass Line", self.min_bet, player)]

        elif game_state.phase == "point":
            # Reactivate inactive Place bets
            for bet in table.bets:
                if bet.owner == player and bet.bet_type.startswith("Place") and bet.status == "inactive":
                    bet.status = "active"
                    message = f"  🧑{player.name}'s {bet.bet_type} bet is now ON."
                    self.play_by_play.write(message)

            # Place Place bets on 5, 6, and 8 during the point phase (excluding the point number)
            numbers = [5, 6, 8]  # Numbers for the Iron Cross

            # Exclude the point number
            if game_state.point in numbers:
                numbers.remove(game_state.point)

            # Filter out numbers already covered by a Place bet
            numbers = [
                num for num in numbers
                if not any(
                    bet.owner == player and bet.bet_type.startswith("Place") and bet.number == num
                    for bet in table.bets
                )
            ]

            # Use RulesEngine to create Place bets
            bets: List[Bet] = []
            for number in numbers:
                min_bet = rules_engine.get_minimum_bet("Place", table, number)  # ✅ Correct
                bets.append(rules_engine.create_bet("Place", min_bet, player, number=number))

            # Add a Field bet if no active Field bet exists
            if not any(bet.owner == player and bet.bet_type == "Field" for bet in table.bets):
                bets.append(rules_engine.create_bet("Field", self.min_bet, player))

            return bets if bets else []

        return []  # No bet to place


# File: .\craps\strategies\lay_strategy.py

from __future__ import annotations
from typing import Union, TYPE_CHECKING, Optional, List
from craps.base_strategy import BaseStrategy

if TYPE_CHECKING:
    from craps.table import Table
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.bet import Bet

class LayBetStrategy(BaseStrategy):
    """Betting strategy for Lay Bets against point numbers."""

    def __init__(self, table: Table, rules_engine: RulesEngine, numbers_or_strategy: Union[str, List[int]]) -> None:
        """
        Initialize the Lay Bet strategy.

        :param table: The table object to access current bets.
        :param rules_engine: RulesEngine instance used to create and validate bets.
        :param numbers_or_strategy: A list of numbers (e.g., [4, 10]) or a named group ("outside", "across").
        """
        super().__init__("Lay")
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine
        self.numbers_or_strategy: Union[str, List[int]] = numbers_or_strategy

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        """Place Lay bets on selected numbers after the point is established."""
        if game_state.phase != "point":
            return []  # Only bet during the point phase

        rules_engine = table.get_rules_engine()

        # Determine which numbers to lay against
        if isinstance(self.numbers_or_strategy, str):
            strategy = self.numbers_or_strategy.lower()
            if strategy == "outside":
                numbers = [4, 10]
            elif strategy == "inside":
                numbers = [5, 6, 8, 9]
            elif strategy == "across":
                numbers = [4, 5, 6, 8, 9, 10]
            else:
                raise ValueError(f"Invalid lay strategy: {strategy}")
        else:
            numbers = self.numbers_or_strategy

        # Filter out numbers already covered by Lay bets for this player
        numbers_to_bet = [
            num for num in numbers
            if not any(
                bet.owner == player and bet.bet_type == "Lay" and bet.number == num and bet.status == "active"
                for bet in table.bets
            )
        ]

        # Place Lay bets
        bets: List[Bet] = []
        for number in numbers_to_bet:
            min_bet = rules_engine.get_minimum_bet("Lay", table, number=number)
            lay_bet = rules_engine.create_bet("Lay", min_bet, player, number=number)
            bets.append(lay_bet)

        return bets


# File: .\craps\strategies\pass_line_odds_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, List, Union
from craps.bet import Bet
from craps.base_strategy import BaseStrategy

if TYPE_CHECKING:
    from craps.table import Table  # Prevents circular imports
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player

class PassLineOddsStrategy(BaseStrategy):
    """Betting strategy for Pass Line with Odds bets."""

    def __init__(self, table: Table, rules_engine: RulesEngine, odds_multiple: Union[int, str] = 1) -> None:
        """
        Initialize the Pass Line Odds strategy.

        :param table: The table object to determine minimum bets.
        :param rules_engine: The RulesEngine instance from the table.
        :param odds_multiple: The multiple of the minimum bet to use for odds (e.g., 1x, 2x).
        """
        super().__init__("Pass Line Odds")
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine
        self.odds_multiple: Union[int, str] = odds_multiple


    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        """
        Place a Pass Line or Pass Line Odds bet based on the game state.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :param table: The table where the bet will be placed.
        :return: A Pass Line or Pass Line Odds bet, or None if no bet is placed.
        """
        rules_engine = self.rules_engine  # Use the passed RulesEngine

        if game_state.phase not in ["come-out", "point"]:
            return []  # Do not place the bet if the phase is invalid

        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if player.has_active_bet(table, "Pass Line"):
                return []  # No new bet to place

            # Use RulesEngine to create a Pass Line bet
            return [rules_engine.create_bet("Pass Line", table.house_rules.table_minimum, player)]

        elif game_state.phase == "point":
            # Check if the player already has an active Pass Line Odds bet
            if player.has_active_bet(table, "Pass Line Odds"):
                return []  # No new bet to place

            # Find the player's active Pass Line bet
            pass_line_bet = next(
                (bet for bet in table.bets if bet.owner == player and bet.bet_type == "Pass Line"),
                None
            )
            if pass_line_bet is None:
                return []  # No Pass Line bet found

            # Calculate odds amount based on fixed or dynamic odds
            if isinstance(self.odds_multiple, str):
                point = game_state.point
                if point is None:
                    return []
                multiplier = self.rules_engine.get_odds_multiplier(self.odds_multiple, point)
                if multiplier is None:
                    return []
                odds_amount = table.house_rules.table_minimum * multiplier
            else:
                odds_amount = table.house_rules.table_minimum * self.odds_multiple

            # Use RulesEngine to create a Pass Line Odds bet linked to the Pass Line bet
            return [rules_engine.create_bet(
                "Pass Line Odds",
                odds_amount,
                player,
                parent_bet=pass_line_bet
            )]

        return []  # No bet to place


# File: .\craps\strategies\pass_line_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, List, Optional
from craps.bet import Bet
from craps.base_strategy import BaseStrategy
from craps.strategies.free_odds_strategy import FreeOddsStrategy

if TYPE_CHECKING:
    from craps.game_state import GameState
    from craps.player import Player
    from craps.table import Table

class PassLineStrategy(BaseStrategy):
    """Pass Line betting strategy with optional odds."""

    def __init__(self, bet_amount: int, table: Table, odds_type: Optional[str] = None) -> None:
        """
        Initialize the Pass Line strategy.

        :param bet_amount: The base amount to bet on the Pass Line.
        :param table: The Table instance for placing bets.
        :param odds_type: Optional string specifying the odds type (e.g., "3x-4x-5x").
        """
        super().__init__("Pass Line")
        self.bet_amount = bet_amount
        self.table = table
        self.odds_strategy = FreeOddsStrategy(table, odds_type) if odds_type else None

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        """Place a Pass Line bet at the start of the come-out roll."""
        if game_state.phase == "come-out" and not player.has_active_bet(table, "Pass Line"):
            return [table.rules_engine.create_bet("Pass Line", self.bet_amount, player)]
        return []

    def adjust_bets(self, game_state: GameState, player: Player, table: Table) -> Optional[List[Bet]]:
        """If an odds strategy is set, place odds bets when a point is established."""
        if self.odds_strategy and game_state.phase == "point":
            return self.odds_strategy.get_odds_bet(game_state, player, table)  # Delegate odds betting to FreeOddsStrategy
        return None


# File: .\craps\strategies\place_reggression_strategy.py

from typing import List, Optional, Set, TYPE_CHECKING, Literal
from craps.bet import Bet
from craps.player import Player
from craps.game_state import GameState
from craps.rules_engine import RulesEngine
from craps.base_strategy import BaseStrategy
from craps.bet_adjusters import BetAdjuster, RegressAdjuster, PressAdjuster, PressStyle

if TYPE_CHECKING:
    from craps.table import Table

class PlaceRegressionStrategy(BaseStrategy):
    """
    Session-aware Place Regression Strategy:
    - Start with high-unit inside bets (e.g. 440)
    - Regress after each inside hit
    - Switch to pressing after session profit buffer is met
    """

    def __init__(self, high_unit: int = 10, low_unit: int = 2, regression_factor: int = 2, regress_units: int = 10) -> None:
        super().__init__("Place Regression")

        self.high_unit = high_unit
        self.low_unit = low_unit
        self.regression_factor = regression_factor
        self.regress_units = regress_units
        self.unit_levels: List[int] = self._generate_unit_levels()

        self.inside_numbers: Set[int] = {5, 6, 8, 9}
        self.original_exposure: int = self._calculate_total_exposure(self.high_unit)

        # Session state
        self.session_profit: int = 0
        self.mode: Literal["regress", "press"] = "regress"

        # Shooter state
        self.level: int = 0
        self.hits: int = 0
        self.placed: bool = False

    def _generate_unit_levels(self) -> List[int]:
        """Generate unit steps from high to low using the regression factor."""
        levels = [self.high_unit]
        while levels[-1] > self.low_unit:
            next_level = max(self.low_unit, levels[-1] // self.regression_factor)
            if next_level == levels[-1]:
                break
            levels.append(next_level)
        return levels

    def _calculate_total_exposure(self, unit: int) -> int:
        """
        Calculate total inside exposure using the given unit:
        - $5 units on 5/9 (×2)
        - $6 units on 6/8 (×2)
        """
        return unit * 5 * 2 + unit * 6 * 2

    def reset_shooter_state(self) -> None:
        """Reset state that resets every shooter."""
        self.level = 0
        self.hits = 0
        self.placed = False
        self.mode = "regress"

    def on_new_shooter(self) -> None:
        """Called at start of new shooter."""
        self.reset_shooter_state()

    def notify_payout(self, amount: int) -> None:
        """Track hit count and prepare for mode switch after completing regression."""
        self.hits += 1

    def place_bets(self, game_state: GameState, player: Player, table: "Table") -> List[Bet]:
        if game_state.phase != "point":
            return []

        # 🔍 Check if the player already has Place bets
        existing_place_bets = [
            b for b in table.bets
            if b.owner == player and b.bet_type == "Place" and b.number in self.inside_numbers and b.status != "removed"
        ]
        if existing_place_bets:
            return []

        bets: List[Bet] = []
        unit = self.unit_levels[self.level] if self.mode == "regress" else self.unit_levels[-1]

        for number in self.inside_numbers:
            base_unit = RulesEngine.get_bet_unit("Place", number)
            bet_amount = base_unit * unit
            bet = RulesEngine.create_bet("Place", bet_amount, player, number)
            bets.append(bet)

        return bets

    def adjust_bets(self, game_state: GameState, player: Player, table: "Table") -> Optional[List[Bet]]:
        last_roll = game_state.stats.last_roll_total
        if last_roll not in self.inside_numbers:
            return None

        updated_bets: List[Bet] = []

        if self.mode == "regress":
            hit_bet = next(
                (
                    b for b in table.bets
                    if b.owner == player and b.bet_type == "Place" and b.number == last_roll and b.status == "won"
                ),
                None
            )
            if not hit_bet:
                return None

            # ✅ Determine regression level
            regression_index = max(0, min(self.hits, len(self.unit_levels) - 1))
            current_unit = self.unit_levels[regression_index]
            adjuster: BetAdjuster = RegressAdjuster(self.unit_levels, regression_index)

            # ✅ Regress *all* of the player’s inside Place bets
            for bet in table.bets:
                if bet.owner == player and bet.bet_type == "Place" and bet.number in self.inside_numbers:
                    bet.amount = current_unit * RulesEngine.get_bet_unit(bet.bet_type, bet.number)
                    adjuster.adjust(bet, table, table.rules_engine)
                    updated_bets.append(bet)

            table.play_by_play.write(f"  📉 {player.name} regressing to unit level {current_unit} after hit #{self.hits}")

            # 👇 Switch to press mode after completing regression
            if current_unit == self.low_unit:
                self.mode = "press"
                self.level = 0
                self.hits = 0
                table.play_by_play.write(
                    f"  🎯 {player.name} completed regression to unit ${current_unit} — switching to press mode."
                )

        elif self.mode == "press":
            half_press_adjuster = PressAdjuster(style=PressStyle.HALF)
            for bet in table.bets:
                if (
                    bet.owner == player and bet.bet_type == "Place"
                    and bet.number == last_roll and bet.status == "won"
                ):
                    half_press_adjuster.adjust(bet, table, table.rules_engine)
                    updated_bets.append(bet)

            # 👇 Check if we're now over threshold and need to regress
            if self.regress_units:
                total_exposure = sum(
                    bet.amount for bet in table.bets
                    if bet.owner == player and bet.bet_type == "Place" and bet.number in self.inside_numbers
                )
                target_threshold = self.regress_units * 22
                if total_exposure >= target_threshold:
                    self.mode = "regress"
                    self.level = 0
                    self.hits = 0
                    table.play_by_play.write(
                        f"  🎯 {player.name}'s press exposure (${total_exposure}) exceeded threshold (${target_threshold}) — switching back to regression."
                    )
                    # Reset bets to the regress_unit 
                    for b in table.bets:
                        if b.owner == player and b.bet_type == "Place" and b.number in self.inside_numbers:
                            base_unit = RulesEngine.get_bet_unit(b.bet_type, b.number)
                            b.amount = base_unit * self.regress_units

        return updated_bets if updated_bets else None

# File: .\craps\strategies\place_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import Union, TYPE_CHECKING, Optional, List
from craps.base_strategy import BaseStrategy

if TYPE_CHECKING:
    from craps.table import Table  # Prevents circular imports
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.bet import Bet

class PlaceBetStrategy(BaseStrategy):
    """Betting strategy for Place Bets."""

    def __init__(self, table: Table, rules_engine: RulesEngine, numbers_or_strategy: Union[str, list[int]]) -> None:
        """
        Initialize the Place Bet strategy.

        :param table: The table object to determine minimum bets.
        :param rules_engine: The RulesEngine instance from the table.
        :param numbers_or_strategy: A list of numbers (e.g., [5, 6, 8, 9]) or a strategy ("inside", "across").
        """
        super().__init__("Place")
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine  # Use the existing RulesEngine
        self.numbers_or_strategy: Union[str, list[int]] = numbers_or_strategy

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        """Place Place Bets based on the strategy and game state."""
        if game_state.phase != "point":
            return []  # Only place bets after the point is established

        rules_engine = table.get_rules_engine()

        # Determine which numbers to bet on
        if isinstance(self.numbers_or_strategy, str):
            if self.numbers_or_strategy == "inside":
                numbers = [5, 6, 8, 9]  # Inside numbers
            elif self.numbers_or_strategy == "across":
                numbers = [4, 5, 6, 8, 9, 10]  # Across numbers
            else:
                raise ValueError(f"Invalid strategy: {self.numbers_or_strategy}")
        else:
            numbers = self.numbers_or_strategy  # Specific numbers provided

        # Filter out numbers already covered by a Pass Line bet or a Place bet
        numbers = [
            num for num in numbers
            if not any(
                (bet.owner == player and bet.bet_type == "Pass Line" and game_state.point == num) or  # Pass Line covers the point
                (bet.owner == player and bet.bet_type.startswith("Place") and bet.number == num)  # Place Bet covers the number
                for bet in table.bets
            )
        ]

        # Use Table's RulesEngine to create Place bets
        bets: List[Bet] = []
        for number in numbers:
            min_bet = rules_engine.get_minimum_bet("Place", table, number=number)  # Use correct RulesEngine reference
            bets.append(rules_engine.create_bet("Place", min_bet, player, number=number))

        return bets if bets else []  # Return bets if any were created

# File: .\craps\strategies\regress_then_press_strategy.py

from typing import List, Optional, TYPE_CHECKING
from craps.base_strategy import BaseStrategy
from craps.bet import Bet
from craps.bet_adjusters import PressAdjuster, PressStyle
from craps.strategies.adjuster_only_strategy import AdjusterOnlyStrategy

if TYPE_CHECKING:
    from craps.table import Table
    from craps.game_state import GameState
    from craps.player import Player


class RegressThenPressStrategy(BaseStrategy):
    """
    Composite Strategy: Regress-Then-Press

    This strategy begins each shooter by executing a regression-style betting pattern
    designed to quickly reduce risk after initial bets are placed.

    After the total session profit reaches the original exposure level for the current shooter,
    the strategy transitions to a more aggressive approach, such as pressing bets
    (e.g., half-pressing winnings).

    Once in press mode, it remains active until pressed up to the original high-bet amount. It
    then switches back to regression mode where the cycle repeats.
    """

    def __init__(self, regression_strategy: BaseStrategy, press_style: Optional[PressStyle] = None) -> None:
        super().__init__("Regress Then Press")
        self.regression = regression_strategy
        self.press = AdjusterOnlyStrategy(
            name=f"{(press_style or PressStyle.HALF).value.title()} Press",
            adjuster=PressAdjuster(style=(press_style or PressStyle.HALF))
        )
        self.active_strategy = self.regression
        self.transitioned = False
        self.max_press_threshold: Optional[float] = None

    def on_new_shooter(self) -> None:
        self.regression.on_new_shooter()
        self.press.on_new_shooter()
        self.active_strategy = self.regression
        self.transitioned = False
        self.max_press_threshold = None

    def notify_payout(self, amount: int) -> None:
        self.regression.notify_payout(amount)
        self.press.notify_payout(amount)

    def place_bets(self, game_state: "GameState", player: "Player", table: "Table") -> List[Bet]:
        return self.active_strategy.place_bets(game_state, player, table)

    def adjust_bets(self, game_state: "GameState", player: "Player", table: "Table") -> Optional[List[Bet]]:
        if self.transitioned and self.max_press_threshold is not None:
            total_on_table = sum(
                bet.amount for bet in table.bets
                if bet.owner == player and bet.bet_type == "Place" and bet.number in {5, 6, 8, 9}
            )
            if total_on_table >= self.max_press_threshold:
                self.active_strategy = self.regression
                self.transitioned = False
                self.regression.reset_shooter_state()
        return self.active_strategy.adjust_bets(game_state, player, table)

    def notify_roll(self, game_state: "GameState", player: "Player", table: "Table") -> None:
        return self.active_strategy.notify_roll(game_state, player, table)

    def remove_bets(self, game_state: "GameState", player: "Player", table: "Table") -> Optional[List[Bet]]:
        return self.active_strategy.remove_bets(game_state, player, table)

    def turn_off_bets(self, game_state: "GameState", player: "Player", table: "Table") -> Optional[List[Bet]]:
        return self.active_strategy.turn_off_bets(game_state, player, table)

    def turn_on_bets(self, game_state: "GameState", player: "Player", table: "Table") -> Optional[List[Bet]]:
        return self.active_strategy.turn_on_bets(game_state, player, table)


# File: .\craps\strategies\three_point_dolly_strategy.py

from __future__ import annotations
from typing import TYPE_CHECKING, List, Optional
from craps.strategies.free_odds_strategy import FreeOddsStrategy

if TYPE_CHECKING:
    from craps.table import Table
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.bet import Bet

class ThreePointDollyStrategy:
    """
    Betting strategy for the 3-Point Dolly system.

    This strategy plays the dark side of the 3-point molly:
    - A Don't Pass bet on come-out
    - Up to 2 Don't Come bets with lay odds
    """

    def __init__(
        self,
        table: Table,
        bet_amount: int,
        odds_type: Optional[str] = "3x4x5x",
        dont_come_odds_working_on_come_out: bool = False
    ) -> None:
        self.table = table
        self.bet_amount = bet_amount
        self.odds_strategy = FreeOddsStrategy(table, odds_type) if odds_type else None
        self.dont_come_odds_working_on_come_out = dont_come_odds_working_on_come_out

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        bets: List[Bet] = []
        rules_engine = table.rules_engine

        # Place Don't Pass on come-out if not already placed
        if game_state.phase == "come-out":
            if not player.has_active_bet(table, "Don't Pass"):
                bets.append(rules_engine.create_bet("Don't Pass", self.bet_amount, player))

        # Place up to 2 Don't Come bets during point phase
        if game_state.phase == "point":
            active_dont_come_bets = [
                b for b in table.bets
                if b.bet_type == "Don't Come" and b.owner == player and b.number is not None
            ]
            if len(active_dont_come_bets) < 2:
                bets.append(rules_engine.create_bet("Don't Come", self.bet_amount, player))

        # Place Lay Odds on Don't Pass and Don't Come bets using FreeOddsStrategy
        if self.odds_strategy and game_state.phase == "point":
            odds_bets = self.odds_strategy.get_odds_bet(game_state, player, table)
            if odds_bets:
                existing_odds = {
                    (b.parent_bet, b.number)
                    for b in table.bets
                    if b.bet_type.endswith("Odds") and b.owner == player
                }
                for odds_bet in odds_bets:
                    parent = odds_bet.parent_bet
                    if (
                        parent
                        and parent.owner == player
                        and (parent, parent.number) not in existing_odds
                    ):
                        odds_bet.number = parent.number  # Ensure odds bet inherits number
                        bets.append(odds_bet)

        return bets if bets else []

    def should_dont_come_odds_be_working(self) -> bool:
        """
        Return whether the strategy wants Don't Come odds to be working during the next come-out roll.
        """
        return self.dont_come_odds_working_on_come_out


# File: .\craps\strategies\three_point_molly_strategy.py

from __future__ import annotations
from typing import TYPE_CHECKING, List, Optional
from craps.strategies.free_odds_strategy import FreeOddsStrategy

if TYPE_CHECKING:
    from craps.table import Table
    from craps.rules_engine import RulesEngine  
    from craps.game_state import GameState
    from craps.player import Player
    from craps.bet import Bet

class ThreePointMollyStrategy:
    """Betting strategy for the 3-Point Molly system."""

    def __init__(self, table: Table, bet_amount: int, odds_type: Optional[str] = None, come_odds_working_on_come_out: bool = False) -> None:
        """
        Initialize the 3-Point Molly strategy.

        :param table: The table object to determine minimum bets.
        :param bet_amount: The bet amount for the strategy (defaults to table minimum).
        :param odds_type: The type of odds to use (e.g., "3x-4x-5x").
        :param come_odds_working_on_come_out: Whether Come odds bets are working during the come-out roll.
        """
        self.table = table
        self.bet_amount = bet_amount
        self.odds_strategy = FreeOddsStrategy(table, odds_type) if odds_type else None
        self.come_odds_working_on_come_out = come_odds_working_on_come_out

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        """
        Place bets according to the 3-Point Molly strategy.

        :param game_state: The current game state.
        :param player: The player placing the bets.
        :param table: The table to place the bets on.
        :return: A list of bets to place, or None if no bets are placed.
        """
        bets: List[Bet] = []
        rules_engine = table.rules_engine

        # Place a Pass Line bet if no active Pass Line bet exists (only during come-out phase)
        if game_state.phase == "come-out":
            if not player.has_active_bet(table, "Pass Line"):
                bets.append(rules_engine.create_bet("Pass Line", self.bet_amount, player))

        # Place up to 2 Come bets if fewer than 2 active Come bets (with a number) exist (only during point phase)
        if game_state.phase == "point":
            active_come_bets = [
                bet for bet in table.bets
                if bet.bet_type == "Come" and bet.owner == player and bet.number is not None
            ]
            if len(active_come_bets) < 2:
                bets.append(rules_engine.create_bet("Come", self.bet_amount, player))

        # Place odds on active Pass Line and Come bets using FreeOddsStrategy
        if self.odds_strategy and game_state.phase == "point":
            odds_bets = self.odds_strategy.get_odds_bet(game_state, player, table)
            if odds_bets:
                existing_odds = {
                    (bet.parent_bet, bet.number)
                    for bet in table.bets
                    if bet.bet_type.endswith("Odds") and bet.owner == player
                }
                for odds_bet in odds_bets:
                    parent = odds_bet.parent_bet
                    if (
                        parent
                        and parent.owner == player
                        and (parent, parent.number) not in existing_odds
                    ):
                        odds_bet.number = parent.number  # Ensure odds bet inherits number
                        bets.append(odds_bet)

        return bets if bets else []

    def should_come_odds_be_working(self) -> bool:
        """Return whether the strategy wants Come Odds to be working during the next come-out roll."""
        return self.come_odds_working_on_come_out


# File: .\craps\strategies\three_two_one_strategy.py

from __future__ import annotations
from typing import TYPE_CHECKING, List, Optional
from craps.bet import Bet
from craps.base_strategy import BaseStrategy
from craps.bet_adjusters import PressAdjuster

if TYPE_CHECKING:
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.table import Table

class ThreeTwoOneStrategy(BaseStrategy):
    def __init__(self, rules_engine: RulesEngine, min_bet: int, odds_type: str = "2x") -> None:
        super().__init__("Three-Two-One")
        self.rules_engine = rules_engine
        self.min_bet = min_bet
        self.odds_type = odds_type
        self.total_hits = 0
        self.adjuster = PressAdjuster()
        self.turned_off = False

    def place_bets(self, game_state: GameState, player: Player, table: Table) -> List[Bet]:
        new_bets = []
        
        if game_state.phase == "come-out":
            # Only place Pass Line bet
            new_passline_bet = self.rules_engine.create_bet("Pass Line", self.min_bet, player)
            new_bets.append(new_passline_bet)
        else:
            # Add odds only if not already added
            has_odds = any(
                b.bet_type == "Pass Line Odds" and b.owner == player for b in table.bets
            )
            if not has_odds:
                for bet in table.bets:
                    if bet.bet_type == "Pass Line" and bet.owner == player:
                        multiplier = self.rules_engine.get_odds_multiplier(self.odds_type, game_state.point) or 0
                        odds_amount = self.min_bet * multiplier
                        odds_bet = self.rules_engine.create_bet("Pass Line Odds", odds_amount, player)
                        new_bets.append(odds_bet)

            # Place inside numbers (excluding the point)
            inside_numbers = [5, 6, 8, 9]
            for num in inside_numbers:
                if num == game_state.point:
                    continue
                existing = next(
                    (b for b in table.bets if b.owner == player and b.bet_type == "Place" and b.number == num),
                    None
                )
                if not existing:
                    amount = self.rules_engine.get_minimum_bet("Place", table, num)
                    inside_bet = self.rules_engine.create_bet("Place", amount, player, num)
                    new_bets.append(inside_bet)
                elif existing.status == "inactive":
                    existing.status = "active"

        return new_bets

    def adjust_bets(self, game_state: GameState, player: Player, table: Table) -> Optional[List[Bet]]:
        # Avoid adjusting during cleanup after 7-out
        if game_state.phase != "come-out" and game_state.point is None:
            return []

        if game_state.phase == "come-out":
            self.total_hits = 0
            self.turned_off = False
            return []

        for bet in table.bets:
            if bet.owner == player and bet.bet_type == "Place" and bet.status == "won":
                self.total_hits += 1
                bet.status = "active"

        if not self.turned_off:
            for bet in table.bets:
                if (
                    bet.bet_type == "Place" and bet.owner == player and
                    (game_state.point in {4, 10} and self.total_hits >= 2 or
                    game_state.point in {5, 6, 8, 9} and self.total_hits >= 3)
                ):
                    self.turned_off = True
                    bet.status = "inactive"

        return None

    def reset_shooter_state(self) -> None:
        """Reset stateful tracking for a new shooter (used by composite strategies)."""
        self.total_hits = 0
        self.turned_off = False


# File: .\craps\strategies\__init__.py



# File: .\tests\test_bet_creation.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.player import Player

class TestBetCreationValidation(unittest.TestCase):
    
    def setUp(self):
        """Set up a player instance for testing."""
        self.player = Player("Test Player")  # Remove 'bankroll' if it's not a valid argument
        self.player.bankroll = 1000  # Set bankroll manually if needed

    
    def test_valid_bet_creation(self):
        """Ensure bets can be created correctly in valid phases."""
        bet = RulesEngine.create_bet("Pass Line", 10, self.player)
        self.assertEqual(bet.bet_type, "Pass Line")
        self.assertEqual(bet.amount, 10)
        self.assertEqual(bet.owner, self.player)
    
    def test_invalid_bet_creation(self):
        """Ensure invalid bets raise an exception."""
        with self.assertRaises(ValueError):
            RulesEngine.create_bet("Invalid Bet", 10, self.player)  
    
    def test_contract_bet_cannot_be_removed(self):
        """Ensure contract bets cannot be removed once placed."""
        bet = RulesEngine.create_bet("Pass Line", 10, self.player)
        self.assertFalse(RulesEngine.can_remove_bet(bet.bet_type))
    
    def test_valid_phases_for_bets(self):
        """Ensure bets are only allowed in correct game phases."""
        self.assertTrue(RulesEngine.can_make_bet("Pass Line", "come-out"))
        self.assertFalse(RulesEngine.can_make_bet("Pass Line", "point"))
        self.assertTrue(RulesEngine.can_make_bet("Come", "point"))
        self.assertFalse(RulesEngine.can_make_bet("Come", "come-out"))
    
    def test_bet_linkage(self):
        """Ensure linked bets (e.g., Pass Line → Pass Line Odds) are valid."""
        linked_bet = RulesEngine.get_linked_bet_type("Pass Line")
        self.assertEqual(linked_bet, "Pass Line Odds")
        
    def test_create_hardways_bet_valid(self):
        """Ensure a valid Hardways bet is created correctly."""
        bet = RulesEngine.create_bet("Hardways", 10, self.player, number=8)
        self.assertEqual(bet.bet_type, "Hardways")
        self.assertEqual(bet.amount, 10)
        self.assertEqual(bet.number, 8)  # ✅ Should correctly store the Hardway number

    def test_create_hardways_bet_invalid(self):
        """Ensure an invalid Hardways bet (wrong number) raises an error."""
        with self.assertRaises(ValueError):
            RulesEngine.create_bet("Hardways", 10, self.player, number=5)  # ❌ Invalid number (not 4,6,8,10)
        
        with self.assertRaises(ValueError):
            RulesEngine.create_bet("Hardways", 10, self.player)  # ❌ Missing number
    
if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_bet_resolution.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.player import Player

class TestBetResolution(unittest.TestCase):

    def setUp(self):
        """Set up common test data."""
        self.player = Player("Test Player")
        self.rules_engine = RulesEngine()

    ### ✅ Line Bets ###
    def test_pass_line_win_come_out(self):
        """Pass Line bet should win on come-out roll with 7 or 11."""
        bet = self.rules_engine.create_bet("Pass Line", 10, self.player)
        payout = self.rules_engine.resolve_bet(bet, [4, 3], "come-out", None)  # Roll: 7

        self.assertEqual(bet.status, "won")
        self.assertEqual(payout, 10)  # Even money

    def test_pass_line_lose_come_out(self):
        """Pass Line bet should lose on come-out roll with 2, 3, or 12."""
        bet = self.rules_engine.create_bet("Pass Line", 10, self.player)
        payout = self.rules_engine.resolve_bet(bet, [1, 1], "come-out", None)  # Roll: 2

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    ### ✅ Proposition Bets (Updated) ###
    def test_proposition_win(self):
        """Proposition bet should win when the exact number is rolled."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=11)  # Yo (11)
        payout = self.rules_engine.resolve_bet(bet, [6, 5], "point", 8)  # Roll: 11

        self.assertEqual(bet.status, "won")
        self.assertGreater(payout, 0)

    def test_proposition_loss(self):
        """Proposition bet should lose on any number except its specific value."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=11)  # Yo (11)
        payout = self.rules_engine.resolve_bet(bet, [3, 4], "point", 8)  # Roll: 7

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    ### ✅ Any 7 Bet (Updated to Proposition) ###
    def test_proposition_7_win(self):
        """Any 7 bet should win when a 7 is rolled."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=7)
        payout = self.rules_engine.resolve_bet(bet, [5, 2], "point", 8)  # Roll: 7

        self.assertEqual(bet.status, "won")
        self.assertGreater(payout, 0)

    def test_proposition_7_loss(self):
        """Any 7 bet should lose on any roll except 7."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=7)
        payout = self.rules_engine.resolve_bet(bet, [6, 5], "point", 8)  # Roll: 11

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    ### ✅ Field Bets (Ensure Proper Payouts) ###
    def test_field_bet_special_payout(self):
        """Field bet should pay 2:1 for 2 and 3:1 for 12."""
        bet = self.rules_engine.create_bet("Field", 10, self.player)
        payout = self.rules_engine.resolve_bet(bet, [1, 1], "point", 8)  # Roll: 2

        self.assertEqual(bet.status, "won")
        self.assertEqual(payout, 20)  # 2:1 payout for rolling a 2

    ### ✅ Hardways ###
    def test_hardways_win(self):
        """Hardways bet should win when the exact hardway is rolled."""
        bet = self.rules_engine.create_bet("Hardways", 10, self.player, number=8)
        payout = self.rules_engine.resolve_bet(bet, [4, 4], "point", 8)  # Hard 8

        self.assertEqual(bet.status, "won")
        self.assertGreater(payout, 0)

    def test_hardways_loss_easy_way(self):
        """Hardways bet should lose if the same total is rolled the easy way."""
        bet = self.rules_engine.create_bet("Hardways", 10, self.player, number=8)
        payout = self.rules_engine.resolve_bet(bet, [5, 3], "point", 8)  # Easy 8

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    def test_hardways_loss_seven(self):
        """Hardways bet should lose when a 7 is rolled."""
        bet = self.rules_engine.create_bet("Hardways", 10, self.player, number=8)
        payout = self.rules_engine.resolve_bet(bet, [5, 2], "point", 8)  # Roll: 7

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_dice.py

import sys
import os
import unittest
from craps.dice import Dice

class TestDice(unittest.TestCase):
    def test_roll(self):
        dice = Dice()
        num_rolls = 1_000_000  # Number of rolls to simulate
        tolerance = 0.001  # Tolerance for probability comparison

        # Initialize counters for single die outcomes
        single_die_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}

        # Initialize counters for total outcomes
        total_counts = {
            2: 0, 3: 0, 4: 0, 5: 0, 6: 0,
            7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0
        }

        # Roll the dice 1 million times
        for _ in range(num_rolls):
            outcome = dice.roll()
            total = sum(outcome)

            # Count single die outcomes
            for die in outcome:
                single_die_counts[die] += 1

            # Count total outcomes
            total_counts[total] += 1

        # Calculate observed probabilities for single die outcomes
        single_die_probs = {
            die: count / (num_rolls * 2)  # Each roll involves 2 dice
            for die, count in single_die_counts.items()
        }

        # Calculate observed probabilities for total outcomes
        total_probs = {
            total: count / num_rolls
            for total, count in total_counts.items()
        }

        # Expected probabilities for single die outcomes
        expected_single_die_prob = 1 / 6

        # Expected probabilities for total outcomes
        expected_total_probs = {
            2: 1 / 36,
            3: 2 / 36,
            4: 3 / 36,
            5: 4 / 36,
            6: 5 / 36,
            7: 6 / 36,
            8: 5 / 36,
            9: 4 / 36,
            10: 3 / 36,
            11: 2 / 36,
            12: 1 / 36,
        }

        # Display results for single die outcomes
        print("\nSingle Die Outcomes:")
        print(f"{'Outcome':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for die in range(1, 7):
            actual = single_die_probs[die]
            expected = expected_single_die_prob
            deviation = actual - expected
            print(f"{die:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Display results for total outcomes
        print("\nTotal Outcomes:")
        print(f"{'Total':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for total in range(2, 13):
            actual = total_probs[total]
            expected = expected_total_probs[total]
            deviation = actual - expected
            print(f"{total:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Test single die outcomes
        for die, prob in single_die_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_single_die_prob,
                delta=tolerance,
                msg=f"Single die outcome {die} probability is not within tolerance."
            )

        # Test total outcomes
        for total, prob in total_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_total_probs[total],
                delta=tolerance,
                msg=f"Total outcome {total} probability is not within tolerance."
            )

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_invalid_bets.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.player import Player

class TestInvalidBets(unittest.TestCase):

    def setUp(self):
        """Create a mock player for testing."""
        self.player = Player("Test Player", 1000)  # ✅ Fixed positional args

    def test_invalid_place_bets(self):
        """Test invalid Place bets (should only allow 4, 5, 6, 8, 9, 10)."""
        invalid_numbers = [2, 3, 7, 11, 12]
        for num in invalid_numbers:
            with self.assertRaises(ValueError, msg=f"Place bet on {num} should be invalid"):
                RulesEngine.create_bet("Place", 10, self.player, number=num)

    def test_invalid_hardways(self):
        """Test invalid Hardways bets (should only allow 4, 6, 8, 10)."""
        invalid_numbers = [2, 3, 5, 7, 9, 11, 12]
        for num in invalid_numbers:
            with self.assertRaises(ValueError, msg=f"Hardways bet on {num} should be invalid"):
                RulesEngine.create_bet("Hardways", 10, self.player, number=num)

    def test_invalid_field_bets(self):
        """Test invalid Field bets (should not take a number)."""
        with self.assertRaises(ValueError, msg="Field bet should not have a number"):
            RulesEngine.create_bet("Field", 10, self.player, number=5)

    def test_invalid_pass_line_bets(self):
        """Test invalid Pass Line bets (should not take a number)."""
        with self.assertRaises(ValueError, msg="Pass Line bet should not have a number"):
            RulesEngine.create_bet("Pass Line", 10, self.player, number=7)

    def test_invalid_dont_pass_bets(self):
        """Test invalid Don't Pass bets (should not take a number)."""
        with self.assertRaises(ValueError, msg="Don't Pass bet should not have a number"):
            RulesEngine.create_bet("Don't Pass", 10, self.player, number=7)

    def test_invalid_hop_bets(self):
        """Test invalid Hop bets (e.g., Hop 7-7 is not possible)."""
        with self.assertRaises(ValueError, msg="Hop 7-7 should be invalid"):
            RulesEngine.create_bet("Hop", 10, self.player, number=(7, 7))


if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_odds_multiple.py

import unittest
from craps.rules_engine import RulesEngine
from craps.rules import ODDS_MULTIPLIERS

class TestRulesEngine(unittest.TestCase):
    """Unit tests for the RulesEngine, specifically testing odds multipliers."""

    def test_odds_multipliers(self):
        """Ensure that the correct odds multiplier is returned for each point number."""
        test_cases = [
            ("1x", 4, 1),
            ("1x", 6, 1),
            ("2x", 5, 2),
            ("2x", 9, 2),
            ("1x-2x-3x", 4, 1),
            ("1x-2x-3x", 5, 2),
            ("1x-2x-3x", 6, 3),
            ("3x-4x-5x", 4, 3),
            ("3x-4x-5x", 5, 4),
            ("3x-4x-5x", 6, 5),
            ("3x-4x-5x", 8, 5),
            ("3x-4x-5x", 9, 4),
            ("3x-4x-5x", 10, 3),
            ("10x", 4, 10),
            ("20x", 8, 20),
            ("100x", 10, 100),
            ("100x", 6, 100),
            ("100x", 9, 100),
        ]
        
        for odds_type, point, expected in test_cases:
            with self.subTest(odds_type=odds_type, point=point):
                self.assertEqual(RulesEngine.get_odds_multiplier(odds_type, point), expected)

    def test_invalid_odds_type(self):
        """Ensure that an invalid odds type raises a ValueError."""
        with self.assertRaises(ValueError):
            RulesEngine.get_odds_multiplier("InvalidOdds", 6)

    def test_none_point(self):
        """Ensure that passing None as the point returns None (no odds allowed)."""
        self.assertIsNone(RulesEngine.get_odds_multiplier("3x-4x-5x", None))
    
    def test_unknown_point(self):
        """Ensure that passing an unsupported point number returns None."""
        self.assertIsNone(RulesEngine.get_odds_multiplier("3x-4x-5x", 11))

    def test_flat_odds_multipliers(self):
        """Ensure flat multipliers return the correct value regardless of point number."""
        for odds_type, expected in [("10x", 10), ("20x", 20), ("100x", 100)]:
            with self.subTest(odds_type=odds_type):
                for point in [4, 5, 6, 8, 9, 10]:  # Test all possible points
                    self.assertEqual(RulesEngine.get_odds_multiplier(odds_type, point), expected)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_payouts.py

import unittest
from craps.common import CommonTableSetup
from craps.rules_engine import RulesEngine

class TestPayouts(unittest.TestCase):
    def setUp(self):
        """Initialize the common table setup for testing."""
        self.common_setup = CommonTableSetup()
        self.rules_engine = RulesEngine()
        self.min_bet = self.common_setup.house_rules.table_minimum
        self.player = self.common_setup.player

    def test_payouts_for_all_bet_types(self):
        """Test that each bet type pays out correctly with the minimum bet when it wins."""
        bet_scenarios = [
            ("Pass Line", (4,3), "come-out", None, None),
            ("Pass Line Odds", (3,3), "point", None, 6),
            ("Come", (5,2), "point", None, None),
            ("Come", (3,3), "point", 6, None),
            ("Come Odds", (2,2), "point", 4, None),
            ("Place", (3,3), "point", 6, None),
            ("Place Odds", (3,3), "point", 6, None),
            ("Field", (1,1), "come-out", None, None),
            ("Field", (6,6), "point", None, None),
            ("Buy", (2,2), "point", 4, None),
            ("Lay", (5,2), "point", 10, None),
            ("Don't Pass", (1,1), "come-out", None, None),
            ("Don't Pass Odds", (5,5), "point", None, 10),
            ("Don't Come", (1,1), "point", None, None),
            ("Don't Come", (3,3), "point", 6, None),
            ("Don't Come Odds", (5,5), "point", 10, None),
            ("Hardways", (2,2), "point", 4, None),
            ("Hardways", (3,3), "point", 6, None),
            ("Hardways", (4,4), "point", 8, None),
            ("Hardways", (5,5), "point", 10, None),
            ("Proposition", (1,1), "come-out", 2, None),
            ("Proposition", (1,2), "point", 3, None),
            ("Proposition", (3,4), "come-out", 7, None),
            ("Proposition", (5,6), "point", 11, None),
            ("Proposition", (6,6), "come-out", 12, None),
            ("Hop", (5,1), "come-out", (1, 5), None),
            ("Hop", (3,3), "point", (3, 3), None)
        ]

        placed_bets = {}  # Dictionary to track placed bets by type

        print("\nPayout Validation for Minimum Bets")
        print("=" * 95)
        print(f"{'Bet Type':<20}{'Dice Roll':<15}{'Phase':<15}{'Bet Is On':<15}{'Point On':<15}{'Expected':<15}{'Actual':<15}")
        print("-" * 95)

        for bet_type, dice_roll, phase, bet_is_on, point_on in bet_scenarios:
            # Set the point number explicitly from test case
            self.point = point_on

            if bet_type in ["Come", "Don't Come"]:
                # First roll: Place the bet with no number
                bet = self.rules_engine.create_bet(bet_type, self.min_bet, self.player, number=None)
                self.common_setup.table.place_bet(bet, "point")  # ✅ Correct phase

                # First roll outcome determines movement or resolution
                first_roll_outcome = tuple(map(int, dice_roll))
                bet.resolve(self.rules_engine, first_roll_outcome, "point", self.point)

                # If the bet moves to a number, store it
                if bet.status == "active" and bet.number is not None:
                    placed_bets[bet_type] = bet

                    # ✅ Ensure a second roll that matches the Come number
                    second_roll_outcome = (bet.number, 1)  # Winning roll
                    bet.resolve(self.rules_engine, second_roll_outcome, "point", self.point)

            elif "Odds" in bet_type:
                # Place Odds bet only if the corresponding Come/Don't Come bet has moved to a number
                parent_bet_type = "Come" if "Come Odds" in bet_type else "Don't Come"
                parent_bet = placed_bets.get(parent_bet_type)
                if parent_bet and parent_bet.number is not None:
                    bet = self.rules_engine.create_bet(
                        bet_type,
                        self.min_bet,
                        self.player,
                        number=parent_bet.number,  # ✅ Now correctly inherits the number
                        parent_bet=parent_bet
                    )
                    self.common_setup.table.place_bet(bet, phase)

            else:
                # Regular bets resolve normally
                bet = self.rules_engine.create_bet(bet_type, self.min_bet, self.player, number=bet_is_on)
                self.common_setup.table.place_bet(bet, phase)

            # Second roll to determine if Come/Don't Come bet wins or loses
            if bet_type in ["Come", "Don't Come"] and bet.status == "active":
                second_roll_outcome = (4, 3)  # Example second roll, can be randomized
                bet.resolve(self.rules_engine, second_roll_outcome, phase, self.point)

            # Ensure dice outcome is correctly formatted
            dice_outcome = tuple(map(int, dice_roll))
            
            # Resolve the bet for payout
            bet.resolve(self.rules_engine, dice_outcome, phase, self.point)

            # Get the payout after resolution
            payout = bet.payout()

            # Expected payout based on rules
            expected_payout = bet.payout()

            # Print formatted results
            print(f"{bet_type:<20}{str(dice_roll):<15}{phase:<15}{str(bet_is_on):<15}{str(point_on):<15}{expected_payout:<15}{payout:<15}")

            # Validate payout
            self.assertEqual(payout, expected_payout)


if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_player.py

import unittest
from craps.house_rules import HouseRules
from craps.player import Player
from craps.play_by_play import PlayByPlay  # Import PlayByPlay

class TestPlayer(unittest.TestCase):
    def setUp(self):
        """Set up a player for testing."""
        house_rules_config = {
            "table_minimum": 5,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.play_by_play = PlayByPlay()
        self.player = Player(name="Test Player", initial_balance=1000)
    
    def test_player_bankroll_persistence(self):
        """Test that a player's bankroll persists across rounds."""
        initial_balance = self.player.balance
        self.player.receive_payout(100, self.play_by_play)
        self.assertEqual(self.player.balance, initial_balance + 100)
    
    def test_player_can_place_bet(self):
        """Test that a player can place a valid bet."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.assertEqual(self.house_rules.table_minimum, 10)
    
    def test_player_cannot_bet_below_minimum(self):
        """Test that a player cannot place a bet below the table minimum."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.assertLess(5, self.house_rules.table_minimum)
    
    def test_player_cannot_bet_above_maximum(self):
        """Test that a player cannot place a bet above the table maximum."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.assertGreater(6000, self.house_rules.table_maximum)
    
    def test_player_balance_after_losing_bet(self):
        """Test that a player's balance decreases after losing a bet."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        initial_balance = self.player.balance
        lost_amount = 50
        self.player.balance -= lost_amount
        self.assertEqual(self.player.balance, initial_balance - lost_amount)
    
    def test_player_balance_after_winning_bet(self):
        """Test that a player's balance increases after winning a bet."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        initial_balance = self.player.balance
        win_amount = 150
        self.player.receive_payout(win_amount, self.play_by_play)
        self.assertEqual(self.player.balance, initial_balance + win_amount)
    
if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_session_manager.py

import sys
import os

# Add project root to path
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from craps.session_manager import SessionManager

def is_interactive() -> bool:
    """Detect whether this script is running in an interactive context (not under pytest)."""
    return sys.stdin.isatty() and sys.stdout.isatty()

def test_basic_session_setup():
    print("\n🔧 Testing SessionManager setup...")
    session_mgr = SessionManager()
    max_shooters = 3
    success = session_mgr.setup_session(num_shooters=max_shooters)

    if not success:
        print("❌ Session initialization failed.")
        return

    print(f"✅ Session initialized successfully!")
    print(f"✅ House Rules: Table Min = ${session_mgr.house_rules.table_minimum}, Max = ${session_mgr.house_rules.table_maximum}")
    print(f"✅ Game initialized with table: {bool(session_mgr.table)}, stats: {bool(session_mgr.stats)}")

    num_players = session_mgr.add_players_from_config()
    print(f"✅ Players added from config: {num_players}")
    for player in session_mgr.player_lineup.get_active_players_list():
        print(f"  🧑 {player.name} [Strategy: {player.name}] — Bankroll: ${player.balance}")

    session_mgr.lock_session()
    print("🔒 Session has been locked. Players and rules are now frozen.")

    # Shooter loop
    for shooter_num in range(1, max_shooters + 1):
        shooter = session_mgr.player_lineup.get_active_players_list()[session_mgr.shooter_index % num_players]
        if session_mgr.game_state:
            session_mgr.game_state.assign_new_shooter(shooter, shooter_num)

        # Inner loop for this shooter
        while True:
            session_mgr.accept_bets()

            if is_interactive():
                user_input = input("\n⏸️ Press Enter to roll the dice (or type 'quit' to exit): ")
                if user_input.strip().lower() == 'quit':
                    print("👋 Exiting test.")
                    return

            outcome = session_mgr.roll_dice()
            print(f"🎯 Dice outcome: {outcome[0]} + {outcome[1]} = {sum(outcome)}")

            session_mgr.resolve_bets(outcome)
            
            puck_msg = "⚫ Puck OFF" if session_mgr.game_state.point == None else f"⚪ Puck is ON {session_mgr.game_state.point}"
            print(puck_msg)

            session_mgr.adjust_bets()

            # 🧾 Print player bet summary
            for player in session_mgr.player_lineup.get_active_players_list():
                remaining_bets = [b for b in session_mgr.table.bets if b.owner == player]
                if remaining_bets:
                    summary = ", ".join(
                        f"{b.bet_type} {b.number} (${b.amount} {b.status})" if b.number else f"{b.bet_type} (${b.amount} {b.status})"
                        for b in remaining_bets
                    )
                    bet_total = sum(b.amount for b in remaining_bets)
                    print(f"  📊 {player.name}'s remaining bets: {summary} | Total on table: ${bet_total} Bankroll: {player.balance}")

            # 🛑 End shooter on 7-out (detected by phase reset)
            if session_mgr.game_state.phase == "come-out" and sum(outcome) == 7:
                session_mgr.stats.record_seven_out()
                session_mgr.shooter_index += 1
                break

            # Prevent infinite loop in non-interactive test runs
            if not is_interactive():
                return

if __name__ == "__main__":
    test_basic_session_setup()


# File: .\tests\test_shooter_rotation.py

import unittest
from craps.common import CommonTableSetup
from craps.player import Player
from time import sleep  # ⏳ Prevent runaway loops

class TestShooterRotation(unittest.TestCase):
    def setUp(self):
        """Initialize the game state and players for testing."""
        self.common_setup = CommonTableSetup()
        self.game_state = self.common_setup.game_state
        self.table = self.common_setup.table
        self.players = [
            Player("Alice", 1000),
            Player("Bob", 1000),
            Player("Charlie", 1000)
        ]

    def test_shooter_rotation(self):
        """Test that the shooter rotates correctly after consecutive 7-outs."""
        print("\n🚀 Testing Shooter Rotation on 7-Outs")

        for round_num in range(1, 4):  # Test rotation for 3 shooters
            player_index = (round_num - 1) % len(self.players)
            shooter = self.players[player_index]  # 🔄 Assign shooter
            self.game_state.assign_new_shooter(shooter, round_num)  # ✅ Set current shooter

            print(f"🎯 Round {round_num}: {shooter.name} is shooting...")

            # 🔢 **Step 1: Roll a point (e.g., 6)**
            self.game_state.update_state((3, 3))  # 🎲 Simulate rolling a 6
            self.assertEqual(self.game_state.point, 6, "Point should be set to 6")

            # 🔢 **Step 2: Roll a 7 (7-out)**
            self.game_state.update_state((4, 3))  # 🎲 Simulate rolling a 7
            self.assertIsNone(self.game_state.point, "Point should reset after 7-out")

            # 🏹 **Shooter should rotate**
            previous_shooter = shooter
            self.game_state.clear_shooter()  # 🚀 Clear shooter flag

            # ✅ **Manually assign next shooter (Single Session does this)**
            new_shooter_index = round_num % len(self.players)
            new_shooter = self.players[new_shooter_index]
            self.game_state.assign_new_shooter(new_shooter, round_num)  # ✅ Assign next shooter

            print(f"❌ {previous_shooter.name} 7-outs! Passing dice to {new_shooter.name}...")

            self.assertFalse(previous_shooter.is_shooter, "Previous shooter should lose turn after 7-out.")
            self.assertTrue(new_shooter.is_shooter, "Next player should become the new shooter.")

            sleep(0.5)  # ⏳ Prevent runaway loop

if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_strategies.py

import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))
import unittest
from craps.rules_engine import RulesEngine
from craps.table import Table
from craps.play_by_play import PlayByPlay
from craps.house_rules import HouseRules
from craps.lineup import PlayerLineup
from craps.player import Player
from craps.game_state import GameState
from craps.strategies.pass_line_strategy import PassLineStrategy
from craps.strategies.three_point_molly_strategy import ThreePointMollyStrategy
from craps.strategies.iron_cross_strategy import IronCrossStrategy
from craps.strategies.double_hop_strategy import DoubleHopStrategy
from craps.strategies.three_two_one_strategy import ThreeTwoOneStrategy
from craps.statistics import Statistics
from craps.strategies.place_reggression_strategy import PlaceRegressionStrategy
from craps.strategies.adjuster_only_strategy import AdjusterOnlyStrategy
from craps.bet_adjusters import PressStyle, PressAdjuster
from craps.strategies.regress_then_press_strategy import RegressThenPressStrategy
from tests.test_utils import assert_contains_bet


class TestStrategies(unittest.TestCase):
    """Tests for betting strategies like Pass Line and Three-Point Molly."""

    def setUp(self):
        """Set up common test environment for all strategies."""
        self.rules_engine = RulesEngine()
        self.play_by_play = PlayByPlay()
        self.house_rules = HouseRules({"table_minimum": 10, "table_maximum": 5000})
        self.player = Player(name="TestPlayer", initial_balance=1000)  # ✅ Create player first
        self.player_lineup = PlayerLineup(self.house_rules, None, self.play_by_play, self.rules_engine)
        self.player_lineup.add_player(self.player)  # ✅ Now safe
        self.table = Table(self.house_rules, self.play_by_play, self.rules_engine, self.player_lineup)
        self.stats = Statistics(self.house_rules.table_minimum, num_shooters=1, num_players=1)
        self.game_state = GameState(stats=self.stats, play_by_play=self.play_by_play)
        self.game_state.set_table(self.table)

    def test_pass_line_base_bet(self):
        """Test placing a Pass Line bet with no odds."""
        strategy = PassLineStrategy(bet_amount=10, table=self.table)  # No odds
        bets = strategy.place_bets(self.game_state, self.player, self.table)

        self.assertEqual(len(bets), 1)
        self.assertEqual(bets[0].bet_type, "Pass Line")
        self.assertEqual(bets[0].amount, 10)

        base_bet = bets[0]
        self.table.place_bet(base_bet, self.game_state.phase)
        self.player.balance -= base_bet.amount

        # Simulate point being established
        self.game_state.point = 6
        base_bet.number = 6

        # Strategy should not place more bets
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        self.assertFalse(bets, "Expected no bets after point is established")

    def test_pass_line_with_odds(self):
        """Test placing a Pass Line bet with different odds types."""
        odds_types = ["1x", "2x", "3x-4x-5x", "10x"]

        for odds_type in odds_types:
            with self.subTest(odds_type=odds_type):
                strategy = PassLineStrategy(bet_amount=10, table=self.table, odds_type=odds_type)
                self.game_state.point = None  # Come-out phase

                bets = strategy.place_bets(self.game_state, self.player, self.table)
                if not bets:
                    continue  # No bet returned, skip this odds_type

                # ✅ Place Pass Line bet BEFORE point is established
                base_bet = bets[0]
                self.table.place_bet(base_bet, self.game_state.phase)
                self.player.balance -= base_bet.amount

                # ✅ Now establish the point
                self.game_state.point = 6
                base_bet.number = self.game_state.point

                # Confirm Pass Line bet is on the table
                matching_bet = next((b for b in self.table.bets if b.bet_type == "Pass Line" and b.owner == self.player), None)
                assert matching_bet is not None, f"Missing base bet for odds_type={odds_type}"

                # Now try placing odds
                odds_bets = strategy.adjust_bets(self.game_state, self.player, self.table)

                self.assertIsNotNone(odds_bets, f"Expected odds bet for odds_type={odds_type}")
                self.assertEqual(len(odds_bets), 1)
                self.assertEqual(odds_bets[0].bet_type, "Pass Line Odds")

                multiplier = self.rules_engine.get_odds_multiplier(odds_type, self.game_state.point)
                expected_odds_amount = 10 * multiplier
                self.assertEqual(odds_bets[0].amount, expected_odds_amount)

                # Strategy should not place more bets
                bets = strategy.place_bets(self.game_state, self.player, self.table)
                self.assertFalse(bets, "Expected no bets after point is established")

    def test_three_point_molly(self):
        """Test Three-Point Molly strategy placing exactly 3 bets and then stopping."""
        strategy = ThreePointMollyStrategy(table=self.table, bet_amount=10, odds_type="3x-4x-5x")

        # 1) Come-out roll
        self.game_state.point = None

        # 2) Strategy places Pass Line bet
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        
        assert_contains_bet(bets, "Pass Line", self.player)

        self.table.place_bet(bets[0], self.game_state.phase)
        self.player.balance -= bets[0].amount

        # 3) Simulate point roll (e.g., point is now 6)
        self.game_state.point = 6

        # 4) Strategy should place first Come bet
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        assert_contains_bet(bets, "Come", self.player)

        come_bet_1 = next(b for b in bets if b.bet_type == "Come" and b.owner == self.player)
        self.table.place_bet(come_bet_1, self.game_state.phase)
        self.player.balance -= come_bet_1.amount

        # 5) Simulate number roll → Come bet resolves to 4
        come_bet_1.number = 4

        # 6) Strategy should place second Come bet
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        assert_contains_bet(bets, "Come", self.player)

        come_bet_2 = next(b for b in bets if b.bet_type == "Come" and b.owner == self.player)
        self.table.place_bet(come_bet_2, self.game_state.phase)
        self.player.balance -= come_bet_2.amount

        # 7) Simulate number roll → Come bet resolves to 9
        come_bet_2.number = 9

        # 8) Strategy should return no more bets (already has 3)
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        base_bets = [b for b in bets if b.bet_type in {"Pass Line", "Come"}]
        self.assertEqual(len(base_bets), 0, "Strategy should not place more than 3 base bets")


    def test_come_odds_working_toggle(self):
        """Test that the strategy correctly toggles come odds working state."""
        strategy = ThreePointMollyStrategy(table=self.table, bet_amount=10, odds_type="3x-4x-5x")

        self.assertFalse(strategy.should_come_odds_be_working())

        # ✅ Set the toggle directly
        strategy.come_odds_working_on_come_out = True

        self.assertTrue(strategy.should_come_odds_be_working())

    def test_iron_cross_strategy(self):
        """Test Iron Cross strategy behavior before and after point is set."""
        strategy = IronCrossStrategy(
            table=self.table,
            rules_engine=self.rules_engine,
            min_bet=self.house_rules.table_minimum,
            play_by_play=self.play_by_play
        )

        # Come-out: should place Pass Line bet only
        self.game_state.point = None
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        assert_contains_bet(bets, "Pass Line", self.player)
        base_bet = bets[0]
        self.table.place_bet(base_bet, self.game_state.phase)
        self.player.balance -= base_bet.amount

        # Simulate point set
        self.game_state.point = 6
        base_bet.number = 6

        # Place Iron Cross setup bets
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        bet_types = [b.bet_type for b in bets]
        self.assertIn("Place", bet_types)
        self.assertIn("Field", bet_types)

        for b in bets:
            self.table.place_bet(b, self.game_state.phase)
            self.player.balance -= b.amount

        # Retry — should return no additional bets
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        self.assertFalse(bets, "Expected no additional bets once Iron Cross is established")

    def setUp(self):
        self.rules_engine = RulesEngine()
        self.play_by_play = PlayByPlay()
        self.house_rules = HouseRules({"table_minimum": 10, "table_maximum": 5000})
        self.player = Player(name="DoubleHopTester", initial_balance=1000)
        self.player_lineup = PlayerLineup(self.house_rules, None, self.play_by_play, self.rules_engine)
        self.player_lineup.add_player(self.player)
        self.table = Table(self.house_rules, self.play_by_play, self.rules_engine, self.player_lineup)
        self.stats = Statistics(self.house_rules.table_minimum, num_shooters=1, num_players=1)
        self.game_state = GameState(stats=self.stats, play_by_play=self.play_by_play)
        self.game_state.set_table(self.table)
        self.strategy = DoubleHopStrategy(hop_target=(1, 1), rules_engine=self.rules_engine, base_bet=10)
        self.player.betting_strategy = self.strategy

    def test_initial_placement(self):
        bets = self.strategy.place_bets(self.game_state, self.player, self.table)
        for bet in bets:
            self.table.place_bet(bet, self.game_state.phase)  # ✅ Actually place the bet

        self.assertEqual(len(self.table.bets), 1)
        hop_bet = self.table.bets[0]
        self.assertEqual(hop_bet.number, (1, 1))
        self.assertEqual(hop_bet.amount, 10)
        self.assertEqual(hop_bet.bet_type, "Hop")

    def test_press_and_reset_cycle(self):
        # Step 1: Place initial bet
        bets = self.strategy.place_bets(self.game_state, self.player, self.table)
        for bet in bets:
            self.table.place_bet(bet, self.game_state.phase)  # ✅ Actually place the bet

        hop_bet = self.table.bets[0]

        # Step 2: First win (should press to 310)
        hop_bet.status = "won"
        hop_bet.resolved_payout = 300
        hop_bet.hits += 1
        self.strategy.adjust_bets(self.game_state, self.player, self.table)
        self.assertEqual(hop_bet.amount, 310)

        # Step 3: Second win (should reset to base bet)
        hop_bet.status = "won"
        hop_bet.resolved_payout = 9300
        hop_bet.hits += 1
        self.strategy.adjust_bets(self.game_state, self.player, self.table)
        self.assertEqual(hop_bet.amount, 10)

    def test_three_two_one_strategy(self):
        # Set up the strategy
        strategy = ThreeTwoOneStrategy(self.rules_engine, min_bet=10)
        self.player.betting_strategy = strategy

        # Step 1: Come-out → expect Pass Line only
        self.game_state.point = None  # Come-out
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        self.assertEqual(len(bets), 1)
        self.assertEqual(bets[0].bet_type, "Pass Line")

        self.table.place_bet(bets[0], self.game_state.phase)
        self.player.balance -= bets[0].amount

        # Step 2: Point is set to 5
        self.game_state.point = 5

        # Step 3: Place inside bets (should exclude 5), and odds
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        bet_types = [b.bet_type for b in bets]
        numbers = [b.number for b in bets if b.bet_type == "Place"]

        self.assertIn("Pass Line Odds", bet_types)
        self.assertCountEqual(numbers, [6, 8, 9])

        for bet in bets:
            self.table.place_bet(bet, self.game_state.phase)
            self.player.balance -= bet.amount

        # Step 4: Simulate 3 hits (6, 8, 9 all win)
        for bet in self.table.bets:
            if bet.bet_type == "Place":
                bet.status = "won"

        strategy.adjust_bets(self.game_state, self.player, self.table)

        # Step 5: Verify that place bets were turned off
        for bet in self.table.bets:
            if bet.bet_type == "Place":
                self.assertEqual(bet.status, "inactive")

        # Step 6: Simulate 5 rolled (point hit)
        for bet in self.table.bets:
            if bet.bet_type in {"Pass Line", "Pass Line Odds"}:
                bet.status = "won"

        # Simulate resolution — not verifying payout here
        # Step 7: Set puck off (new come-out)
        self.game_state.point = None # Come-out
        strategy.adjust_bets(self.game_state, self.player, self.table)  # Should reset state

        # Step 8: New point → place bets should come back alive
        self.game_state.point = 10  # Point
        strategy.place_bets(self.game_state, self.player, self.table)

        for bet in self.table.bets:
            if bet.bet_type == "Place":
                self.assertEqual(bet.status, "active")

    def test_regress_then_half_press_strategy(self):
        """Test RegressThenPressStrategy cycles between regress and press within same shooter."""

        unit_levels = [20, 10, 5]

        regression_strategy = PlaceRegressionStrategy(
            high_unit=unit_levels[0],
            low_unit=unit_levels[-1],
            regression_factor=2,
            regress_units=10
        )

        strategy = RegressThenPressStrategy(
            regression_strategy=regression_strategy,
            press_style=PressStyle.HALF
        )

        self.player.betting_strategy = strategy
        self.game_state.point = 6

        # Phase 1: Start in regression mode
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        self.assertEqual(len(bets), 4)
        self.assertIs(strategy.active_strategy, regression_strategy)
        self.assertFalse(strategy.transitioned)

        for bet in bets:
            self.table.place_bet(bet, self.game_state.phase)
            self.player.balance -= bet.amount

        # Simulate 3 hits to fully regress from 20 → 10 → 5
        for _ in range(3):
            strategy.notify_payout(140)
            self.stats.last_roll_total = 6

            # 🛠️ Each time we must set the matching bet as 'won'
            place_bet = next(
                b for b in self.table.bets if b.bet_type == "Place" and b.number == 6
            )
            place_bet.status = "won"
            place_bet.resolved_payout = 140

            strategy.adjust_bets(self.game_state, self.player, self.table)

        # Confirm child strategy transitioned to press mode
        self.assertEqual(regression_strategy.mode, "press")

    def test_three_point_dolly(self):
        """Test Three-Point Dolly strategy places Don't Pass, Don't Come, and Lay Odds correctly."""
        from craps.strategies.three_point_dolly_strategy import ThreePointDollyStrategy

        strategy = ThreePointDollyStrategy(table=self.table, bet_amount=10, odds_type="3x-4x-5x")
        self.player.betting_strategy = strategy

        # 1) Come-out roll — should place Don't Pass
        self.game_state.point = None
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        assert_contains_bet(bets, "Don't Pass", self.player)

        dp_bet = bets[0]
        self.table.place_bet(dp_bet, self.game_state.phase)
        self.player.balance -= dp_bet.amount

        # 2) Point is established (e.g., 8)
        self.game_state.point = 8

        # 3) Should place Don't Come and lay odds on Don't Pass
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        assert_contains_bet(bets, "Don't Come", self.player)
        assert_contains_bet(bets, "Don't Pass Odds", self.player)

        for b in bets:
            self.table.place_bet(b, self.game_state.phase)
            self.player.balance -= b.amount

        # 4) Simulate Don't Come bet moving to 5
        dc_bet = next(b for b in self.table.bets if b.bet_type == "Don't Come")
        dc_bet.number = 5

        # 5) Place second Don't Come and odds on the first
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        assert_contains_bet(bets, "Don't Come", self.player)
        assert_contains_bet(bets, "Don't Come Odds", self.player)

        for b in bets:
            self.table.place_bet(b, self.game_state.phase)
            self.player.balance -= b.amount

        # 6) Simulate second Don't Come moving to 9
        second_dc = next(b for b in self.table.bets if b.bet_type == "Don't Come" and b.number is None)
        second_dc.number = 9

        # 7) Try placing more Don't Come bets → should NOT place (already have 2 DC points)
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        base_dont_come_bets = [b for b in bets if b.bet_type == "Don't Come"]
        self.assertEqual(len(base_dont_come_bets), 0, "Should not place more than 2 Don't Come bets")

    def test_lay_strategy_outside(self):
        """Test LayBetStrategy places correct Lay bets on 4 and 10 after point is established."""
        from craps.strategies.lay_strategy import LayBetStrategy  # Ensure path matches your layout

        strategy = LayBetStrategy(table=self.table, rules_engine=self.rules_engine, numbers_or_strategy="outside")
        self.player.betting_strategy = strategy

        self.game_state.point = 6  # Simulate point is established

        # Player should lay against 4 and 10
        bets = strategy.place_bets(self.game_state, self.player, self.table)
        self.assertEqual(len(bets), 2)

        expected_numbers = {4, 10}
        actual_numbers = {b.number for b in bets}
        self.assertEqual(expected_numbers, actual_numbers)

        for bet in bets:
            self.assertEqual(bet.bet_type, "Lay")
            self.table.place_bet(bet, self.game_state.phase)
            self.player.balance -= bet.amount

        # Re-invoke — should not place duplicates
        followup_bets = strategy.place_bets(self.game_state, self.player, self.table)
        self.assertEqual(len(followup_bets), 0, "Strategy should not place duplicate Lay bets")

if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_utils.py

def assert_contains_bet(bets, bet_type, owner):
    """
    Assert that a bet of the given type exists for the specified owner.

    Args:
        bets (List[Bet]): List of Bet objects to search.
        bet_type (str): The type of bet to look for (e.g., "Come", "Pass Line").
        owner (Player): The player object.

    Raises:
        AssertionError: If no matching bet is found.
    """
    for b in bets:
        if b.bet_type == bet_type and b.owner == owner:
            return
    raise AssertionError(f"Expected bet type '{bet_type}' for owner '{getattr(owner, 'name', owner)}' not found.")


# File: .\tests\__init__.py



