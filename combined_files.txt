# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.py'):  # Only process Python files
                    file_path = os.path.join(root, file)
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory (change as needed)
output_file = 'combined_files.txt'

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")

# File: .\main.py

# File: .\main.py

from colorama import init, Fore, Style
init()  # Initialize colorama for colored text

from craps.table import Table
from craps.game_state import GameState
from craps.shooter import Shooter
from craps.strategies.pass_line import PassLineStrategy
from craps.strategies.place_bet import PlaceBetStrategy
from craps.statistics import Statistics
from craps.visualizer import Visualizer

def main():
    # Initialize components
    table_minimum = 10  # Set table minimum
    stats = Statistics(table_minimum, num_shooters=10, num_players=3)  # Initialize stats

    # Create the GameState object
    game_state = GameState(stats, players=[])  # Pass stats and empty players list initially

    # Create the Table object
    table = Table(table_minimum=table_minimum)

    # Set the number of players, shooters, and initial bankroll
    num_players = 3
    num_shooters = 10
    initial_bankroll = 500

    # Create players with different betting strategies
    players = [
        Shooter("Pass Line", initial_balance=initial_bankroll, betting_strategy=PassLineStrategy(min_bet=10))
        if i == 0 else
        Shooter("44 Inside", initial_balance=initial_bankroll, betting_strategy=PlaceBetStrategy(table, "inside"))
        if i == 1 else
        Shooter("54 Across", initial_balance=initial_bankroll, betting_strategy=PlaceBetStrategy(table, "across"))
        for i in range(num_players)
    ]

    # Update the GameState with the players
    game_state.players = players

    # Simulate shooters
    for shooter_num in range(1, num_shooters + 1):
        player_index = (shooter_num - 1) % num_players
        shooter = players[player_index]
        game_state.set_shooter(shooter)
        print(f"\n{Fore.CYAN}Shooter {shooter_num} is {shooter.name}. It's their turn to roll.{Style.RESET_ALL}")

        while True:
            # Allow all players to place bets
            for player in players:
                bet = player.betting_strategy.get_bet(game_state, player)
                if bet:
                    player.place_bet(bet, table)

            # Roll the dice and resolve bets
            outcome = shooter.roll_dice()
            total = sum(outcome)
            stats.update_rolls()  # Update roll count
            print(f"{Fore.LIGHTMAGENTA_EX}{shooter.name} rolled: {outcome} (Total: {total}) | Roll Count: {stats.num_rolls}{Style.RESET_ALL}")

            # Check bets on the table
            table.check_bets(outcome, game_state.phase, game_state.point)

            # Resolve bets for each player and update their bankroll
            for player in players:
                player.resolve_bets(table, stats, outcome, game_state.phase, game_state.point)  # Pass phase and point

            # Update player bankrolls in statistics
            stats.update_player_bankrolls(players)

            # Update game state
            previous_phase = game_state.phase
            message = game_state.update_state(outcome)
            if message:
                print(message)

            # Reactivate inactive Place bets after resolving bets
            if game_state.phase == "point":
                for player in players:
                    for bet in player.active_bets:
                        if bet.bet_type.startswith("Place") and bet.status == "inactive":
                            bet.status = "active"
                            print(f"{player.name}'s {bet.bet_type} bet is now ACTIVE.")

            # Check if the shooter 7-outs (only if the point was set)
            if previous_phase == "point" and total == 7:
                print(f"{shooter.name} has 7-ed out. Their turn is over.")
                stats.record_seven_out()  # Record 7-out event

                # Resolve all bets for all players
                for player in players:
                    player.resolve_bets(table, stats, outcome, game_state.phase, game_state.point)  # Pass phase and point

                # Clear all bets from the table
                table.bets.clear()

                stats.update_shooter_stats(shooter)  # Update shooter statistics
                break

    # Update player bankrolls and calculate statistics
    stats.update_player_bankrolls(players)
    stats.print_statistics()
    stats.print_shooter_report()

    # Visualize player bankrolls
    visualizer = Visualizer(stats)
    visualizer.visualize_bankrolls()

if __name__ == "__main__":
    main()


# File: .\setup.py

from setuptools import setup, find_packages

setup(
    name="craps_simulator",
    version="0.1",
    packages=find_packages(),
)

# File: .\craps\bet.py

# File: .\craps\bet.py

class Bet:
    """Base class for all bet types."""
    def __init__(self, bet_type, amount, owner, payout_ratio=(1, 1), locked=True, vig=0):
        """
        Initialize a bet.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Come").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param payout_ratio: The payout ratio as a tuple (numerator, denominator).
        :param locked: Whether the bet is locked (cannot be taken down).
        :param vig: The vig (commission) as a percentage of the bet amount.
        """
        self.bet_type = bet_type
        self.amount = amount
        self.owner = owner
        self.payout_ratio = payout_ratio
        self.locked = locked
        self.vig = vig
        self.status = "active"  # Can be "active", "won", "lost", or "pushed"

    def resolve(self, outcome, phase, point):
        """
        Resolve the bet based on the dice outcome, phase, and point.
        
        :param outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        raise NotImplementedError("Subclasses must implement this method.")

    def payout(self):
        """
        Calculate the payout for the bet.
        - For Pass-Line bets: Return the total payout (original bet + profit).
        - For Place bets: Return the profit only (original bet remains on the table).
        """
        if self.status != "won":
            return 0  # No payout if the bet is not won
        
        # Calculate the profit based on the payout ratio
        numerator, denominator = self.payout_ratio
        profit = self.amount * numerator // denominator
        
        # Deduct the vig (if applicable)
        if self.vig > 0:
            vig_amount = self.amount * self.vig // 100
            profit -= vig_amount
        
        # Return the total payout for Pass-Line bets or profit only for Place bets
        if self.bet_type == "Pass Line":
            return self.amount + profit  # Total payout (original bet + profit)
        else:
            return profit  # Profit only (original bet remains on the table)

    def is_resolved(self):
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def __str__(self):
        return f"{self.owner}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"

# File: .\craps\betting_strategy.py

# File: .\craps\strategies\pass_line.py

from craps.bet_factory import BetFactory

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                return None  # No new bet to place

            # Use the BetFactory to create a Pass Line bet
            return BetFactory.create_pass_line_bet(self.min_bet, player.name)
        return None  # No bet to place

# File: .\craps\bet_factory.py

# File: .\craps\bet_factory.py

from craps.bets import PassLineBet, PlaceBet, PassLineOddsBet

class BetFactory:
    @staticmethod
    def create_pass_line_bet(amount, owner):
        """Create a Pass Line bet."""
        return PassLineBet(amount, owner)

    @staticmethod
    def create_place_bet(amount, owner, number):
        """Create a Place bet."""
        return PlaceBet(amount, owner, number)

    @staticmethod
    def create_pass_line_odds_bet(amount, owner):
        """Create a Pass Line Odds bet."""
        return PassLineOddsBet(amount, owner)

    @staticmethod
    def create_bets(bet_type, amount, owner, number=None):
        """
        Create one or more bets based on the bet type.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Place", "Pass Line Odds").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param number: The number for Place bets (optional).
        :return: A single bet or a list of bets.
        """
        if bet_type == "Pass Line":
            return BetFactory.create_pass_line_bet(amount, owner)
        elif bet_type == "Place":
            return BetFactory.create_place_bet(amount, owner, number)
        elif bet_type == "Pass Line Odds":
            return BetFactory.create_pass_line_odds_bet(amount, owner)
        else:
            raise ValueError(f"Unknown bet type: {bet_type}")

# File: .\craps\dice.py

import random

class Dice:
    def __init__(self):
        self.values = [1, 1]

    def roll(self):
        self.values = [random.randint(1, 6), random.randint(1, 6)]
        return self.values

# File: .\craps\game_state.py

from colorama import Fore, Style
from craps.puck import Puck

class GameState:
    def __init__(self, stats, players):
        """
        Initialize the game state.
        
        :param stats: The Statistics object to track point number rolls.
        :param players: The list of players in the game.
        """
        self.phase = "come-out"
        self.point = None
        self.puck = Puck()
        self.shooter = None
        self.stats = stats  # Store the stats object
        self.players = players  # Store the players list

    def set_shooter(self, shooter):
        """Set the current shooter and reset their statistics."""
        self.shooter = shooter
        self.shooter.reset_stats()

    def update_state(self, dice_outcome):
        """Update the game state based on the dice outcome."""
        total = sum(dice_outcome)
        message = None

        if self.phase == "come-out":
            if total in [7, 11]:
                self.puck.reset()
                message = f"{Fore.GREEN}✅ 7-Winner: Pass Line bets won!{Style.RESET_ALL}"
            elif total in [2, 3, 12]:
                self.puck.reset()
                message = f"{Fore.RED}❌ Craps: Pass Line bets lose!{Style.RESET_ALL}"
            else:
                self.phase = "point"
                self.puck.set_point(total)
                self.point = total
                message = f"{Fore.YELLOW}Point Set: {total}{Style.RESET_ALL}"
                # Reactivate inactive Place bets
                for player in self.players:
                    for bet in player.active_bets:
                        if bet.bet_type.startswith("Place") and bet.status == "inactive":
                            bet.status = "active"
                            print(f"{player.name}'s {bet.bet_type} bet is now ACTIVE.")
        else:  # Point phase
            if total == self.puck.point:
                self.shooter.points_rolled += 1  # Increment points rolled
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"{Fore.GREEN}✅ Point Hit: {total}. Pass Line bets win!{Style.RESET_ALL}"
            elif total == 7:
                self.shooter.rolls_before_7_out = self.shooter.current_roll_count  # Record rolls before 7-out
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"{Fore.RED}❌ 7-Out: Pass Line bets lose!{Style.RESET_ALL}"
            elif total in [4, 5, 6, 8, 9, 10]:  # Point number rolled during point phase
                self.stats.record_point_number_roll()  # Record the roll number

        return message

    def get_puck_state(self):
        if self.puck.position == "On":
            return f"Puck is ON (Point: {self.puck.point})"
        else:
            return "Puck is OFF (Come-out phase)"

    def __str__(self):
        return f"Game State: {self.get_puck_state()}"

# File: .\craps\player.py

# File: .\craps\player.py

from craps.bet import Bet

class Player:
    def __init__(self, name, initial_balance=500, betting_strategy=None):
        """
        Initialize a player.
        
        :param name: The name of the player.
        :param initial_balance: The initial bankroll of the player.
        :param betting_strategy: The betting strategy used by the player.
        """
        self.name = name
        self.balance = initial_balance
        self.betting_strategy = betting_strategy
        self.active_bets = []  # Track active bets for this player

    def place_bet(self, bet, table):
        """Place a bet (or multiple bets) on the table and deduct the amount from the player's balance."""
        # Convert single bet to a list for uniform handling
        bets = [bet] if not isinstance(bet, list) else bet

        # Calculate the total amount to be wagered
        total_amount = sum(b.amount for b in bets)

        # Check if the player has sufficient funds
        if total_amount > self.balance:
            print(f"{self.name} has insufficient funds to place ${total_amount} in bets.")
            return False

        # Place each bet and deduct the amount from the player's balance
        for b in bets:
            self.balance -= b.amount
            table.place_bet(b)
            self.active_bets.append(b)

        # Calculate the total amount at risk on the table
        total_at_risk = sum(b.amount for b in self.active_bets)

        # Summarize the bets placed
        if len(bets) == 1:
            print(f"{self.name} placed a ${bets[0].amount} {bets[0].bet_type} bet. Bankroll: ${self.balance}. Bet: ${total_at_risk}")
        else:
            bet_summary = ", ".join(f"{b.bet_type} ${b.amount}" for b in bets)
            print(f"{self.name} bet ${total_amount} on {bet_summary}. Bankroll: ${self.balance}. Bet: ${total_at_risk}")

        return True

    def resolve_bets(self, table, stats, outcome, phase, point):
        """Resolve all active bets for the player and update the bankroll."""
        # Summarize Won/Lost bets for the player
        won_lost_bets = []
        total_payout = 0

        # Create a copy of active_bets to avoid modifying the list while iterating
        active_bets_copy = self.active_bets.copy()

        for bet in active_bets_copy:
            # Resolve the bet (let the bet class handle the logic)
            bet.resolve(outcome, phase, point)  # Pass phase and point directly

            if bet.status == "won":
                # Calculate the payout
                payout = bet.payout()
                total_payout += payout
                won_lost_bets.append(f"{bet.bet_type} bet WON ${payout}")
                self.balance += payout  # Add the payout to the player's bankroll
                stats.total_player_win_loss += payout  # Update player win/loss (total payout)
                stats.total_house_win_loss -= payout  # Update house win/loss (loss of total payout)

                # Remove Pass-Line bets from the table when won
                if bet.bet_type == "Pass Line":
                    self.active_bets.remove(bet)
                # Reset the Place bet status to "active" after winning
                elif bet.bet_type.startswith("Place"):
                    bet.status = "active"
            elif bet.status == "lost":
                won_lost_bets.append(f"{bet.bet_type} bet LOST ${bet.amount}")
                # Do NOT deduct the bet amount again (it was already deducted when the bet was placed)
                stats.total_player_win_loss -= 0  # No additional loss for the player
                stats.total_house_win_loss += bet.amount  # House collects the original bet

                # Remove lost bets from the table
                self.active_bets.remove(bet)
            elif bet.status == "inactive":
                # Do NOT remove inactive bets; they will be reactivated when the puck is turned on
                pass

        # Calculate the total amount at risk on the table
        total_at_risk = sum(b.amount for b in self.active_bets)

        # Print summary of resolved bets
        if won_lost_bets:
            print(f"{self.name}'s resolved bets: {', '.join(won_lost_bets)}. Total Payout: ${total_payout}. Updated Bankroll: ${self.balance}. Bet: ${total_at_risk}")

        # Summarize bets still on the table for the player
        active_bets_summary = [
            f"{bet.bet_type}{' (Off)' if bet.status == 'inactive' else ''}"
            for bet in self.active_bets
        ]
        if active_bets_summary:
            print(f"{self.name}'s active bets: {', '.join(active_bets_summary)}")
        else:
            print(f"{self.name} has no active bets.")

    def __str__(self):
        return f"Player: {self.name}, Balance: ${self.balance}"

# File: .\craps\puck.py

from colorama import Fore, Style
class Puck:
    def __init__(self):
        self.position = "Off"
        self.point = None

    def set_point(self, value):
        self.position = "On"
        self.point = value
        print(f"{Fore.MAGENTA}Puck is now ON{Style.RESET_ALL}")

    def reset(self):
        self.position = "Off"
        self.point = None
        print(f"{Fore.MAGENTA}Puck is now OFF{Style.RESET_ALL}")

# File: .\craps\shooter.py

from craps.player import Player
from craps.dice import Dice

class Shooter(Player):
    def __init__(self, name, initial_balance=0, betting_strategy=None):
        super().__init__(name, initial_balance, betting_strategy)
        self.dice = Dice()
        self.points_rolled = 0  # Number of times the shooter rolled the point
        self.rolls_before_7_out = 0  # Number of rolls before 7-ing out
        self.current_roll_count = 0  # Tracks rolls in the current turn

    def roll_dice(self):
        """Roll the dice and update shooter statistics."""
        outcome = self.dice.roll()
        self.current_roll_count += 1
        return outcome

    def reset_stats(self):
        """Reset shooter statistics for a new turn."""
        self.points_rolled = 0
        self.rolls_before_7_out = 0
        self.current_roll_count = 0

# File: .\craps\statistics.py

# File: .\craps\statistics.py

class Statistics:
    def __init__(self, table_minimum, num_shooters, num_players):
        self.table_minimum = table_minimum
        self.num_shooters = num_shooters
        self.num_players = num_players
        self.num_rolls = 0
        self.total_house_win_loss = 0
        self.total_player_win_loss = 0
        self.player_bankrolls = []
        self.highest_bankroll = 0
        self.lowest_bankroll = float('inf')
        self.shooter_stats = {}

        # For visualization
        self.roll_numbers = []  # Track roll numbers
        self.bankroll_history = {}  # Track bankroll history for each player
        self.seven_out_rolls = []  # Track rolls where a 7-out occurs
        self.point_number_rolls = []  # Track rolls where a point number (4, 5, 6, 8, 9, 10) is rolled

    def update_rolls(self):
        """Increment the roll count."""
        self.num_rolls += 1
        self.roll_numbers.append(self.num_rolls)

    def update_player_bankrolls(self, players):
        """Update player bankrolls and track highest/lowest bankroll."""
        self.player_bankrolls = [player.balance for player in players]
        self.highest_bankroll = max(self.player_bankrolls)
        self.lowest_bankroll = min(self.player_bankrolls)

        # Track bankroll history for visualization
        for player in players:
            if player.name not in self.bankroll_history:
                self.bankroll_history[player.name] = []
            self.bankroll_history[player.name].append(player.balance)

    def record_seven_out(self):
        """Record the roll number where a 7-out occurs."""
        self.seven_out_rolls.append(self.num_rolls)
        
    def record_point_number_roll(self):
        """Record the roll number where a point number (4, 5, 6, 8, 9, 10) is rolled."""
        self.point_number_rolls.append(self.num_rolls)

    def visualize_bankrolls(self):
        """Visualize player bankrolls over time."""
        import matplotlib.pyplot as plt

        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.bankroll_history.items():
            # Ensure bankrolls and roll_numbers have the same length
            if len(bankrolls) != len(self.roll_numbers):
                # Trim the longer list to match the shorter one
                min_length = min(len(bankrolls), len(self.roll_numbers))
                bankrolls = bankrolls[:min_length]
                roll_numbers = self.roll_numbers[:min_length]
            else:
                roll_numbers = self.roll_numbers
            plt.plot(roll_numbers, bankrolls, label=player)

        # Add red vertical lines for 7-out events
        for roll in self.seven_out_rolls:
            plt.axvline(x=roll, color='red', linestyle='--', alpha=0.5, label='7-Out' if roll == self.seven_out_rolls[0] else "")

        # Add green dotted lines for point number rolls
        for roll in self.point_number_rolls:
            plt.axvline(x=roll, color='green', linestyle=':', alpha=0.5, label='Point Number Rolled' if roll == self.point_number_rolls[0] else "")

        # Add labels and title
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)
        plt.show()

    def update_shooter_stats(self, shooter):
        """Update shooter statistics."""
        if shooter.name not in self.shooter_stats:
            self.shooter_stats[shooter.name] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "total_rolls": 0,
            }
        self.shooter_stats[shooter.name]["points_rolled"] += shooter.points_rolled
        self.shooter_stats[shooter.name]["rolls_before_7_out"].append(shooter.rolls_before_7_out)
        self.shooter_stats[shooter.name]["total_rolls"] += shooter.current_roll_count

    def print_statistics(self):
        """Print the simulation statistics."""
        print("\n=== Simulation Statistics ===")
        print(f"Table Minimum: ${self.table_minimum}")
        print(f"Number of Shooters: {self.num_shooters}")
        print(f"Number of Players: {self.num_players}")
        print(f"Number of Rolls: {self.num_rolls}")
        print(f"Total House Win/Loss: ${self.total_house_win_loss}")
        print(f"Total Player Win/Loss: ${self.total_player_win_loss}")
        print(f"Player Bankrolls: {self.player_bankrolls}")
        print(f"Highest Player Bankroll: ${self.highest_bankroll}")
        print(f"Lowest Player Bankroll: ${self.lowest_bankroll}")

    def print_shooter_report(self):
        """Print a report summarizing each shooter's performance."""
        print("\n=== Shooter Performance Report ===")
        for shooter_name, stats in self.shooter_stats.items():
            total_points_rolled = stats["points_rolled"]
            total_rolls = stats["total_rolls"]
            rolls_before_7_out = stats["rolls_before_7_out"]
            avg_rolls_before_7_out = sum(rolls_before_7_out) / len(rolls_before_7_out) if rolls_before_7_out else 0

            print(f"\nShooter: {shooter_name}")
            print(f"  Total Points Rolled: {total_points_rolled}")
            print(f"  Total Rolls: {total_rolls}")
            print(f"  Average Rolls Before 7-Out: {avg_rolls_before_7_out:.2f}")
            print(f"  Rolls Before 7-Out: {rolls_before_7_out}")

# File: .\craps\table.py

# File: .\craps\table.py

class Table:
    def __init__(self, table_minimum=5):
        """
        Initialize the table with a minimum bet.
        
        :param table_minimum: The minimum bet for the table (e.g., 5, 10, 15, 25).
        """
        self.bets = []
        self.table_minimum = table_minimum
        self.unit = table_minimum // 5  # Unit is table minimum divided by 5

    def place_bet(self, bet):
        """Place a bet on the table."""
        self.bets.append(bet)

    def check_bets(self, outcome, phase, point):
        """Check and resolve all bets on the table based on the dice outcome, phase, and point."""
        total = sum(outcome)

        # Create a copy of bets to avoid modifying the list while iterating
        bets_copy = self.bets.copy()

        for bet in bets_copy:
            # Only resolve active bets
            if bet.status == "active":
                bet.resolve(outcome, phase, point)

        # If a 7-out occurs, clear all bets from the table
        if phase == "come-out" and total == 7:
            self.bets.clear()

    def get_minimum_bet(self, number):
        """
        Get the minimum bet for a Place bet on a specific number.
        
        :param number: The number being bet on (4, 5, 6, 8, 9, or 10).
        :return: The minimum bet amount.
        """
        if number in [6, 8]:
            # For 6 and 8, the minimum bet is table minimum + unit
            return self.table_minimum + self.unit
        else:
            # For other numbers, the minimum bet is the table minimum
            return self.table_minimum

# File: .\craps\visualizer.py

# File: .\craps\visualizer.py

import matplotlib.pyplot as plt

class Visualizer:
    def __init__(self, stats):
        self.stats = stats

    def visualize_bankrolls(self):
        """Visualize player bankrolls over time."""
        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.stats.bankroll_history.items():
            # Ensure bankrolls and roll_numbers have the same length
            if len(bankrolls) != len(self.stats.roll_numbers):
                # Trim the longer list to match the shorter one
                min_length = min(len(bankrolls), len(self.stats.roll_numbers))
                bankrolls = bankrolls[:min_length]
                roll_numbers = self.stats.roll_numbers[:min_length]
            else:
                roll_numbers = self.stats.roll_numbers
            plt.plot(roll_numbers, bankrolls, label=player)

        # Add red vertical lines for 7-out events
        for roll in self.stats.seven_out_rolls:
            plt.axvline(x=roll, color='red', linestyle='--', alpha=0.5, label='7-Out' if roll == self.stats.seven_out_rolls[0] else "")

        # Add green dashed lines for point number rolls
        for roll in self.stats.point_number_rolls:
            plt.axvline(x=roll, color='green', linestyle=':', alpha=0.5, label='Point Number Rolled' if roll == self.stats.point_number_rolls[0] else "")

        # Add labels and title
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)
        plt.show()

# File: .\craps\__init__.py



# File: .\craps\bets\pass_line.py

# File: .\craps\bets\pass_line.py

from . import Bet  # Import the base Bet class from the bets package

class PassLineBet(Bet):
    """Class representing a Pass Line bet."""
    def __init__(self, amount, owner):
        super().__init__("Pass Line", amount, owner, payout_ratio=(1, 1), locked=True)

    def resolve(self, outcome, phase, point):
        """Resolve the Pass Line bet based on the dice outcome, phase, and point."""
        total = sum(outcome)
        
        if phase == "come-out":
            if total in [7, 11]:
                self.status = "won"  # Pass Line bet wins
            elif total in [2, 3, 12]:
                self.status = "lost"  # Pass Line bet loses
            else:
                self.status = "active"  # Point is set; bet remains active
        else:  # Point phase
            if total == point:
                self.status = "won"  # Pass Line bet wins
            elif total == 7:
                self.status = "lost"  # Pass Line bet loses
            else:
                self.status = "active"  # Bet remains active

# File: .\craps\bets\pass_line_odds.py

# File: .\craps\bets\pass_line_odds.py

from . import Bet  # Import the base Bet class from the bets package

class PassLineOddsBet(Bet):
    """Class representing a Pass Line Odds bet."""
    def __init__(self, amount, owner):
        super().__init__("Pass Line Odds", amount, owner, payout_ratio=(1, 1), locked=False)

    def resolve(self, outcome, phase, point):
        """Resolve the Pass Line Odds bet based on the dice outcome, phase, and point."""
        total = sum(outcome)
        
        if phase == "point":
            if total == point:
                if point in [4, 10]:
                    self.payout_ratio = (2, 1)  # 2:1 payout for 4 and 10
                elif point in [5, 9]:
                    self.payout_ratio = (3, 2)  # 3:2 payout for 5 and 9
                elif point in [6, 8]:
                    self.payout_ratio = (6, 5)  # 6:5 payout for 6 and 8
                self.status = "won"  # Pass Line Odds bet wins
            elif total == 7:
                self.status = "lost"  # Pass Line Odds bet loses
            else:
                self.status = "active"  # Bet remains active

# File: .\craps\bets\place_bet.py

# File: .\craps\bets\place_bet.py

from . import Bet  # Import the base Bet class from the bets package

class PlaceBet(Bet):
    """Class representing a Place bet."""
    def __init__(self, amount, owner, number):
        super().__init__(f"Place {number}", amount, owner, locked=False)
        self.number = number

    def resolve(self, outcome, phase, point):
        """Resolve the Place bet based on the dice outcome, phase, and point."""
        total = sum(outcome)
        
        if phase == "come-out":
            self.status = "inactive"  # Place bets are inactive during the come-out phase
            return
        
        if phase == "point":
            if total == self.number:
                if self.number in [4, 10]:
                    self.payout_ratio = (9, 5)  # 9:5 payout for 4 and 10
                elif self.number in [5, 9]:
                    self.payout_ratio = (7, 5)  # 7:5 payout for 5 and 9
                elif self.number in [6, 8]:
                    self.payout_ratio = (7, 6)  # 7:6 payout for 6 and 8
                self.status = "won"  # Place bet wins
            elif total == 7:
                self.status = "lost"  # Place bet loses on 7-out
            else:
                self.status = "active"  # Bet remains active

# File: .\craps\bets\__init__.py

# File: .\craps\bets\__init__.py

# Define the base Bet class
class Bet:
    """Base class for all bet types."""
    def __init__(self, bet_type, amount, owner, payout_ratio=(1, 1), locked=True, vig=0):
        """
        Initialize a bet.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Come").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param payout_ratio: The payout ratio as a tuple (numerator, denominator).
        :param locked: Whether the bet is locked (cannot be taken down).
        :param vig: The vig (commission) as a percentage of the bet amount.
        """
        self.bet_type = bet_type
        self.amount = amount
        self.owner = owner
        self.payout_ratio = payout_ratio
        self.locked = locked
        self.vig = vig
        self.status = "active"  # Can be "active", "won", "lost", or "pushed"

    def calculate_profit(self):
        """Calculate the profit for the bet based on the payout ratio and vig."""
        numerator, denominator = self.payout_ratio
        profit = self.amount * numerator // denominator
        
        # Deduct the vig (if applicable)
        if self.vig > 0:
            vig_amount = self.amount * self.vig // 100
            profit -= vig_amount
        
        return profit

    def payout(self):
        """
        Calculate the payout for the bet.
        - For Pass-Line bets: Return the total payout (original bet + profit).
        - For Place bets: Return the profit only (original bet remains on the table).
        """
        if self.status != "won":
            return 0  # No payout if the bet is not won
        
        profit = self.calculate_profit()
        
        # Return the total payout for Pass-Line bets or profit only for Place bets
        if self.bet_type == "Pass Line":
            return self.amount + profit  # Total payout (original bet + profit)
        else:
            return profit  # Profit only (original bet remains on the table)

    def resolve(self, outcome, phase, point):
        """
        Resolve the bet based on the dice outcome, phase, and point.
        
        :param outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        raise NotImplementedError("Subclasses must implement this method.")

    def is_resolved(self):
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def __str__(self):
        return f"{self.owner}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"


# Import and re-export the bet classes
from .pass_line import PassLineBet
from .place_bet import PlaceBet
from .pass_line_odds import PassLineOddsBet

# Optionally, define __all__ to make it clear which classes are exported
__all__ = ["Bet", "PassLineBet", "PlaceBet", "PassLineOddsBet"]

# File: .\craps\strategies\pass_line.py

# File: .\craps\strategies\pass_line.py

from craps.bets.pass_line import PassLineBet  # Import the PassLineBet class

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                # print(f"{player.name} already has an active Pass Line bet.")
                return None  # No new bet to place

            # Place a new Pass Line bet
            return PassLineBet(self.min_bet, player.name)  # Use PassLineBet instead of Bet
        return None  # No bet to place

# File: .\craps\strategies\pass_line_odds.py

# File: .\craps\strategies\pass_line_odds.py

from craps.bet_factory import BetFactory

class PassLineOddsStrategy:
    """Betting strategy for Pass Line with Odds bets."""
    def __init__(self, min_bet, odds_multiple=1):
        self.min_bet = min_bet
        self.odds_multiple = odds_multiple

    def get_bet(self, game_state, player):
        """Place a Pass Line or Pass Line Odds bet based on the game state."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                return None  # No new bet to place

            # Use the BetFactory to create a Pass Line bet
            return BetFactory.create_pass_line_bet(self.min_bet, player.name)
        
        elif game_state.phase == "point":
            # Check if the player already has an active Pass Line Odds bet
            if any(b.bet_type == "Pass Line Odds" for b in player.active_bets):
                return None  # No new bet to place

            # Use the BetFactory to create a Pass Line Odds bet
            return BetFactory.create_pass_line_odds_bet(self.min_bet * self.odds_multiple, player.name)
        
        return None  # No bet to place

# File: .\craps\strategies\place_bet.py

# File: .\craps\strategies\place_bet.py

from craps.bet_factory import BetFactory

class PlaceBetStrategy:
    """Betting strategy for Place Bets."""
    def __init__(self, table, numbers_or_strategy):
        """
        Initialize the Place Bet strategy.
        
        :param table: The table object to determine minimum bets.
        :param numbers_or_strategy: A list of numbers (e.g., [5, 6, 8, 9]) or a strategy ("inside", "across").
        """
        self.table = table
        self.numbers_or_strategy = numbers_or_strategy

    def get_bet(self, game_state, player):
        """Place Place Bets based on the strategy and game state."""
        if game_state.phase != "point":
            return None  # Only place bets after the point is established

        # Determine which numbers to bet on
        if isinstance(self.numbers_or_strategy, str):
            if self.numbers_or_strategy == "inside":
                numbers = [5, 6, 8, 9]  # Inside numbers
            elif self.numbers_or_strategy == "across":
                numbers = [4, 5, 6, 8, 9, 10]  # Across numbers
            else:
                raise ValueError(f"Invalid strategy: {self.numbers_or_strategy}")
        else:
            numbers = self.numbers_or_strategy  # Specific numbers provided

        # Filter out numbers already covered by a Pass Line bet or a Place bet
        numbers = [
            num for num in numbers
            if not any(
                (b.bet_type == "Pass Line" and b.point == num) or  # Pass Line covers the point
                (b.bet_type.startswith("Place") and b.number == num)  # Place Bet covers the number
                for b in player.active_bets
            )
        ]

        # Use the BetFactory to create Place bets
        bets = []
        for number in numbers:
            min_bet = self.table.get_minimum_bet(number)
            bets.append(BetFactory.create_place_bet(min_bet, player.name, number))

        return bets if bets else None

# File: .\tests\test_dice.py

import sys
import os
import unittest
from craps.dice import Dice

class TestDice(unittest.TestCase):
    def test_roll(self):
        dice = Dice()
        num_rolls = 1_000_000  # Number of rolls to simulate
        tolerance = 0.001  # Tolerance for probability comparison

        # Initialize counters for single die outcomes
        single_die_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}

        # Initialize counters for total outcomes
        total_counts = {
            2: 0, 3: 0, 4: 0, 5: 0, 6: 0,
            7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0
        }

        # Roll the dice 1 million times
        for _ in range(num_rolls):
            outcome = dice.roll()
            total = sum(outcome)

            # Count single die outcomes
            for die in outcome:
                single_die_counts[die] += 1

            # Count total outcomes
            total_counts[total] += 1

        # Calculate observed probabilities for single die outcomes
        single_die_probs = {
            die: count / (num_rolls * 2)  # Each roll involves 2 dice
            for die, count in single_die_counts.items()
        }

        # Calculate observed probabilities for total outcomes
        total_probs = {
            total: count / num_rolls
            for total, count in total_counts.items()
        }

        # Expected probabilities for single die outcomes
        expected_single_die_prob = 1 / 6

        # Expected probabilities for total outcomes
        expected_total_probs = {
            2: 1 / 36,
            3: 2 / 36,
            4: 3 / 36,
            5: 4 / 36,
            6: 5 / 36,
            7: 6 / 36,
            8: 5 / 36,
            9: 4 / 36,
            10: 3 / 36,
            11: 2 / 36,
            12: 1 / 36,
        }

        # Display results for single die outcomes
        print("\nSingle Die Outcomes:")
        print(f"{'Outcome':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for die in range(1, 7):
            actual = single_die_probs[die]
            expected = expected_single_die_prob
            deviation = actual - expected
            print(f"{die:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Display results for total outcomes
        print("\nTotal Outcomes:")
        print(f"{'Total':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for total in range(2, 13):
            actual = total_probs[total]
            expected = expected_total_probs[total]
            deviation = actual - expected
            print(f"{total:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Test single die outcomes
        for die, prob in single_die_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_single_die_prob,
                delta=tolerance,
                msg=f"Single die outcome {die} probability is not within tolerance."
            )

        # Test total outcomes
        for total, prob in total_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_total_probs[total],
                delta=tolerance,
                msg=f"Total outcome {total} probability is not within tolerance."
            )

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_player.py

import unittest
from craps.player import Player
from craps.table import Table
from craps.bet import Bet

class TestPlayer(unittest.TestCase):
    def test_place_bet(self):
        player = Player("Alice", 1000)
        table = Table()
        player.place_bet("Pass Line", 100, table)
        self.assertEqual(player.balance, 900)
        self.assertEqual(len(player.bets), 1)
        self.assertEqual(len(table.bets), 1)

    def test_resolve_bets(self):
        player = Player("Alice", 1000)
        table = Table()
        bet = Bet("Pass Line", 100, "Alice")
        table.place_bet(bet)
        player.bets.append(bet)

        # Simulate a win
        bet.status = "won"
        player.resolve_bets(table)
        self.assertEqual(player.balance, 1100)
        self.assertEqual(len(player.bets), 0)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_puck.py

import unittest
from craps.puck import Puck

class TestPuck(unittest.TestCase):
    def test_puck(self):
        puck = Puck()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

        puck.set_point(4)
        self.assertEqual(puck.position, "On")
        self.assertEqual(puck.point, 4)

        puck.reset()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_shooter.py

import unittest
from craps.shooter import Shooter

class TestShooter(unittest.TestCase):
    def test_roll_dice(self):
        shooter = Shooter("Alice")
        outcome = shooter.roll_dice()
        self.assertIsInstance(outcome, list)
        self.assertEqual(len(outcome), 2)
        self.assertTrue(1 <= outcome[0] <= 6)
        self.assertTrue(1 <= outcome[1] <= 6)

if __name__ == "__main__":
    unittest.main()

