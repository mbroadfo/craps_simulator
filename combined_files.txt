# File: .\config.py

# File: .\config.py

ACTIVE_PLAYERS = {
    "Pass-Line": False,
    "Pass-Line w/ Odds": True,
    "$44 Inside": False,
    "$54 Across": False,
    "Field": False,
    "Iron Cross": True,
    "3-Point Molly": True,
}

# Add a new configuration entry for session mode
SESSION_MODE = "live"  # Options: "live" or "history"

# House Rules Configuration
HOUSE_RULES = {
    "field_bet_payout_2": (2, 1),  # 2:1 payout for 2
    "field_bet_payout_12": (3, 1),  # 3:1 payout for 12
    "table_minimum": 10,  # Minimum bet amount
    "table_maximum": 5000,  # Maximum bet amount
    "come_odds_working_on_come_out": False,  # Whether Come odds bets are working during the come-out roll
}


# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.py'):  # Only process Python files
                    file_path = os.path.join(root, file)
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory (change as needed)
output_file = 'combined_files.txt'

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")

# File: .\main.py

# File: .\main.py

from colorama import init, Fore, Style
from config import ACTIVE_PLAYERS, SESSION_MODE, HOUSE_RULES
from craps.session_initializer import InitializeSession
from craps.player_setup import SetupPlayers
from craps.single_session import run_single_session
from craps.visualizer import Visualizer
from craps.view_log import InteractiveLogViewer

def main():
    init()  # Initialize colorama for colored text

    # Initialize the session
    session_initializer = InitializeSession(SESSION_MODE, HOUSE_RULES)
    result = session_initializer.prepare_session()
    if not result:
        return  # Exit if session initialization fails

    house_rules, table, roll_history_manager, log_manager, play_by_play = result

    # Set up players
    player_setup = SetupPlayers(house_rules, table, ACTIVE_PLAYERS)
    strategies, player_names = player_setup.setup()

    # Get the roll history file based on the session mode
    roll_history_file = roll_history_manager.get_roll_history_file(SESSION_MODE)

    # Run the session
    stats = run_single_session(
        house_rules,
        strategies,
        player_names=player_names,
        roll_history_file=roll_history_file,
        play_by_play=play_by_play
    )

    # Save the roll history if running in live mode
    if SESSION_MODE == "live":
        roll_history_manager.save_roll_history(stats.roll_history)

    # Print statistics
    stats.print_statistics()
    stats.print_shooter_report()
    stats.print_player_statistics()
    
    # View the log file interactively
    log_viewer = InteractiveLogViewer()
    log_viewer.view(log_manager.log_file)
    
    # Visualize player bankrolls
    visualizer = Visualizer(stats)
    visualizer.visualize_bankrolls()

if __name__ == "__main__":
    main()

# File: .\setup.py

from setuptools import setup, find_packages

setup(
    name="craps_simulator",
    version="0.1",
    packages=find_packages(),
)

# File: .\craps\bet.py

# File: .\craps\bet.py

from typing import List, Optional, Tuple
import logging

class Bet:
    """Base class for all bet types."""
    VALID_PHASES = ["come-out", "point"]  # Define valid phases as a class constant

    def __init__(
        self,
        bet_type: str,
        amount: int,
        owner,
        payout_ratio: Tuple[int, int] = (1, 1),
        locked: bool = True,
        vig: int = 0,
        unit: int = 1,
        valid_phases: List[str] = None,
        number: Optional[int] = None,
        parent_bet: Optional['Bet'] = None
    ):
        """
        Initialize a bet.

        :param bet_type: The type of bet (e.g., "Pass Line", "Place").
        :param amount: The amount of the bet.
        :param owner: The Player object who placed the bet.
        :param payout_ratio: The payout ratio as a tuple (numerator, denominator).
        :param locked: Whether the bet is locked (cannot be taken down).
        :param vig: The vig (commission) as a percentage of the bet amount.
        :param unit: The unit for Place/Buy bets (default is 1).
        :param valid_phases: The phases during which the bet can be placed (default is all phases).
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        """
        self.bet_type = bet_type
        self.amount = amount
        self.owner = owner
        self.payout_ratio = payout_ratio
        self.locked = locked
        self.vig = vig
        self.unit = unit
        self.valid_phases = valid_phases if valid_phases is not None else self.VALID_PHASES
        self.number = number
        self.status = "active"
        self.parent_bet = parent_bet

    def validate_bet(self, phase: str, table_minimum: int, table_maximum: int) -> bool:
        """
        Validate the bet based on the game phase, table limits, and bet type.

        :param phase: The current game phase ("come-out" or "point").
        :param table_minimum: The table's minimum bet amount.
        :param table_maximum: The table's maximum bet amount.
        :return: True if the bet is valid, False otherwise.
        """
        # Check if the bet can be placed during the current phase
        if phase not in self.valid_phases:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet cannot be placed during the {phase} phase.")
            return False

        # Check if the bet amount is within table limits
        if self.amount < table_minimum:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} is below the table minimum of ${table_minimum}.")
            return False
        if self.amount > table_maximum:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} exceeds the table maximum of ${table_maximum}.")
            return False

        # Check if the bet amount is valid for the bet type
        if self.bet_type in ["Place", "Buy"]:
            if self.amount % self.unit != 0:
                logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} must be a multiple of ${self.unit}.")
                return False

        return True

    def resolve(self, rules_engine, dice_outcome: List[int], phase: str, point: Optional[int]) -> None:
        """
        Resolve the bet based on the dice outcome, phase, and point.
        Delegates resolution logic to the RulesEngine.

        :param rules_engine: The RulesEngine instance to use for resolution.
        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        rules_engine.resolve_bet(self, dice_outcome, phase, point)

    def is_resolved(self) -> bool:
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def payout(self) -> int:
        """
        Calculate the payout for the bet.

        :return: The payout amount.
        """
        if self.status != "won":
            return 0

        numerator, denominator = self.payout_ratio
        profit = self.amount * numerator // denominator

        # Deduct the vig (if applicable)
        if self.vig > 0:
            vig_amount = self.amount * self.vig // 100
            profit -= vig_amount

        return profit if self.bet_type != "Pass Line" else self.amount + profit

    def __str__(self):
        """Return a string representation of the bet."""
        if self.number is not None:
            return f"{self.owner.name}'s ${self.amount} {self.bet_type} {self.number} bet (Status: {self.status})"
        else:
            return f"{self.owner.name}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"

# File: .\craps\betting_strategy.py

# File: .\craps\strategies\pass_line.py

from craps.bet_factory import BetFactory

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                return None  # No new bet to place

            # Use the BetFactory to create a Pass Line bet
            return BetFactory.create_pass_line_bet(self.min_bet, player.name)
        return None  # No bet to place

# File: .\craps\common.py

# File: .\craps\common.py

from craps.house_rules import HouseRules
from craps.table import Table
from craps.play_by_play import PlayByPlay
from craps.rules_engine import RulesEngine
from craps.player import Player
from craps.dice import Dice
from craps.statistics import Statistics  # Import the Statistics class

class CommonTableSetup:
    """Common setup for all craps tests."""

    def __init__(self):
        """Initialize the table, players, and other components for testing."""
        # Initialize house rules
        self.house_rules_config = {
            "field_bet_payout_2": (2, 1),  # 2:1 payout for 2
            "field_bet_payout_12": (3, 1),  # 3:1 payout for 12
            "table_minimum": 10,  # Minimum bet amount
            "table_maximum": 5000,  # Maximum bet amount
        }
        self.house_rules = HouseRules(self.house_rules_config)

        # Initialize play-by-play and rules engine
        self.play_by_play = PlayByPlay()
        self.rules_engine = RulesEngine()

        # Initialize the table
        self.table = Table(self.house_rules, self.play_by_play, self.rules_engine)

        # Initialize a player
        self.player_name = "Alice"
        self.initial_balance = 1000
        self.player = Player(self.player_name, self.initial_balance)

        # Initialize statistics
        self.stats = Statistics(self.house_rules.table_minimum, num_shooters=10, num_players=1)

        # Initialize dice (optional, for testing specific rolls)
        self.dice = Dice()

    def place_bet(self, bet_type, amount, phase="come-out", number=None):
        """
        Place a bet on the table for the player.

        :param bet_type: The type of bet (e.g., "Field", "Pass Line").
        :param amount: The amount of the bet.
        :param phase: The current game phase ("come-out" or "point").
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :return: The created bet.
        """
        if bet_type == "Come Odds":
            # Ensure the Come bet has a number before placing the Come Odds bet
            come_bet = next((bet for bet in self.table.bets if bet.bet_type == "Come" and bet.owner == self.player), None)
            if come_bet is None or come_bet.number is None:
                raise ValueError("Cannot place Come Odds bet without an active Come bet with a number.")
            number = come_bet.number  # Use the number from the Come bet

        bet = self.rules_engine.create_bet(bet_type, amount, self.player, number=number)
        self.table.place_bet(bet, phase)
        return bet

    def simulate_roll(self, dice_outcome, phase="come-out", point=None):
        """
        Simulate a dice roll and resolve bets on the table.

        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        :return: A list of resolved bets.
        """
        self.table.check_bets(dice_outcome, phase, point)
        return self.table.clear_resolved_bets()

    def reset_table(self):
        """Reset the table and player for a new test."""
        self.table.bets = []  # Clear all bets
        self.player.balance = self.initial_balance  # Reset player balance

# File: .\craps\dice.py

import csv
import random

class Dice:
    def __init__(self, roll_history_file=None):
        """
        Initialize the Dice class.
        
        :param roll_history_file: Path to a CSV file containing roll history. If None, rolls are random.
        """
        self.values = [1, 1]
        self.roll_history_file = roll_history_file
        self.roll_history = []
        self.current_roll_index = 0

        if self.roll_history_file:
            self._load_roll_history()

    def _load_roll_history(self):
        """Load roll history from a CSV file."""
        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to integers
                dice = [int(die) for die in row["dice"].strip('[]').split(', ')]
                total = int(row["total"])
                shooter_num = int(row["shooter_num"])
                self.roll_history.append({
                    "dice": dice,
                    "total": total,
                    "shooter_num": shooter_num
                })

    def roll(self):
        """Roll the dice. If roll history is loaded, use the next roll from the history."""
        if self.roll_history:
            if self.current_roll_index >= len(self.roll_history):
                raise IndexError("No more rolls in the history.")
            roll = self.roll_history[self.current_roll_index]
            self.values = roll["dice"]
            self.current_roll_index += 1
            return roll["dice"]
        else:
            # Generate random rolls if no history is loaded
            self.values = [random.randint(1, 6), random.randint(1, 6)]
            return self.values

# File: .\craps\game_state.py

from typing import List
from craps.puck import Puck
from colorama import Fore, Style

class GameState:
    def __init__(self, stats, play_by_play=None):
        """
        Initialize the game state.

        :param stats: The Statistics object for recording game data.
        :param play_by_play: The PlayByPlay instance for writing play-by-play messages.
        """
        self.phase = "come-out"  # Current game phase ("come-out" or "point")
        self.point = None  # Current point number (if in point phase)
        self.puck = Puck()  # Puck to indicate the point
        self.stats = stats  # Statistics object (required)
        self.play_by_play = play_by_play  # Store the PlayByPlay instance

    def set_table(self, table):
        """
        Set the table object.

        :param table: The table object.
        """
        self.table = table

    def update_state(self, dice_outcome: List[int]) -> str:
        """
        Update the game state based on the dice outcome.

        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :return: A message describing the state change.
        """
        total = sum(dice_outcome)
        message = "No change in game state."  # Default message

        if self.phase == "come-out":
            if total in [7, 11]:
                self.puck.reset()
                message = f"{Fore.GREEN}✅ 7-Winner: Pass Line bets win!{Fore.YELLOW} Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
            elif total in [2, 3, 12]:
                self.puck.reset()
                message = f"{Fore.RED}❌ Craps: Pass Line bets lose!{Fore.YELLOW} Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
            else:
                self.phase = "point"
                self.puck.set_point(total)
                self.point = total
                message = f"{Fore.YELLOW}Point Set: {total}. Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
                
                # Notify the table to reactivate inactive bets
                if self.table:
                    self.table.reactivate_inactive_bets()
        else:  # Point phase
            if total == self.puck.point:
                self.stats.record_point_number_roll()  # Record point number roll
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"{Fore.GREEN}✅ Point Hit: {total}. Pass Line bets win!{Fore.YELLOW} Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
            elif total == 7:
                self.stats.record_seven_out()  # Record 7-out
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"❌ 7-Out: Pass Line bets lose! Puck is {self.puck.position.upper()}."

        # Write the message to the play-by-play file
        if self.play_by_play:
            self.play_by_play.write(message)

        return message

# File: .\craps\house_rules.py

# File: .\craps\house_rules.py

class HouseRules:
    """Class representing house rules for payouts and table limits."""
    def __init__(self, config):
        """
        Initialize the HouseRules with configuration from config.py.

        :param config: A dictionary containing house rules configuration.
        """
        self.field_bet_payout_2 = config.get("field_bet_payout_2", (2, 1))  # Default to 2:1 for 2
        self.field_bet_payout_12 = config.get("field_bet_payout_12", (3, 1))  # Default to 3:1 for 12
        self.table_minimum = config.get("table_minimum", 10)  # Default to $10
        self.table_maximum = config.get("table_maximum", 5000)  # Default to $5000

    def set_field_bet_payouts(self, payout_2, payout_12):
        """Set the payout ratios for the Field Bet."""
        self.field_bet_payout_2 = payout_2
        self.field_bet_payout_12 = payout_12

    def set_table_limits(self, minimum, maximum):
        """Set the table limits."""
        self.table_minimum = minimum
        self.table_maximum = maximum

# File: .\craps\lineup.py

# File: .\craps\lineup.py

from .strategies.pass_line_strategy import PassLineStrategy
from .strategies.pass_line_odds_strategy import PassLineOddsStrategy
from .strategies.place_strategy import PlaceBetStrategy
from .strategies.field_strategy import FieldBetStrategy
from .strategies.iron_cross_strategy import IronCrossStrategy
from .strategies.three_point_molly_strategy import ThreePointMollyStrategy

class PlayerLineup:
    """Class to manage the lineup of players and their strategies."""
    def __init__(self, house_rules, table):
        """
        Initialize the player lineup.

        :param house_rules: The HouseRules object for table limits and payouts.
        :param table: The Table object for placing bets.
        """
        self.house_rules = house_rules
        self.table = table

        # Define all possible strategies and their names
        self.all_strategies = {
            "Pass-Line": PassLineStrategy(min_bet=self.house_rules.table_minimum),
            "Pass-Line w/ Odds": PassLineOddsStrategy(table=self.table, odds_multiple=1),
            "$44 Inside": PlaceBetStrategy(table=self.table, numbers_or_strategy="inside"),
            "$54 Across": PlaceBetStrategy(table=self.table, numbers_or_strategy="across"),
            "Field": FieldBetStrategy(min_bet=self.house_rules.table_minimum),
            "Iron Cross": IronCrossStrategy(table=self.table, min_bet=self.house_rules.table_minimum),
            "3-Point Molly": ThreePointMollyStrategy(min_bet=self.house_rules.table_minimum, odds_multiple=1)
        }
    def get_active_players(self, active_players_config):
        """
        Get the list of active strategies and player names based on the configuration.
        
        :param active_players_config: A dictionary specifying which players are active.
        :return: A tuple of (strategies, player_names).
        """
        strategies = [strategy for name, strategy in self.all_strategies.items() if active_players_config.get(name, False)]
        player_names = [name for name, active in active_players_config.items() if active]
        return strategies, player_names

# File: .\craps\log_manager.py

# File: .\craps\log_manager.py

import os
import logging

class LogManager:
    def __init__(self, output_folder="output", log_file='general.log'):
        self.output_folder = output_folder
        self.log_file = os.path.join(output_folder, log_file)
        self.ensure_output_folder_exists()
        self.configure_logging()

    def ensure_output_folder_exists(self):
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def configure_logging(self):
        """Configure logging to write to the log file."""
        logging.basicConfig(
            filename=self.log_file,
            level=logging.INFO,
            format='%(message)s',
            encoding='utf-8'
        )

    def delete_log_file(self):
        """Delete the log file if it exists."""
        if os.path.exists(self.log_file):
            # Close all logging handlers to release the file
            for handler in logging.root.handlers[:]:
                handler.close()
                logging.root.removeHandler(handler)
            os.remove(self.log_file)
            print(f"Deleted existing log file: {self.log_file}")
            # Reconfigure logging after deleting the file
            self.configure_logging()

# File: .\craps\player.py

# File: .\craps\player.py

from colorama import Fore, Style
from typing import List, Union, Optional
from craps.bet import Bet
from craps.table import Table
from craps.rules_engine import RulesEngine  # Import RulesEngine

class Player:
    def __init__(self, name: str, initial_balance: int = 500, betting_strategy=None, play_by_play=None):
        """
        Initialize a player.

        :param name: The name of the player.
        :param initial_balance: The initial bankroll of the player.
        :param betting_strategy: The betting strategy used by the player.
        :param play_by_play: The PlayByPlay instance for writing play-by-play messages.
        """
        self.name = name
        self.balance = initial_balance
        self.betting_strategy = betting_strategy
        self.play_by_play = play_by_play
        self.rules_engine = RulesEngine()  # Initialize RulesEngine

    def place_bet(self, bet: Union[Bet, List[Bet]], table: Table, phase: str) -> bool:
        """
        Place a bet (or multiple bets) on the table and deduct the amount from the player's balance.

        :param bet: The bet(s) to place.
        :param table: The table to place the bet on.
        :param phase: The current game phase ("come-out" or "point").
        :return: True if the bet(s) were placed successfully, False otherwise.
        """
        # Convert single bet to a list for uniform handling
        bets = [bet] if not isinstance(bet, list) else bet
        
        # Check if any of the bets are odds bets and validate their parent bets
        for b in bets:
            if hasattr(b, 'parent_bet') and b.parent_bet is not None:  # Check if the bet is an odds bet and has a parent
                if b.parent_bet.owner != self:
                    raise ValueError("Cannot place odds bet on another player's bet")
                if not table.has_bet(b.parent_bet):
                    raise ValueError("Parent bet must be on the table before placing odds")

        # Calculate the total amount to be wagered
        total_amount = sum(b.amount for b in bets)

        # Check if the player has sufficient funds
        if total_amount > self.balance:
            message = f"{Fore.RED}❌ {self.name} has insufficient funds to place ${total_amount} in bets.{Style.RESET_ALL}"
            self.play_by_play.write(message)  # Write the message to the play-by-play file
            return False

        # Place each bet on the table
        for b in bets:
            if not table.place_bet(b, phase):  # Use the updated place_bet method
                message = f"{Fore.RED}❌ Failed to place {b.bet_type} bet for {self.name}.{Style.RESET_ALL}"
                self.play_by_play.write(message)  # Write the message to the play-by-play file
                return False

            # Deduct the amount from the player's balance
            self.balance -= b.amount
            message = f"{Fore.GREEN}✅ {self.name} placed a ${b.amount} {b.bet_type} bet. Bankroll: ${self.balance}.{Style.RESET_ALL}"
            self.play_by_play.write(message)  # Write the message to the play-by-play file

        return True

    def receive_payout(self, payout: int) -> None:
        """
        Add the payout amount to the player's bankroll.

        :param payout: The payout amount.
        """
        self.balance += payout
        message = f"{Fore.GREEN}✅ {self.name} received a payout of ${payout}. Bankroll: ${self.balance}.{Style.RESET_ALL}"
        self.play_by_play.write(message)  # Write the message to the play-by-play file

    def has_active_bet(self, table: Table, bet_type: str, number: Optional[int] = None) -> bool:
        """
        Check if the player has an active bet of a specific type and number on the table.

        :param table: The table to check for active bets.
        :param bet_type: The type of bet to check for (e.g., "Pass Line", "Place").
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :return: True if the player has an active bet of the specified type and number, False otherwise.
        """
        return any(
            bet.owner == self and bet.bet_type == bet_type and (number is None or bet.number == number)
            for bet in table.bets
        )

# File: .\craps\player_setup.py

# File: .\craps\player_setup.py

from craps.lineup import PlayerLineup

class SetupPlayers:
    def __init__(self, house_rules, table, active_players_config):
        self.house_rules = house_rules
        self.table = table
        self.active_players_config = active_players_config

    def setup(self):
        """Set up the players and their strategies."""
        player_lineup = PlayerLineup(self.house_rules, self.table)
        strategies, player_names = player_lineup.get_active_players(self.active_players_config)
        return strategies, player_names

# File: .\craps\play_by_play.py

import os
import logging

class PlayByPlay:
    def __init__(self, output_folder="output", play_by_play_file="play_by_play.txt"):
        """
        Initialize the PlayByPlay writer.

        :param output_folder: The folder where the play-by-play file will be saved.
        :param play_by_play_file: The name of the play-by-play file.
        """
        self.output_folder = output_folder
        self.play_by_play_file = os.path.join(output_folder, play_by_play_file)
        self.ensure_output_folder_exists()

    def ensure_output_folder_exists(self):
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def write(self, message: str):
        """
        Write a pre-formatted message (with embedded Colorama colors) to the play-by-play file.

        :param message: The message to write.
        """
        with open(self.play_by_play_file, "a", encoding="utf-8") as file:
            file.write(message + "\n")

    def clear_play_by_play_file(self):
        """Clear the play-by-play file if it exists."""
        if os.path.exists(self.play_by_play_file):
            # Ensure the file is closed before attempting to delete it
            for handler in logging.root.handlers[:]:
                handler.close()
                logging.root.removeHandler(handler)
            os.remove(self.play_by_play_file)
            print(f"Deleted existing play-by-play file: {self.play_by_play_file}")

# File: .\craps\puck.py

class Puck:
    def __init__(self):
        self.position = "Off"
        self.point = None

    def set_point(self, value):
        self.position = "On"
        self.point = value

    def reset(self):
        self.position = "Off"
        self.point = None

# File: .\craps\roll_history_manager.py

# File: .\craps\roll_history_manager.py

import os
import csv

class RollHistoryManager:
    def __init__(self, output_folder="output", roll_history_file="single_session_roll_history.csv"):
        self.output_folder = output_folder
        self.roll_history_file = os.path.join(output_folder, roll_history_file)

    def ensure_output_folder_exists(self):
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def delete_roll_history_file(self):
        """Delete the roll history file if it exists."""
        if os.path.exists(self.roll_history_file):
            os.remove(self.roll_history_file)
            print(f"Deleted existing roll history file: {self.roll_history_file}")

    def save_roll_history(self, roll_history):
        """
        Save the roll history to a CSV file.
        
        :param roll_history: A list of dictionaries representing the roll history.
        """
        self.ensure_output_folder_exists()
        with open(self.roll_history_file, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ["shooter_num", "roll_number", "dice", "total", "phase", "point"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            # Write the header
            writer.writeheader()

            # Write the roll history
            for roll in roll_history:
                writer.writerow(roll)

        print(f"Roll history saved to: {self.roll_history_file}")

    def load_roll_history(self):
        """
        Load the roll history from a CSV file.
        
        :return: A list of dictionaries representing the roll history.
        """
        if not os.path.exists(self.roll_history_file):
            raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found.")

        roll_history = []
        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to integers
                row["roll_number"] = int(row["roll_number"])
                row["shooter_num"] = int(row["shooter_num"])
                row["dice"] = [int(die) for die in row["dice"].strip('[]').split(', ')]
                row["total"] = int(row["total"])
                roll_history.append(row)

        print(f"Roll history loaded from: {self.roll_history_file}")
        return roll_history

    def prepare_for_session(self, session_mode):
        """
        Prepare for the session based on the session mode.
        
        :param session_mode: The session mode ("live" or "history").
        :raises FileNotFoundError: If the roll history file is missing in history mode.
        """
        self.validate_session_mode(session_mode)
        self.ensure_output_folder_exists()

        if session_mode == "live":
            self.delete_roll_history_file()
            print("Running session in 'live' mode with random rolls.")
        elif session_mode == "history":
            if not os.path.exists(self.roll_history_file):
                raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found. Please run in 'live' mode first.")
            print(f"Running session in 'history' mode using roll history from: {self.roll_history_file}")

    def validate_session_mode(self, session_mode):
        """
        Validate the session mode.
        
        :param session_mode: The session mode ("live" or "history").
        :raises ValueError: If the session mode is invalid.
        """
        if session_mode not in ["live", "history"]:
            raise ValueError(f"Invalid SESSION_MODE '{session_mode}'. Must be 'live' or 'history'.")

    def get_roll_history_file(self, session_mode):
        """
        Get the roll history file based on the session mode.
        
        :param session_mode: The session mode ("live" or "history").
        :return: The roll history file path if in "history" mode, otherwise None.
        """
        return self.roll_history_file if session_mode == "history" else None

# File: .\craps\rules.py

# File: .\craps\rules.py

# ==================================================
# Table 1: Bet Behavior
# ==================================================

BET_BEHAVIOR = {
    # Pass Line and Pass Line Odds (already defined)
    "Pass Line": {
        "come-out": {
            "can_bet": True,
            "can_remove": False,
            "can_turn_on": "Always On",
            "winning": [7, 11],
            "losing": [2, 3, 12],
            "other_action": "Sets the Point",
            "linked_bet": "Pass Line Odds",
        },
        "point": {
            "can_bet": False,
            "can_remove": False,
            "can_turn_on": "Always On",
            "winning": ["Point"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": "Pass Line Odds",
        },
    },
    "Pass Line Odds": {
        "come-out": {
            "can_bet": False,
            "can_remove": "Must Remove",
            "can_turn_on": "Must Remove",
            "winning": None,
            "losing": None,
            "other_action": None,
            "linked_bet": None,
        },
        "point": {
            "can_bet": True,
            "can_remove": True,
            "can_turn_on": "Always On",
            "winning": ["Point"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": None,
        },
    },
    # Place Bet
    "Place": {
        "come-out": {
            "can_bet": False,
            "can_remove": True,
            "can_turn_on": True,
            "winning": ["Number"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": "Place Odds",
        },
        "point": {
            "can_bet": True,
            "can_remove": True,
            "can_turn_on": "Always On",
            "winning": ["Number"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": "Place Odds",
        },
    },
    # Place Odds
    "Place Odds": {
        "come-out": {
            "can_bet": False,
            "can_remove": True,
            "can_turn_on": True,
            "winning": ["Number"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": None,
        },
        "point": {
            "can_bet": True,  # Allow Place Odds bets during the point phase
            "can_remove": True,
            "can_turn_on": "Always On",
            "winning": ["Number"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": None,
        },
    },
    # Come Bet
    "Come": {
        "come-out": {
            "can_bet": False,  # Come bets cannot be placed during the come-out phase
            "can_remove": False,
            "can_turn_on": "Always On",
            "winning": [7, 11],
            "losing": [2, 3, 12],
            "other_action": "Moves to Number",
            "linked_bet": "Come Odds",
        },
        "point": {
            "can_bet": True,  # Come bets can be placed during the point phase
            "can_remove": False,
            "can_turn_on": "Always On",
            "winning": ["Number"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": "Come Odds",
        },
    },
    # Come Odds Bet
    "Come Odds": {
        "come-out": {
            "can_bet": False,  # Come Odds bets cannot be placed during the come-out phase
            "can_remove": False,
            "can_turn_on": "Always On",
            "winning": None,
            "losing": None,
            "other_action": None,
            "linked_bet": None,
        },
        "point": {
            "can_bet": True,  # Come Odds bets can be placed during the point phase
            "can_remove": True,
            "can_turn_on": "Always On",
            "winning": ["Number"],
            "losing": [7],
            "other_action": "No Change",
            "linked_bet": None,
        },
    },
    # Field Bet
    "Field": {
        "come-out": {
            "can_bet": True,
            "can_remove": True,
            "can_turn_on": "Always On",
            "winning": [2, 3, 4, 9, 10, 11, 12],  # Winning numbers for Field bet
            "losing": [5, 6, 7, 8],  # Losing numbers for Field bet
            "other_action": "No Change",
            "linked_bet": None,
        },
        "point": {
            "can_bet": True,
            "can_remove": True,
            "can_turn_on": "Always On",
            "winning": [2, 3, 4, 9, 10, 11, 12],  # Winning numbers for Field bet
            "losing": [5, 6, 7, 8],  # Losing numbers for Field bet
            "other_action": "No Change",
            "linked_bet": None,
        },
    },
}

# ==================================================
# Table 2: Bet Payout
# ==================================================

BET_PAYOUT = {
    "Pass Line": {"payout_ratio": (1, 1), "vig": False},
    "Pass Line Odds": {"payout_ratio": "True Odds", "vig": False},
    "Place": {"payout_ratio": "House Odds", "vig": False},
    "Place Odds": {"payout_ratio": "True Odds", "vig": False},
    "Come": {"payout_ratio": (1, 1), "vig": False},
    "Come Odds": {"payout_ratio": "True Odds", "vig": False},
    "Field": {"payout_ratio": "Field Odds", "vig": False},  # Add Field bet payout
}

# ==================================================
# Table 3: Odds Payout
# ==================================================

ODDS_PAYOUT = {
    "True Odds": {
        4: (2, 1),
        5: (3, 2),
        6: (6, 5),
        8: (6, 5),
        9: (3, 2),
        10: (2, 1),
    },
    "House Odds": {
        4: (9, 5),
        5: (7, 5),
        6: (7, 6),
        8: (7, 6),
        9: (7, 5),
        10: (9, 5),
    },
    "Field Odds": {
        2: (2, 1),  # 2:1 payout for 2
        12: (3, 1),  # 3:1 payout for 12
        # Other winning numbers (3, 4, 9, 10, 11) default to 1:1
    }
}

# File: .\craps\rules_engine.py

# File: .\craps\rules_engine.py

from typing import List, Optional, Dict, Any, Tuple
from craps.rules import BET_BEHAVIOR, BET_PAYOUT, ODDS_PAYOUT
from craps.bet import Bet  # Import the Bet class

class RulesEngine:
    """A rules engine for handling bets based on the rules defined in rules.py."""

    @staticmethod
    def get_minimum_bet(number: Optional[int] = None) -> int:
        """
        Get the minimum bet amount for a specific bet type or number.

        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :return: The minimum bet amount.
        """
        # Default minimum bet for most bets
        default_min_bet = 10  # Replace with the actual default minimum bet from house rules

        # Adjust minimum bet for specific bet types or numbers
        if number is not None:
            # For Place bets, the minimum bet may vary based on the number
            if number in [4, 5, 6, 8, 9, 10]:
                return default_min_bet  # Replace with actual logic if needed
            else:
                raise ValueError(f"Invalid number for minimum bet: {number}")

        return default_min_bet

    @staticmethod
    def create_bet(bet_type: str, amount: int, owner, number: Optional[int] = None, parent_bet: Optional[Bet] = None) -> Bet:
        """
        Create a bet based on the bet type.

        :param bet_type: The type of bet (e.g., "Pass Line", "Place").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :param parent_bet: The parent bet for odds bets.
        :return: A Bet instance.
        """
        # Get the payout ratio and other properties from the RulesEngine
        payout_ratio = RulesEngine.get_payout_ratio(bet_type, number)
        vig = RulesEngine.has_vig(bet_type)
        valid_phases = ["come-out", "point"]  # Default valid phases

        # Create the bet
        bet = Bet(
            bet_type=bet_type,
            amount=amount,
            owner=owner,
            payout_ratio=payout_ratio,
            vig=vig,
            valid_phases=valid_phases,
            number=number,
            parent_bet=parent_bet
        )

        return bet

    # ... (rest of the RulesEngine class remains unchanged)

    @staticmethod
    def can_make_bet(bet_type: str, phase: str, parent_bet: Optional[Bet] = None) -> bool:
        """
        Determine if a bet of the given type can be made during the current phase.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Pass Line Odds", "Place").
        :param phase: The current game phase ("come-out" or "point").
        :param parent_bet: The parent bet for odds bets.
        :return: True if the bet can be made, False otherwise.
        """
        if bet_type not in BET_BEHAVIOR:
            raise ValueError(f"Unknown bet type: {bet_type}")
            
        # Additional checks for odds bets
        if bet_type.endswith("Odds"):
            if parent_bet is None:
                return False  # Parent bet is required for odds bets
            if bet_type == "Come Odds" and parent_bet.number is None:
                return False  # Come bet must have a number set
                
        return BET_BEHAVIOR[bet_type][phase]["can_bet"]

    @staticmethod
    def get_linked_bet_type(bet_type: str) -> Optional[str]:
        """
        Get the type of bet that can be linked to the given bet type.
        Now returns the child bet type instead of parent.
        """
        linked_bets = {
            "Pass Line": "Pass Line Odds",
            "Place": "Place Odds",
            "Come": "Come Odds",
        }
        return linked_bets.get(bet_type)

    @staticmethod
    def can_remove_bet(bet_type: str, phase: str) -> bool:
        """
        Determine if a bet of the given type can be removed during the current phase.

        :param bet_type: The type of bet (e.g., "Pass Line", "Pass Line Odds", "Place").
        :param phase: The current game phase ("come-out" or "point").
        :return: True if the bet can be removed, False otherwise.
        """
        if bet_type not in BET_BEHAVIOR:
            raise ValueError(f"Unknown bet type: {bet_type}")
        
        return BET_BEHAVIOR[bet_type][phase]["can_remove"]

    @staticmethod
    def can_turn_on(bet_type: str, phase: str) -> bool:
        """
        Determine if a bet of the given type can be turned on during the current phase.

        :param bet_type: The type of bet (e.g., "Pass Line", "Pass Line Odds", "Place").
        :param phase: The current game phase ("come-out" or "point").
        :return: True if the bet can be turned on, False otherwise.
        """
        if bet_type not in BET_BEHAVIOR:
            raise ValueError(f"Unknown bet type: {bet_type}")
        
        return BET_BEHAVIOR[bet_type][phase]["can_turn_on"]

    @staticmethod
    def resolve_bet(bet: Bet, dice_outcome: List[int], phase: str, point: Optional[int]) -> Optional[int]:
        """
        Resolve a bet based on the dice outcome, phase, and point.

        :param bet: The bet to resolve.
        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        :return: The new point number if the bet sets the point, otherwise None.
        """
        if bet.bet_type not in BET_BEHAVIOR:
            raise ValueError(f"Unknown bet type: {bet.bet_type}")

        total = sum(dice_outcome)
        behavior = BET_BEHAVIOR[bet.bet_type][phase]

        # Handle Field bet payouts dynamically
        if bet.bet_type == "Field":
            if total in ODDS_PAYOUT["Field Odds"]:
                bet.payout_ratio = ODDS_PAYOUT["Field Odds"][total]  # Set payout ratio for 2 or 12
            else:
                bet.payout_ratio = (1, 1)  # Default payout ratio for other winning numbers

        # Check if the bet wins
        if behavior["winning"] is not None:
            if isinstance(behavior["winning"], list) and "Number" in behavior["winning"]:
                # For Place bets, check if the total matches the bet's number
                if total == bet.number:
                    bet.status = "won"
                    return None
            elif total in behavior["winning"] or (isinstance(behavior["winning"], list) and "Point" in behavior["winning"] and total == point):
                bet.status = "won"
                return None

        # Check if the bet loses
        if behavior["losing"] is not None:
            if total in behavior["losing"]:
                bet.status = "lost"
                return None

        # Handle other actions (e.g., setting the point or moving a Come bet)
        if behavior["other_action"] is not None:
            if behavior["other_action"] == "Sets the Point":
                # Set the point for Pass Line bets
                bet.status = "active"  # Ensure the bet remains active
                return total
            elif behavior["other_action"] == "Moves to Number":
                # Move Come bets to the number rolled
                bet.number = total
                bet.valid_phases = ["point"]  # Now only valid during the point phase

        # If neither, the bet remains active
        bet.status = "active"
        return None

    @staticmethod
    def get_payout_ratio(bet_type: str, number: Optional[int] = None) -> Tuple[int, int]:
        """
        Get the payout ratio for a bet based on its type and number.

        :param bet_type: The type of bet (e.g., "Pass Line", "Pass Line Odds", "Place").
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :return: A tuple representing the payout ratio (numerator, denominator).
        """
        if bet_type not in BET_PAYOUT:
            raise ValueError(f"Unknown bet type: {bet_type}")

        payout_info = BET_PAYOUT[bet_type]
        if payout_info["payout_ratio"] == "True Odds":
            if number is None:
                raise ValueError(f"Number must be provided for True Odds bets.")
            return ODDS_PAYOUT["True Odds"][number]
        elif payout_info["payout_ratio"] == "House Odds":
            if number is None:
                raise ValueError(f"Number must be provided for House Odds bets.")
            return ODDS_PAYOUT["House Odds"][number]
        elif payout_info["payout_ratio"] == "Field Odds":
            if number is None:
                return (1, 1)  # Default payout for Field bet
            return ODDS_PAYOUT["Field Odds"].get(number, (1, 1))  # Use special payouts for 2 and 12
        else:
            return payout_info["payout_ratio"]

    @staticmethod
    def has_vig(bet_type: str) -> bool:
        """
        Determine if a bet of the given type has a vig (commission).

        :param bet_type: The type of bet (e.g., "Pass Line", "Pass Line Odds", "Place").
        :return: True if the bet has a vig, False otherwise.
        """
        if bet_type not in BET_PAYOUT:
            raise ValueError(f"Unknown bet type: {bet_type}")

        return BET_PAYOUT[bet_type]["vig"]

    @staticmethod
    def get_linked_bet_type(bet_type: str) -> Optional[str]:
        """
        Get the type of bet linked to the given bet type (e.g., Pass Line Odds is linked to Pass Line).

        :param bet_type: The type of bet (e.g., "Pass Line", "Pass Line Odds", "Place").
        :return: The linked bet type, or None if no linked bet exists.
        """
        linked_bets = {
            "Pass Line": "Pass Line Odds",
            "Come": "Come Odds",
            "Place": "Place Odds",
        }
        return linked_bets.get(bet_type)

# File: .\craps\session_initializer.py

# File: .\craps\session_initializer.py

from craps.house_rules import HouseRules
from craps.table import Table
from craps.roll_history_manager import RollHistoryManager
from craps.log_manager import LogManager
from craps.play_by_play import PlayByPlay
from craps.rules_engine import RulesEngine

class InitializeSession:
    def __init__(self, session_mode, house_rules_config):
        """
        Initialize the session.

        :param session_mode: The session mode ("live" or "history").
        :param house_rules_config: The house rules configuration.
        """
        self.session_mode = session_mode
        self.house_rules_config = house_rules_config
        self.roll_history_manager = RollHistoryManager()
        self.log_manager = LogManager()
        self.play_by_play = PlayByPlay()
        self.rules_engine = RulesEngine()

    def prepare_session(self):
        """Prepare the session based on the session mode."""
        try:
            self.roll_history_manager.prepare_for_session(self.session_mode)
        except (ValueError, FileNotFoundError) as e:
            print(f"Error: {e}")
            return None

        # Initialize house rules
        house_rules = HouseRules(self.house_rules_config)

        # Create the Table object with the RulesEngine
        table = Table(house_rules, self.play_by_play, self.rules_engine)

        # Delete the existing log file before starting the session
        self.log_manager.delete_log_file()

        # Clear the play-by-play file before starting the session
        self.play_by_play.clear_play_by_play_file()

        return house_rules, table, self.roll_history_manager, self.log_manager, self.play_by_play

# File: .\craps\shooter.py

from craps.player import Player
from craps.dice import Dice

class Shooter(Player):
    def __init__(self, name, initial_balance=0, betting_strategy=None, dice=None, play_by_play=None):
        super().__init__(
            name,
            initial_balance=initial_balance,
            betting_strategy=betting_strategy,
            play_by_play=play_by_play
        )
        self.dice = dice if dice else Dice()
        self.points_rolled = 0  # Number of times the shooter rolled the point
        self.rolls_before_7_out = 0  # Number of rolls before 7-ing out
        self.current_roll_count = 0  # Tracks rolls in the current turn

    def roll_dice(self):
        """Roll the dice and update shooter statistics."""
        outcome = self.dice.roll()
        self.current_roll_count += 1
        return outcome

    def reset_stats(self):
        """Reset shooter statistics for a new turn."""
        self.points_rolled = 0
        self.rolls_before_7_out = 0
        self.current_roll_count = 0

# File: .\craps\simulation_manager.py

# File: craps/simulation_manager.py
from craps.single_session import run_single_session

class SimulationManager:
    def __init__(self, house_rules, num_tables, num_shooters, strategies):
        """
        Initialize the SimulationManager.
        
        :param house_rules: The HouseRules object for payout rules and limits.
        :param num_tables: The number of tables to simulate.
        :param num_shooters: The number of shooters per session.
        :param strategies: A list of betting strategies to evaluate.
        """
        self.house_rules = house_rules
        self.num_tables = num_tables
        self.num_shooters = num_shooters
        self.strategies = strategies
        self.stats = Statistics(house_rules.table_minimum, num_shooters, len(strategies))

    def run_simulation(self, num_sessions):
        """Run multiple sessions and collect statistics."""
        for _ in range(num_sessions):
            for _ in range(self.num_tables):
                stats = run_single_session(self.house_rules, self.strategies, num_shooters=self.num_shooters)
                self.stats.merge(stats)  # Merge session stats into overall stats

        self.stats.print_statistics()
        self.stats.print_shooter_report()

# File: .\craps\single_session.py

# File: .\craps\single_session.py

from colorama import init, Fore, Style
from craps.table import Table
from craps.game_state import GameState
from craps.shooter import Shooter
from craps.dice import Dice
from craps.statistics import Statistics
from craps.rules_engine import RulesEngine
import os

def run_single_session(house_rules, strategies, player_names=None, initial_bankroll=500, num_shooters=10, roll_history_file=None, play_by_play=None):
    """
    Run a single session of craps and log the roll history.
    """
    init()  # Initialize colorama

    # Set dice mode
    if roll_history_file and os.path.exists(roll_history_file):
        dice = Dice(roll_history_file)
    else:
        dice = Dice()  # Use random rolls

    # Initialize components
    rules_engine = RulesEngine()
    table = Table(house_rules, play_by_play, rules_engine)
    stats = Statistics(house_rules.table_minimum, num_shooters, len(strategies))
    game_state = GameState(stats, play_by_play=play_by_play)
    game_state.set_table(table)

    # Create players with different betting strategies
    if player_names is None:
        player_names = [f"Player {i+1}" for i in range(len(strategies))]

    players = [
        Shooter(player_names[i], initial_balance=initial_bankroll, betting_strategy=strategy, dice=dice, play_by_play=play_by_play)
        for i, strategy in enumerate(strategies)
    ]

    # Initialize bankroll history with the starting bankroll for each player
    stats.initialize_bankroll_history(players)

    # Initialize roll history
    roll_history = []

    # Simulate shooters
    for shooter_num in range(1, num_shooters + 1):
        player_index = (shooter_num - 1) % len(players)
        shooter = players[player_index]
        stats.set_shooter(shooter, shooter_num)

        while True:
            # Allow all players to place bets
            for player in players:
                bet = player.betting_strategy.get_bet(game_state, player, table)
                if bet:
                    player.place_bet(bet, table, game_state.phase)  # Pass the current phase

            # Roll the dice and resolve bets
            outcome = shooter.roll_dice()
            total = sum(outcome)
            stats.update_rolls()
            stats.update_shooter_stats(shooter)

            # Log the dice roll and total
            message = f"{Fore.LIGHTMAGENTA_EX}{shooter.name} rolled: {outcome} (Total: {total}) | Roll Count: {stats.num_rolls}{Style.RESET_ALL}"
            play_by_play.write(message)  # Write the message to the play-by-play file

            # Log the roll to the history
            roll_history.append({
                "shooter_num": shooter_num,
                "roll_number": stats.num_rolls,
                "dice": outcome,
                "total": total,
                "phase": game_state.phase,
                "point": game_state.point
            })

            # Check bets on the table
            table.check_bets(outcome, game_state.phase, game_state.point)

            # Clear resolved bets and update player bankrolls
            resolved_bets = table.clear_resolved_bets()
            for bet in resolved_bets:
                if bet.status == "won":
                    payout = bet.payout()
                    bet.owner.receive_payout(payout)
                elif bet.status == "lost":
                    message = f"{Fore.RED}❌ {bet.owner.name}'s {bet.bet_type} bet LOST ${bet.amount}.{Style.RESET_ALL}"
                    play_by_play.write(message)  # Write the message to the play-by-play file
                stats.update_win_loss(bet)

            # Update player bankrolls in statistics
            stats.update_player_bankrolls(players)

            # Update game state
            previous_phase = game_state.phase
            message = game_state.update_state(outcome)
            if message:
                play_by_play.write(message)  # Write the message to the play-by-play file

            # Check if the shooter 7-outs
            if previous_phase == "point" and total == 7:
                stats.record_seven_out()
                break

    # Return stats and roll history
    stats.roll_history = roll_history
    return stats

# File: .\craps\statistics.py

## File: craps/statistics.py

import logging
class Statistics:
    def __init__(self, table_minimum, num_shooters, num_players):
        self.table_minimum = table_minimum
        self.num_shooters = num_shooters
        self.num_players = num_players
        self.num_rolls = 0
        self.total_house_win_loss = 0
        self.total_player_win_loss = 0
        self.player_bankrolls = []
        self.highest_bankroll = 0
        self.lowest_bankroll = float('inf')
        self.shooter_stats = {}
        self.player_stats = {}
        self.shooter = None
        self.shooter_num = None

        # For visualization
        self.roll_numbers = [0]  # Start with roll 0
        self.bankroll_history = {}  # Track bankroll history for each player
        self.seven_out_rolls = []  # Track rolls where a 7-out occurs
        self.point_number_rolls = []  # Track rolls where a point number (4, 5, 6, 8, 9, 10) is rolled
        
    def initialize_player_stats(self, players):
        """Initialize player statistics with their starting bankroll."""
        for player in players:
            self.player_stats[player.name] = {
                "initial_bankroll": player.balance,
                "final_bankroll": player.balance,
                "net_win_loss": 0,
            }
            
    def update_player_stats(self, players):
        """Update player statistics at the end of the session."""
        for player in players:
            if player.name in self.player_stats:
                self.player_stats[player.name]["final_bankroll"] = player.balance
                self.player_stats[player.name]["net_win_loss"] = (
                    player.balance - self.player_stats[player.name]["initial_bankroll"]
                )
                
    def print_player_statistics(self):
        """Print player-specific statistics."""
        logging.info("\n=== Player Performance Report ===")
        for player_name, stats in self.player_stats.items():
            net_win_loss = stats["net_win_loss"]
            result = "Won" if net_win_loss >= 0 else "Lost"
            logging.info(f"\nPlayer: {player_name}")
            logging.info(f"  Initial Bankroll: ${stats['initial_bankroll']}")
            logging.info(f"  Final Bankroll: ${stats['final_bankroll']}")
            logging.info(f"  Net Win/Loss: ${net_win_loss} ({result})")
    
    def set_shooter(self, shooter, shooter_num):
        """Set the current shooter and their turn number."""
        self.shooter = shooter
        self.shooter_num = shooter_num  # Track the shooter's turn number
        if shooter_num not in self.shooter_stats:
            self.shooter_stats[shooter_num] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "total_rolls": 0,
            }
            
    def initialize_bankroll_history(self, players):
        """Initialize bankroll history with the starting bankroll for each player."""
        for player in players:
            self.bankroll_history[player.name] = [player.balance]  # Roll 0: initial bankroll

    def merge(self, other_stats):
        """Merge statistics from another session."""
        self.num_rolls += other_stats.num_rolls
        self.total_house_win_loss += other_stats.total_house_win_loss
        self.total_player_win_loss += other_stats.total_player_win_loss
        self.player_bankrolls.extend(other_stats.player_bankrolls)
        self.highest_bankroll = max(self.highest_bankroll, other_stats.highest_bankroll)
        self.lowest_bankroll = min(self.lowest_bankroll, other_stats.lowest_bankroll)
        self.roll_numbers.extend(other_stats.roll_numbers)
        self.seven_out_rolls.extend(other_stats.seven_out_rolls)
        self.point_number_rolls.extend(other_stats.point_number_rolls)

        # Merge shooter stats
        for shooter_name, stats in other_stats.shooter_stats.items():
            if shooter_name not in self.shooter_stats:
                self.shooter_stats[shooter_name] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "total_rolls": 0,
                }
            self.shooter_stats[shooter_name]["points_rolled"] += stats["points_rolled"]
            self.shooter_stats[shooter_name]["rolls_before_7_out"].extend(stats["rolls_before_7_out"])
            self.shooter_stats[shooter_name]["total_rolls"] += stats["total_rolls"]

        # Merge bankroll history
        for player, bankrolls in other_stats.bankroll_history.items():
            if player not in self.bankroll_history:
                self.bankroll_history[player] = []
            self.bankroll_history[player].extend(bankrolls)

    def update_rolls(self):
        """Increment the roll count."""
        self.num_rolls += 1
        self.roll_numbers.append(self.num_rolls)

    def update_win_loss(self, bet):
        """
        Update the house and player win/loss based on the resolved bet.

        :param bet: The resolved bet.
        """
        if bet.status == "won":
            # Player wins: house loses the payout, player gains the payout
            payout = bet.payout()
            self.total_house_win_loss -= payout
            self.total_player_win_loss += payout
        elif bet.status == "lost":
            # Player loses: house gains the bet amount, player loses the bet amount
            self.total_house_win_loss += bet.amount
            self.total_player_win_loss -= bet.amount
    
    def update_player_bankrolls(self, players):
        """Update player bankrolls and track highest/lowest bankroll."""
        self.player_bankrolls = [player.balance for player in players]
        self.highest_bankroll = max(self.player_bankrolls)
        self.lowest_bankroll = min(self.player_bankrolls)

        # Track bankroll history for visualization
        for player in players:
            if player.name not in self.bankroll_history:
                self.bankroll_history[player.name] = []
            self.bankroll_history[player.name].append(player.balance)

    def record_seven_out(self):
        """Record the roll number where a 7-out occurs."""
        self.seven_out_rolls.append(self.num_rolls)
        if self.shooter:
            self.shooter_stats[self.shooter_num]["rolls_before_7_out"].append(self.shooter.current_roll_count)
            self.shooter.current_roll_count = 0  # Reset the roll count after a 7-out
        
    def record_point_number_roll(self):
        """Record the roll number where a point number (4, 5, 6, 8, 9, 10) is rolled."""
        self.point_number_rolls.append(self.num_rolls)
        if self.shooter:
            self.shooter_stats[self.shooter_num]["points_rolled"] += 1

    def visualize_bankrolls(self):
        """Visualize player bankrolls over time."""
        import matplotlib.pyplot as plt

        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.bankroll_history.items():
            # Ensure bankrolls and roll_numbers have the same length
            if len(bankrolls) != len(self.roll_numbers):
                # Trim the longer list to match the shorter one
                min_length = min(len(bankrolls), len(self.roll_numbers))
                bankrolls = bankrolls[:min_length]
                roll_numbers = self.roll_numbers[:min_length]
            else:
                roll_numbers = self.roll_numbers
            plt.plot(roll_numbers, bankrolls, label=player)

        # Add red vertical lines for 7-out events
        for roll in self.seven_out_rolls:
            plt.axvline(x=roll, color='red', linestyle='--', alpha=0.5, label='7-Out' if roll == self.seven_out_rolls[0] else "")

        # Add green dotted lines for point number rolls
        for roll in self.point_number_rolls:
            plt.axvline(x=roll, color='green', linestyle=':', alpha=0.5, label='Point Number Rolled' if roll == self.point_number_rolls[0] else "")

        # Add labels and title
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)
        plt.show()

    def update_shooter_stats(self, shooter):
        """Update shooter statistics."""
        if self.shooter_num not in self.shooter_stats:
            self.shooter_stats[self.shooter_num] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "total_rolls": 0,
            }
        # Update total rolls for the shooter
        self.shooter_stats[self.shooter_num]["total_rolls"] = shooter.current_roll_count
        self.shooter_stats[self.shooter_num]["rolls_before_7_out"].append(shooter.rolls_before_7_out)

    def print_statistics(self):
        """Print the simulation statistics."""
        logging.info("\n=== Simulation Statistics ===")
        logging.info(f"Table Minimum: ${self.table_minimum}")
        logging.info(f"Number of Shooters: {self.num_shooters}")
        logging.info(f"Number of Players: {self.num_players}")
        logging.info(f"Number of Rolls: {self.num_rolls}")
        logging.info(f"Total House Win/Loss: ${self.total_house_win_loss}")
        logging.info(f"Total Player Win/Loss: ${self.total_player_win_loss}")
        logging.info(f"Player Bankrolls: {self.player_bankrolls}")
        logging.info(f"Highest Player Bankroll: ${self.highest_bankroll}")
        logging.info(f"Lowest Player Bankroll: ${self.lowest_bankroll}")

    def print_shooter_report(self):
        """Print a report summarizing each shooter's performance."""
        logging.info("\n=== Shooter Performance Report ===")
        for shooter_num, stats in self.shooter_stats.items():
            total_points_rolled = stats["points_rolled"]
            total_rolls = stats["total_rolls"]
            rolls_before_7_out = stats["rolls_before_7_out"]
            avg_rolls_before_7_out = sum(rolls_before_7_out) / len(rolls_before_7_out) if rolls_before_7_out else 0

            logging.info(f"\nShooter: {shooter_num}")
            logging.info(f"  Total Points Rolled: {total_points_rolled}")
            logging.info(f"  Total Rolls: {total_rolls}")
            logging.info(f"  Average Rolls Before 7-Out: {avg_rolls_before_7_out:.2f}")
            logging.info(f"  Rolls Before 7-Out: {rolls_before_7_out}")

# File: .\craps\table.py

# File: .\craps\table.py

from typing import List, Optional
from craps.bet import Bet
from craps.play_by_play import PlayByPlay
from craps.house_rules import HouseRules
from craps.rules_engine import RulesEngine

class Table:
    def __init__(self, house_rules, play_by_play, rules_engine):
        """
        Initialize the table.

        :param house_rules: The HouseRules object for payout rules and limits.
        :param play_by_play: The PlayByPlay instance for writing play-by-play messages.
        :param rules_engine: The RulesEngine instance for resolving bets.
        """
        self.house_rules = house_rules
        self.bets = []  # All bets on the table
        self.unit = self.house_rules.table_minimum // 5  # Unit for Place/Buy bets
        self.play_by_play = play_by_play
        self.rules_engine = rules_engine

    def reactivate_inactive_bets(self):
        """
        Reactivate inactive Place bets when the point is set.
        """
        reactivated_bets = []
        for bet in self.bets:
            if bet.bet_type.startswith("Place") and bet.status == "inactive":
                bet.status = "active"
                reactivated_bets.append(f"{bet.owner.name}'s {bet.bet_type}")

        if reactivated_bets:
            message = f"{', '.join(reactivated_bets)} are now ON."
            self.play_by_play.write(message)

    def place_bet(self, bet: Bet, phase: str) -> bool:
        """
        Place a bet on the table after validating it.

        :param bet: The bet to place.
        :param phase: The current game phase ("come-out" or "point").
        :return: True if the bet was placed successfully, False otherwise.
        """
        # Validate the bet before placing it
        if not bet.validate_bet(phase, self.house_rules.table_minimum, self.house_rules.table_maximum):
            message = f"Invalid bet: {bet}"
            self.play_by_play.write(message)
            return False

        # Place the bet on the table
        self.bets.append(bet)
        message = f"Bet placed: {bet}"
        self.play_by_play.write(message)
        return True

    def check_bets(self, dice_outcome: List[int], phase: str, point: Optional[int]) -> None:
        """
        Check and resolve all bets on the table based on the dice outcome, phase, and point.

        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        for bet in self.bets:
            bet.resolve(self.rules_engine, dice_outcome, phase, point)
            message = f"Bet resolved: {bet} (Status: {bet.status})"
            self.play_by_play.write(message)

    def clear_resolved_bets(self) -> List[Bet]:
        """
        Remove all resolved bets (won or lost) from the table and return them.
        """
        resolved_bets = [bet for bet in self.bets if bet.is_resolved()]
        self.bets = [bet for bet in self.bets if not bet.is_resolved()]
        return resolved_bets

# File: .\craps\view_log.py

# File: .\craps\view_log.py

import subprocess
from abc import ABC, abstractmethod
import os
import sys

class LogViewer(ABC):
    """
    Abstract base class for log viewers.
    """

    @abstractmethod
    def view(self, log_file: str):
        """
        View the log file.
        
        :param log_file: Path to the log file.
        """
        pass


class InteractiveLogViewer(LogViewer):
    """
    Concrete class for interactive log viewing.
    """

    def view(self, log_file: str):
        """
        Open the log file interactively.
        
        :param log_file: Path to the log file.
        """
        # Check if the log file exists
        if not os.path.exists(log_file):
            print(f"Log file '{log_file}' not found.")
            return

        # Handle Windows and Unix-like systems differently
        if sys.platform == "win32":
            # Windows: Use Python to print the file contents
            try:
                with open(log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        print(line, end='')
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")
        else:
            # Unix-like systems: Use `less -R`
            try:
                subprocess.run(['less', '-R', log_file])
            except FileNotFoundError:
                print("'less' command not found. Falling back to plain text viewing.")
                self._view_plain_text(log_file)
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")

    def _view_plain_text(self, log_file: str):
        """
        Fallback method to view the log file as plain text.
        
        :param log_file: Path to the log file.
        """
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")


class PlainTextLogViewer(LogViewer):
    """
    Concrete class for plain text log viewing.
    """

    def view(self, log_file: str):
        """
        Print the log file to the console.
        
        :param log_file: Path to the log file.
        """

        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")

# File: .\craps\visualizer.py

# File: .\craps\visualizer.py

import matplotlib.pyplot as plt

class Visualizer:
    def __init__(self, stats):
        self.stats = stats

    def visualize_bankrolls(self):
        """Visualize player bankrolls over time."""
        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.stats.bankroll_history.items():
            # Ensure bankrolls and roll_numbers have the same length
            if len(bankrolls) != len(self.stats.roll_numbers):
                # Trim the longer list to match the shorter one
                min_length = min(len(bankrolls), len(self.stats.roll_numbers))
                bankrolls = bankrolls[:min_length]
                roll_numbers = self.stats.roll_numbers[:min_length]
            else:
                roll_numbers = self.stats.roll_numbers
            plt.plot(roll_numbers, bankrolls, label=player)

        # Add red vertical lines for 7-out events
        for roll in self.stats.seven_out_rolls:
            plt.axvline(x=roll, color='red', linestyle='--', alpha=0.5, label='7-Out' if roll == self.stats.seven_out_rolls[0] else "")

        # Add green dashed lines for point number rolls
        for roll in self.stats.point_number_rolls:
            plt.axvline(x=roll, color='green', linestyle=':', alpha=0.5, label='Point Number Rolled' if roll == self.stats.point_number_rolls[0] else "")

        # Set x-axis limits to start at 0 and end at the last roll
        last_roll = self.stats.roll_numbers[-1]
        plt.xlim(left=0, right=last_roll)

        # Customize x-axis ticks to include the last roll number
        x_ticks = list(range(0, last_roll + 1, 10))  # Major ticks every 10 rolls

        # Remove the next-to-last tick if it is within 3 of the last roll and the last roll is not a multiple of 10
        if len(x_ticks) >= 2:
            next_to_last_tick = x_ticks[-2]
            if (last_roll - next_to_last_tick) <= 3 and (last_roll % 10 != 0):
                x_ticks.pop(-2)  # Remove the next-to-last tick

        # Add the last roll number if it's not already included
        if last_roll not in x_ticks:
            x_ticks.append(last_roll)

        plt.xticks(x_ticks)

        # Add labels and title
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)
        plt.show()

# File: .\craps\__init__.py



# File: .\craps\strategies\field_strategy.py

# File: .\craps\strategies\field_strategy.py

from craps.rules_engine import RulesEngine  # Import RulesEngine

class FieldBetStrategy:
    """Betting strategy for Field bets."""
    def __init__(self, min_bet):
        """
        Initialize the Field Bet strategy.
        
        :param min_bet: The minimum bet amount for the table.
        """
        self.min_bet = min_bet
        self.rules_engine = RulesEngine()  # Initialize RulesEngine

    def get_bet(self, game_state, player, table):
        """Place a Field bet during the point roll if no active bet exists."""
        if game_state.phase != "point":
            return None  # Only place bets after the point is established
        else:
            # Check if the player already has an active Field bet
            if player.has_active_bet(table, "Field"):
                return None  # No new bet to place

        # Use RulesEngine to create a Field bet
        return self.rules_engine.create_bet("Field", self.min_bet, player)

# File: .\craps\strategies\free_odds_strategy.py

# File: .\craps\strategies\free_odds_strategy.py

from craps.rules_engine import RulesEngine  # Import RulesEngine

class FreeOddsStrategy:
    """Betting strategy for Free Odds on any active bet."""
    def __init__(self, table, odds_multiple="1x"):
        """
        Initialize the Free Odds strategy.
        
        :param table: The table object to determine minimum bets.
        :param odds_multiple: The odds multiple (e.g., "1x", "2x", "3x", "1-2-3", "3-4-5").
        """
        self.table = table
        self.odds_multiple = odds_multiple
        self.rules_engine = RulesEngine()  # Initialize RulesEngine

    def get_odds_amount(self, original_bet_amount):
        """Calculate the odds amount based on the original bet amount and the selected multiple."""
        if self.odds_multiple == "1x":
            return original_bet_amount
        elif self.odds_multiple == "2x":
            return original_bet_amount * 2
        elif self.odds_multiple == "3x":
            return original_bet_amount * 3
        elif self.odds_multiple == "1-2-3":
            # 1x on 4/10, 2x on 5/9, 3x on 6/8
            return original_bet_amount
        elif self.odds_multiple == "3-4-5":
            # 3x on 4/10, 4x on 5/9, 5x on 6/8
            return original_bet_amount
        else:
            raise ValueError(f"Invalid odds multiple: {self.odds_multiple}")

    def get_bet(self, game_state, player):
        """Place Free Odds bets on any active bets."""
        bets = []

        for active_bet in player.active_bets:
            if active_bet.bet_type in ["Pass Line", "Place"]:
                # Calculate the odds amount based on the original bet amount
                odds_amount = self.get_odds_amount(active_bet.amount)

                # Create a Free Odds bet using RulesEngine
                if active_bet.bet_type == "Pass Line":
                    bets.append(self.rules_engine.create_bet(
                        "Pass Line Odds",
                        odds_amount,
                        player,
                        parent_bet=active_bet
                    ))
                elif active_bet.bet_type == "Place":
                    bets.append(self.rules_engine.create_bet(
                        "Place Odds",
                        odds_amount,
                        player,
                        number=active_bet.number,
                        parent_bet=active_bet
                    ))

        return bets if bets else None

# File: .\craps\strategies\iron_cross_strategy.py

# File: .\craps\strategies\iron_cross_strategy.py

from craps.rules_engine import RulesEngine  # Import RulesEngine

class IronCrossStrategy:
    """Betting strategy for Iron Cross."""
    def __init__(self, table, min_bet):
        """
        Initialize the Iron Cross strategy.
        
        :param table: The table object to determine minimum bets.
        :param min_bet: The minimum bet amount for the table.
        """
        self.table = table
        self.min_bet = min_bet
        self.rules_engine = RulesEngine()  # Initialize RulesEngine

    def get_bet(self, game_state, player, table):
        """Place bets for the Iron Cross strategy."""
        if game_state.phase == "come-out":
            # Place a Pass Line bet during the come-out roll if no active bet exists
            if not any(bet.owner == player and bet.bet_type == "Pass Line" for bet in table.bets):
                return self.rules_engine.create_bet("Pass Line", self.min_bet, player)
        elif game_state.phase == "point":
            # Reactivate inactive Place bets
            for bet in table.bets:
                if bet.owner == player and bet.bet_type.startswith("Place") and bet.status == "inactive":
                    bet.status = "active"
                    message = f"{player.name}'s {bet.bet_type} bet is now ON."
                    self.play_by_play.write(message)

            # Place Place bets on 5, 6, and 8 during the point phase (excluding the point number)
            numbers = [5, 6, 8]  # Numbers for the Iron Cross

            # Exclude the point number
            if game_state.point in numbers:
                numbers.remove(game_state.point)

            # Filter out numbers already covered by a Place bet
            numbers = [
                num for num in numbers
                if not any(
                    bet.owner == player and bet.bet_type.startswith("Place") and bet.number == num
                    for bet in table.bets
                )
            ]

            # Use RulesEngine to create Place bets
            bets = []
            for number in numbers:
                min_bet = self.rules_engine.get_minimum_bet(number)  # Use RulesEngine to get minimum bet
                bets.append(self.rules_engine.create_bet("Place", min_bet, player, number=number))

            # Add a Field bet if no active Field bet exists
            if not any(bet.owner == player and bet.bet_type == "Field" for bet in table.bets):
                bets.append(self.rules_engine.create_bet("Field", self.min_bet, player))

            return bets if bets else None

        return None  # No bet to place

# File: .\craps\strategies\pass_line_odds_strategy.py

# File: .\craps\strategies\pass_line_odds_strategy.py

from craps.rules_engine import RulesEngine  # Import RulesEngine

class PassLineOddsStrategy:
    """Betting strategy for Pass Line with Odds bets."""
    def __init__(self, table, odds_multiple=1):
        """
        Initialize the Pass Line Odds strategy.
        
        :param table: The table object to determine minimum bets.
        :param odds_multiple: The multiple of the minimum bet to use for odds (e.g., 1x, 2x).
        """
        self.table = table
        self.odds_multiple = odds_multiple
        self.rules_engine = RulesEngine()  # Initialize RulesEngine

    def get_bet(self, game_state, player, table):
        """Place a Pass Line or Pass Line Odds bet based on the game state."""
        if game_state.phase not in ["come-out", "point"]:
            return None  # Do not place the bet if the phase is invalid

        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if player.has_active_bet(table, "Pass Line"):
                return None  # No new bet to place

            # Use RulesEngine to create a Pass Line bet
            return self.rules_engine.create_bet("Pass Line", self.table.house_rules.table_minimum, player)
        
        elif game_state.phase == "point":
            # Check if the player already has an active Pass Line Odds bet
            if player.has_active_bet(table, "Pass Line Odds"):
                return None  # No new bet to place

            # Find the player's active Pass Line bet
            pass_line_bet = next(
                (bet for bet in table.bets if bet.owner == player and bet.bet_type == "Pass Line"),
                None
            )
            if pass_line_bet is None:
                return None  # No Pass Line bet found

            # Use RulesEngine to create a Pass Line Odds bet linked to the Pass Line bet
            return self.rules_engine.create_bet(
                "Pass Line Odds",
                self.table.house_rules.table_minimum * self.odds_multiple,  # Bet amount
                player,  # Owner
                number=game_state.point,  # Pass the current point number
                parent_bet=pass_line_bet  # Parent Pass Line bet
            )
        
        return None  # No bet to place

# File: .\craps\strategies\pass_line_strategy.py

# File: .\craps\strategies\pass_line_strategy.py

from craps.rules_engine import RulesEngine  # Import RulesEngine

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        self.min_bet = min_bet
        self.rules_engine = RulesEngine()  # Initialize RulesEngine

    def get_bet(self, game_state, player, table):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if player.has_active_bet(table, "Pass Line"):
                return None  # No new bet to place

            # Use RulesEngine to create a Pass Line bet
            return self.rules_engine.create_bet("Pass Line", self.min_bet, player)
        return None  # No bet to place

# File: .\craps\strategies\place_strategy.py

# File: .\craps\strategies\place_strategy.py

from craps.rules_engine import RulesEngine  # Import RulesEngine

class PlaceBetStrategy:
    """Betting strategy for Place Bets."""
    def __init__(self, table, numbers_or_strategy):
        """
        Initialize the Place Bet strategy.
        
        :param table: The table object to determine minimum bets.
        :param numbers_or_strategy: A list of numbers (e.g., [5, 6, 8, 9]) or a strategy ("inside", "across").
        """
        self.table = table
        self.numbers_or_strategy = numbers_or_strategy
        self.rules_engine = RulesEngine()  # Initialize RulesEngine

    def get_bet(self, game_state, player, table):
        """Place Place Bets based on the strategy and game state."""
        if game_state.phase != "point":
            return None  # Only place bets after the point is established

        # Determine which numbers to bet on
        if isinstance(self.numbers_or_strategy, str):
            if self.numbers_or_strategy == "inside":
                numbers = [5, 6, 8, 9]  # Inside numbers
            elif self.numbers_or_strategy == "across":
                numbers = [4, 5, 6, 8, 9, 10]  # Across numbers
            else:
                raise ValueError(f"Invalid strategy: {self.numbers_or_strategy}")
        else:
            numbers = self.numbers_or_strategy  # Specific numbers provided

        # Filter out numbers already covered by a Pass Line bet or a Place bet
        numbers = [
            num for num in numbers
            if not any(
                (bet.owner == player and bet.bet_type == "Pass Line" and bet.point == num) or  # Pass Line covers the point
                (bet.owner == player and bet.bet_type.startswith("Place") and bet.number == num)  # Place Bet covers the number
                for bet in table.bets
            )
        ]

        # Use RulesEngine to create Place bets
        bets = []
        for number in numbers:
            min_bet = self.table.get_minimum_bet(number)
            bets.append(self.rules_engine.create_bet("Place", min_bet, player, number=number))

        return bets if bets else None

# File: .\craps\strategies\three_point_molly_strategy.py

# File: .\craps\strategies\three_point_molly_strategy.py

from craps.rules_engine import RulesEngine 

class ThreePointMollyStrategy:
    """Betting strategy for the 3-Point Molly system."""
    def __init__(self, min_bet, odds_multiple=1, come_odds_working_on_come_out=False):
        """
        Initialize the 3-Point Molly strategy.

        :param min_bet: The minimum bet amount for the table.
        :param odds_multiple: The multiple of the minimum bet to use for odds (e.g., 1x, 2x).
        :param come_odds_working_on_come_out: Whether Come odds bets are working during the come-out roll.
        """
        self.min_bet = min_bet
        self.odds_multiple = odds_multiple
        self.come_odds_working_on_come_out = come_odds_working_on_come_out
        self.rules_engine = RulesEngine() 

    def get_bet(self, game_state, player, table):
        """
        Place bets according to the 3-Point Molly strategy.

        :param game_state: The current game state.
        :param player: The player placing the bets.
        :param table: The table to place the bets on.
        :return: A list of bets to place.
        """
        bets = []

        # Place a Pass Line bet if no active Pass Line bet exists (only during come-out phase)
        if game_state.phase == "come-out":
            if not any(bet.bet_type == "Pass Line" for bet in table.bets if bet.owner == player):
                bets.append(self.rules_engine.create_bet(
                    "Pass Line",
                    self.min_bet,
                    player
                ))

        # Place up to 3 Come bets if fewer than 3 active Come bets exist (only during point phase)
        if game_state.phase == "point":
            active_come_bets = [bet for bet in table.bets if bet.bet_type == "Come" and bet.owner == player]
            if len(active_come_bets) < 3:
                bets.append(self.rules_engine.create_bet(
                    "Come",
                    self.min_bet,
                    player
                ))

        # Place odds on active Pass Line and Come bets (only during point phase)
        if game_state.phase == "point":
            for bet in table.bets:
                if bet.owner == player:
                    if bet.bet_type == "Pass Line" and bet.status == "active":
                        # Place Pass Line Odds
                        odds_amount = self.min_bet * self.odds_multiple
                        bets.append(self.rules_engine.create_bet(
                            "Pass Line Odds",
                            odds_amount,
                            player,
                            number=game_state.point,  # Pass the current point number
                            parent_bet=bet
                        ))
                    elif bet.bet_type == "Come" and bet.status == "active" and bet.number is not None:
                        # Place Come Odds
                        odds_amount = self.min_bet * self.odds_multiple
                        bets.append(self.rules_engine.create_bet(
                            "Come Odds",
                            odds_amount,
                            player,
                            number=bet.number,  # Pass the Come bet's number
                            parent_bet=bet
                        ))

        return bets if bets else None

# File: .\tests\test_come_bet_rules.py

# File: .\tests\test_come_bet_rules.py

import unittest
from craps.common import CommonTableSetup  # Import the common setup

class TestComeBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize the common table setup for testing."""
        self.common_setup = CommonTableSetup()

    def test_come_bet_resolution(self):
        """Test Come bet resolution during the point phase."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100)

        # Simulate a come-out roll of 6 to move the Come bet to number 6
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, "come-out")

        # Check that the Come bet has moved to number 6
        self.assertEqual(come_bet.number, 6, "Come bet should move to number 6")

        # Simulate a point roll of 6 (win)
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, "point")

        # Check that the Come bet is resolved as won
        self.assertEqual(come_bet.status, "won", "Come bet should win on 6")

    def test_come_odds_bet_resolution(self):
        """Test Come Odds bet resolution after the Come bet has moved to a number."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100)

        # Simulate a come-out roll of 6 to move the Come bet to number 6
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, "come-out")

        # Place a Come Odds bet linked to the Come bet
        come_odds_bet = self.common_setup.place_bet("Come Odds", 100)

        # Simulate a point roll of 6 (win)
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, "point")

        # Check that the Come Odds bet is resolved as won
        self.assertEqual(come_odds_bet.status, "won", "Come Odds bet should win on 6")

    def test_come_odds_bet_cannot_be_placed_before_come_bet_moves(self):
        """Test that Come Odds bets cannot be placed before the Come bet moves to a number."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100)

        # Attempt to place a Come Odds bet before the Come bet moves to a number
        with self.assertRaises(ValueError):
            self.common_setup.place_bet("Come Odds", 100)

    def test_come_odds_bet_can_be_placed_after_come_bet_moves(self):
        """Test that Come Odds bets can be placed after the Come bet moves to a number."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100)

        # Simulate a come-out roll of 6 to move the Come bet to number 6
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, "come-out")

        # Place a Come Odds bet after the Come bet has moved to a number
        come_odds_bet = self.common_setup.place_bet("Come Odds", 100)

        # Check that the Come Odds bet is placed successfully
        self.assertEqual(come_odds_bet.status, "active", "Come Odds bet should be active")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_dice.py

import sys
import os
import unittest
from craps.dice import Dice

class TestDice(unittest.TestCase):
    def test_roll(self):
        dice = Dice()
        num_rolls = 1_000_000  # Number of rolls to simulate
        tolerance = 0.001  # Tolerance for probability comparison

        # Initialize counters for single die outcomes
        single_die_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}

        # Initialize counters for total outcomes
        total_counts = {
            2: 0, 3: 0, 4: 0, 5: 0, 6: 0,
            7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0
        }

        # Roll the dice 1 million times
        for _ in range(num_rolls):
            outcome = dice.roll()
            total = sum(outcome)

            # Count single die outcomes
            for die in outcome:
                single_die_counts[die] += 1

            # Count total outcomes
            total_counts[total] += 1

        # Calculate observed probabilities for single die outcomes
        single_die_probs = {
            die: count / (num_rolls * 2)  # Each roll involves 2 dice
            for die, count in single_die_counts.items()
        }

        # Calculate observed probabilities for total outcomes
        total_probs = {
            total: count / num_rolls
            for total, count in total_counts.items()
        }

        # Expected probabilities for single die outcomes
        expected_single_die_prob = 1 / 6

        # Expected probabilities for total outcomes
        expected_total_probs = {
            2: 1 / 36,
            3: 2 / 36,
            4: 3 / 36,
            5: 4 / 36,
            6: 5 / 36,
            7: 6 / 36,
            8: 5 / 36,
            9: 4 / 36,
            10: 3 / 36,
            11: 2 / 36,
            12: 1 / 36,
        }

        # Display results for single die outcomes
        print("\nSingle Die Outcomes:")
        print(f"{'Outcome':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for die in range(1, 7):
            actual = single_die_probs[die]
            expected = expected_single_die_prob
            deviation = actual - expected
            print(f"{die:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Display results for total outcomes
        print("\nTotal Outcomes:")
        print(f"{'Total':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for total in range(2, 13):
            actual = total_probs[total]
            expected = expected_total_probs[total]
            deviation = actual - expected
            print(f"{total:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Test single die outcomes
        for die, prob in single_die_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_single_die_prob,
                delta=tolerance,
                msg=f"Single die outcome {die} probability is not within tolerance."
            )

        # Test total outcomes
        for total, prob in total_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_total_probs[total],
                delta=tolerance,
                msg=f"Total outcome {total} probability is not within tolerance."
            )

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_field_bet.py

# File: .\tests\test_field_bet.py

import unittest
from craps.common import CommonTableSetup  # Import the common setup

class TestFieldBet(unittest.TestCase):
    def setUp(self):
        """Initialize the common table setup for testing."""
        self.common_setup = CommonTableSetup()

    def test_field_bet_outcomes(self):
        """Test Field bet outcomes for all possible dice totals."""
        # Define all possible dice totals and their expected outcomes
        test_cases = [
            # (dice_total, expected_status, expected_payout)
            (2, "won", 20),  # Field Bet wins 2:1 on 2 (house rules: 2:1)
            (3, "won", 10),  # Field Bet wins 1:1 on 3
            (4, "won", 10),  # Field Bet wins 1:1 on 4
            (5, "lost", 0),  # Field Bet loses on 5
            (6, "lost", 0),  # Field Bet loses on 6
            (7, "lost", 0),  # Field Bet loses on 7
            (8, "lost", 0),  # Field Bet loses on 8
            (9, "won", 10),  # Field Bet wins 1:1 on 9
            (10, "won", 10),  # Field Bet wins 1:1 on 10
            (11, "won", 10),  # Field Bet wins 1:1 on 11
            (12, "won", 30),  # Field Bet wins 3:1 on 12 (house rules: 3:1)
        ]

        # Print table header
        print("\nField Bet Test Results (House Rules: 2:1 for 2, 3:1 for 12)")
        print("=" * 70)
        print(f"{'Dice Total':<12} {'Expected Status':<16} {'Expected Payout':<16} {'Actual Status':<16} {'Actual Payout':<16} {'Result'}")

        # Test each dice total
        for dice_total, expected_status, expected_payout in test_cases:
            # Place a Field bet
            field_bet = self.common_setup.place_bet("Field", 10)

            # Simulate the dice roll
            dice_outcome = self._get_dice_outcome(dice_total)
            resolved_bets = self.common_setup.simulate_roll(dice_outcome)

            # Get the actual status and payout
            actual_status = field_bet.status
            actual_payout = field_bet.payout() if field_bet.status == "won" else 0

            # Compare expected vs. actual
            status_match = actual_status == expected_status
            payout_match = actual_payout == expected_payout
            result = "✔" if status_match and payout_match else "✗"

            # Print the results in a table format
            print(f"{dice_total:<12} {expected_status:<16} ${expected_payout:<15} {actual_status:<16} ${actual_payout:<15} {result}")

            # Reset the table for the next test case
            self.common_setup.reset_table()

    def _get_dice_outcome(self, total):
        """Helper method to generate a dice outcome for a given total."""
        if total < 2 or total > 12:
            raise ValueError("Invalid dice total. Must be between 2 and 12.")
        for die1 in range(1, 7):
            for die2 in range(1, 7):
                if die1 + die2 == total:
                    return [die1, die2]
        return None

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_multiple_place_bets.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bets.place_bet import PlaceBet
from craps.bets.free_odds_bet import FreeOddsBet

class TestMultiplePlaceBets(unittest.TestCase):
    def setUp(self):
        """Initialize multiple Place bets and the RulesEngine for testing."""
        self.player_name = "Alice"
        self.bet_amount = 100
        self.rules_engine = RulesEngine()

        # Create Place bets on multiple numbers
        self.place_bet_6 = PlaceBet(self.bet_amount, self.player_name, number=6)
        self.place_bet_8 = PlaceBet(self.bet_amount, self.player_name, number=8)
        self.place_bet_5 = PlaceBet(self.bet_amount, self.player_name, number=5)

        # Create Place Odds bets linked to the Place bets
        self.place_odds_bet_6 = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet_6)
        self.place_odds_bet_8 = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet_8)
        self.place_odds_bet_5 = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet_5)
        
    def test_multiple_place_bets_resolution(self):
        """Test resolution of multiple Place bets and their Place Odds bets."""
        # Simulate a roll of 6
        dice_outcome = [3, 3]  # Total of 6
        self.rules_engine.resolve_bet(self.place_bet_6, dice_outcome, "point", None)
        self.rules_engine.resolve_bet(self.place_odds_bet_6, dice_outcome, "point", None)
        self.assertEqual(self.place_bet_6.status, "won", "Place bet on 6 should win on 6")
        self.assertEqual(self.place_odds_bet_6.status, "won", "Place Odds bet on 6 should win on 6")

        # Simulate a roll of 8
        dice_outcome = [4, 4]  # Total of 8
        self.rules_engine.resolve_bet(self.place_bet_8, dice_outcome, "point", None)
        self.rules_engine.resolve_bet(self.place_odds_bet_8, dice_outcome, "point", None)
        self.assertEqual(self.place_bet_8.status, "won", "Place bet on 8 should win on 8")
        self.assertEqual(self.place_odds_bet_8.status, "won", "Place Odds bet on 8 should win on 8")

        # Simulate a roll of 7
        dice_outcome = [3, 4]  # Total of 7
        self.rules_engine.resolve_bet(self.place_bet_5, dice_outcome, "point", None)
        self.rules_engine.resolve_bet(self.place_odds_bet_5, dice_outcome, "point", None)
        self.assertEqual(self.place_bet_5.status, "lost", "Place bet on 5 should lose on 7")
        self.assertEqual(self.place_odds_bet_5.status, "lost", "Place Odds bet on 5 should lose on 7")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_pass_line_bet_rules.py

import unittest
from typing import List
from craps.rules_engine import RulesEngine
from craps.bets.pass_line_bet import PassLineBet

class TestPassLineBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize a Pass Line bet and the RulesEngine for testing."""
        self.player_name = "Alice"
        self.bet_amount = 100
        self.pass_line_bet = PassLineBet(self.bet_amount, self.player_name)
        self.rules_engine = RulesEngine()

    def test_come_out_phase(self):
        """Test Pass Line bet behavior during the come-out phase."""
        # Test winning rolls (7, 11)
        for dice_total in [7, 11]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = self._get_dice_outcome(dice_total)
                self.rules_engine.resolve_bet(self.pass_line_bet, dice_outcome, "come-out", None)
                self.assertEqual(self.pass_line_bet.status, "won", f"Pass Line bet should win on {dice_total}")

        # Test losing rolls (2, 3, 12)
        for dice_total in [2, 3, 12]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = self._get_dice_outcome(dice_total)
                self.rules_engine.resolve_bet(self.pass_line_bet, dice_outcome, "come-out", None)
                self.assertEqual(self.pass_line_bet.status, "lost", f"Pass Line bet should lose on {dice_total}")

        # Test setting the point (4, 5, 6, 8, 9, 10)
        for dice_total in [4, 5, 6, 8, 9, 10]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = self._get_dice_outcome(dice_total)
                new_point = self.rules_engine.resolve_bet(self.pass_line_bet, dice_outcome, "come-out", None)
                self.assertEqual(self.pass_line_bet.status, "active", f"Pass Line bet should remain active on {dice_total}")
                self.assertEqual(new_point, dice_total, f"Point should be set to {dice_total}")

    def test_point_phase(self):
        """Test Pass Line bet behavior during the point phase."""
        # Set the point to 6
        point = 6
        dice_outcome = self._get_dice_outcome(point)
        new_point = self.rules_engine.resolve_bet(self.pass_line_bet, dice_outcome, "come-out", None)
        self.assertEqual(new_point, point, f"Point should be set to {point}")

        # Test rolls that do not resolve the bet (2, 3, 4, 5, 8, 9, 10, 11, 12)
        for dice_total in [2, 3, 4, 5, 8, 9, 10, 11, 12]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = self._get_dice_outcome(dice_total)
                self.rules_engine.resolve_bet(self.pass_line_bet, dice_outcome, "point", point)
                self.assertEqual(self.pass_line_bet.status, "active", f"Pass Line bet should remain active on {dice_total}")

        # Test winning roll (point number)
        dice_outcome = self._get_dice_outcome(point)
        self.rules_engine.resolve_bet(self.pass_line_bet, dice_outcome, "point", point)
        self.assertEqual(self.pass_line_bet.status, "won", f"Pass Line bet should win on {point}")

        # Reset the bet for the next test
        self.pass_line_bet = PassLineBet(self.bet_amount, self.player_name)
        new_point = self.rules_engine.resolve_bet(self.pass_line_bet, self._get_dice_outcome(point), "come-out", None)
        self.assertEqual(new_point, point, f"Point should be set to {point}")

        # Test losing roll (7)
        dice_outcome = self._get_dice_outcome(7)
        self.rules_engine.resolve_bet(self.pass_line_bet, dice_outcome, "point", point)
        self.assertEqual(self.pass_line_bet.status, "lost", "Pass Line bet should lose on 7")

    def test_can_bet(self):
        """Test can_bet behavior for Pass Line bets."""
        # Pass Line bets can be placed during the come-out phase
        self.assertTrue(self.rules_engine.can_make_bet("Pass Line", "come-out"), "Pass Line bets should be allowed during the come-out phase")

        # Pass Line bets cannot be placed during the point phase
        self.assertFalse(self.rules_engine.can_make_bet("Pass Line", "point"), "Pass Line bets should not be allowed during the point phase")

    def test_can_remove(self):
        """Test can_remove behavior for Pass Line bets."""
        # Pass Line bets cannot be removed during the come-out phase
        self.assertFalse(self.rules_engine.can_remove_bet("Pass Line", "come-out"), "Pass Line bets should not be removable during the come-out phase")

        # Pass Line bets cannot be removed during the point phase
        self.assertFalse(self.rules_engine.can_remove_bet("Pass Line", "point"), "Pass Line bets should not be removable during the point phase")

    def test_can_turn_on(self):
        """Test can_turn_on behavior for Pass Line bets."""
        # Pass Line bets are always on during the come-out phase
        self.assertTrue(self.rules_engine.can_turn_on("Pass Line", "come-out"), "Pass Line bets should always be on during the come-out phase")

        # Pass Line bets are always on during the point phase
        self.assertTrue(self.rules_engine.can_turn_on("Pass Line", "point"), "Pass Line bets should always be on during the point phase")

    def test_linked_bet(self):
        """Test linked_bet behavior for Pass Line bets."""
        # Pass Line bets are linked to Pass Line Odds
        linked_bet_type = self.rules_engine.get_linked_bet_type("Pass Line")
        self.assertEqual(linked_bet_type, "Pass Line Odds", "Pass Line bets should be linked to Pass Line Odds")

    def _get_dice_outcome(self, total: int) -> List[int]:
        """Helper method to generate a dice outcome for a given total."""
        if total < 2 or total > 12:
            raise ValueError("Invalid dice total. Must be between 2 and 12.")
        for die1 in range(1, 7):
            for die2 in range(1, 7):
                if die1 + die2 == total:
                    return [die1, die2]
        return None

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_payouts.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bets.place_bet import PlaceBet

class TestPayouts(unittest.TestCase):
    def setUp(self):
        """Initialize Place bets and the RulesEngine for testing."""
        self.player_name = "Alice"
        self.rules_engine = RulesEngine()

        # Create Place bets on different numbers
        self.place_bet_4 = PlaceBet(10, self.player_name, number=4)  # $10 on 4
        self.place_bet_5 = PlaceBet(10, self.player_name, number=5)  # $10 on 5
        self.place_bet_6 = PlaceBet(12, self.player_name, number=6)  # $12 on 6

    def test_place_bet_payouts(self):
        """Test payouts for Place bets after resolving them."""
        # Resolve the Place bet on 4 (winning roll)
        dice_outcome = [2, 2]  # Total of 4
        self.rules_engine.resolve_bet(self.place_bet_4, dice_outcome, "point", None)
        self.assertEqual(self.place_bet_4.status, "won", "Place bet on 4 should be won")
        self.assertEqual(self.place_bet_4.payout_ratio, (9, 5), "Place bet on 4 should have a payout ratio of 9:5")
        self.assertEqual(self.place_bet_4.payout(), 28, "Place bet on 4 should pay 9:5 ($18 profit + $10 original bet = $28)")

        # Resolve the Place bet on 5 (winning roll)
        dice_outcome = [3, 2]  # Total of 5
        self.rules_engine.resolve_bet(self.place_bet_5, dice_outcome, "point", None)
        self.assertEqual(self.place_bet_5.status, "won", "Place bet on 5 should be won")
        self.assertEqual(self.place_bet_5.payout_ratio, (7, 5), "Place bet on 5 should have a payout ratio of 7:5")
        self.assertEqual(self.place_bet_5.payout(), 24, "Place bet on 5 should pay 7:5 ($14 profit + $10 original bet = $24)")

        # Resolve the Place bet on 6 (winning roll)
        dice_outcome = [3, 3]  # Total of 6
        self.rules_engine.resolve_bet(self.place_bet_6, dice_outcome, "point", None)
        self.assertEqual(self.place_bet_6.status, "won", "Place bet on 6 should be won")
        self.assertEqual(self.place_bet_6.payout_ratio, (7, 6), "Place bet on 6 should have a payout ratio of 7:6")
        self.assertEqual(self.place_bet_6.payout(), 26, "Place bet on 6 should pay 7:6 ($14 profit + $12 original bet = $26)")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_place_bet_rules.py

# File: .\tests\test_place_bet_rules.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bets.place_bet import PlaceBet

class TestPlaceBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize a Place bet and the RulesEngine for testing."""
        self.player_name = "Alice"
        self.bet_amount = 100
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)  # Place bet on 6
        self.rules_engine = RulesEngine()

    def test_point_phase(self):
        """Test Place bet behavior during the point phase."""
        # Test winning roll (6)
        dice_outcome = [3, 3]  # Total of 6
        self.rules_engine.resolve_bet(self.place_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_bet.status, "won", "Place bet should win on 6")

        # Reset the bet for the next test
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)

        # Test losing roll (7)
        dice_outcome = [3, 4]  # Total of 7
        self.rules_engine.resolve_bet(self.place_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_bet.status, "lost", "Place bet should lose on 7")

        # Reset the bet for the next test
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)

        # Test non-resolving roll (8)
        dice_outcome = [4, 4]  # Total of 8
        self.rules_engine.resolve_bet(self.place_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_bet.status, "active", "Place bet should remain active on 8")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_place_odds_bet_rules.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bets.free_odds_bet import FreeOddsBet
from craps.bets.place_bet import PlaceBet

class TestPlaceOddsBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize a Place Odds bet and the RulesEngine for testing."""
        self.player_name = "Alice"
        self.bet_amount = 100
        self.rules_engine = RulesEngine()

        # Create a Place bet and a Place Odds bet linked to it
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)
        self.place_odds_bet = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet)

    def test_place_odds_resolution(self):
        """Test Place Odds bet resolution during the point phase."""
        # Test winning roll (6)
        dice_outcome = [3, 3]  # Total of 6
        self.rules_engine.resolve_bet(self.place_odds_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_odds_bet.status, "won", "Place Odds bet should win on 6")

        # Reset the bet for the next test
        self.place_odds_bet = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet)

        # Test losing roll (7)
        dice_outcome = [3, 4]  # Total of 7
        self.rules_engine.resolve_bet(self.place_odds_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_odds_bet.status, "lost", "Place Odds bet should lose on 7")

        # Reset the bet for the next test
        self.place_odds_bet = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet)

        # Test non-resolving roll (8)
        dice_outcome = [4, 4]  # Total of 8
        self.rules_engine.resolve_bet(self.place_odds_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_odds_bet.status, "active", "Place Odds bet should remain active on 8")

    def test_payout_ratio(self):
        """Test payout ratio for Place Odds bets."""
        # Test payout ratio for Place Odds on 6
        payout_ratio = self.rules_engine.get_payout_ratio("Place Odds", number=6)
        self.assertEqual(payout_ratio, (6, 5), "Place Odds bet on 6 should have a payout ratio of 6:5")

        # Test payout ratio for Place Odds on 4
        payout_ratio = self.rules_engine.get_payout_ratio("Place Odds", number=4)
        self.assertEqual(payout_ratio, (2, 1), "Place Odds bet on 4 should have a payout ratio of 2:1")

    def test_place_odds_linked_to_place_bet(self):
        """Test that Place Odds bets are linked to Place bets."""
        linked_bet_type = self.rules_engine.get_linked_bet_type("Place")
        self.assertEqual(linked_bet_type, "Place Odds", "Place bets should be linked to Place Odds")

    def test_place_odds_cannot_be_placed_during_come_out(self):
        """Test that Place Odds bets cannot be placed during the come-out phase."""
        self.assertFalse(
            self.rules_engine.can_make_bet("Place Odds", "come-out", parent_bet=self.place_bet),
            "Place Odds bets should not be allowed during the come-out phase"
        )

    def test_place_odds_can_be_placed_during_point_phase(self):
        """Test that Place Odds bets can be placed during the point phase."""
        self.assertTrue(
            self.rules_engine.can_make_bet("Place Odds", "point", parent_bet=self.place_bet),
            "Place Odds bets should be allowed during the point phase"
        )

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_player.py

import unittest
from craps.player import Player
from craps.table import Table
from craps.bet import Bet

class TestPlayer(unittest.TestCase):
    def test_place_bet(self):
        player = Player("Alice", 1000)
        table = Table()
        player.place_bet("Pass Line", 100, table)
        self.assertEqual(player.balance, 900)
        self.assertEqual(len(player.bets), 1)
        self.assertEqual(len(table.bets), 1)

    def test_resolve_bets(self):
        player = Player("Alice", 1000)
        table = Table()
        bet = Bet("Pass Line", 100, "Alice")
        table.place_bet(bet)
        player.bets.append(bet)

        # Simulate a win
        bet.status = "won"
        player.resolve_bets(table)
        self.assertEqual(player.balance, 1100)
        self.assertEqual(len(player.bets), 0)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_puck.py

import unittest
from craps.puck import Puck

class TestPuck(unittest.TestCase):
    def test_puck(self):
        puck = Puck()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

        puck.set_point(4)
        self.assertEqual(puck.position, "On")
        self.assertEqual(puck.point, 4)

        puck.reset()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_shooter.py

import unittest
from craps.shooter import Shooter

class TestShooter(unittest.TestCase):
    def test_roll_dice(self):
        shooter = Shooter("Alice")
        outcome = shooter.roll_dice()
        self.assertIsInstance(outcome, list)
        self.assertEqual(len(outcome), 2)
        self.assertTrue(1 <= outcome[0] <= 6)
        self.assertTrue(1 <= outcome[1] <= 6)

if __name__ == "__main__":
    unittest.main()

