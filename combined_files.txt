# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.py'):  # Only process Python files
                    file_path = os.path.join(root, file)
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory (change as needed)
output_file = 'combined_files.txt'

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")

# File: .\main.py

# File: .\main.py

from colorama import init
init()  # Initialize colorama for colored text

from craps.table import Table
from craps.game_state import GameState
from craps.shooter import Shooter
from craps.strategies.pass_line import PassLineStrategy
from craps.strategies.place_bet import PlaceBetStrategy
from craps.statistics import Statistics

def main():
    # Initialize components
    table_minimum = 10  # Set table minimum
    table = Table(table_minimum=table_minimum)
    game_state = GameState()

    # Set the number of players, shooters, and initial bankroll
    num_players = 3
    num_shooters = 10
    initial_bankroll = 500

    # Initialize statistics
    stats = Statistics(table_minimum, num_shooters, num_players)

    # Create players with different betting strategies
    players = [
        Shooter(f"Player {i+1}", initial_balance=initial_bankroll, betting_strategy=PassLineStrategy(min_bet=10))
        if i == 0 else
        Shooter(f"Player {i+1}", initial_balance=initial_bankroll, betting_strategy=PlaceBetStrategy(table, "inside"))
        if i == 1 else
        Shooter(f"Player {i+1}", initial_balance=initial_bankroll, betting_strategy=PlaceBetStrategy(table, "across"))
        for i in range(num_players)
    ]

    # Simulate shooters
    for shooter_num in range(1, num_shooters + 1):
        player_index = (shooter_num - 1) % num_players
        shooter = players[player_index]
        game_state.set_shooter(shooter)
        print(f"\nShooter {shooter_num} is {shooter.name}. It's their turn to roll.")

        while True:
            # Allow all players to place bets
            for player in players:
                bet = player.betting_strategy.get_bet(game_state, player)
                if bet:
                    player.place_bet(bet, table)

            # Roll the dice and resolve bets
            outcome = shooter.roll_dice()
            total = sum(outcome)
            stats.update_rolls()  # Update roll count
            print(f"{shooter.name} rolled: {outcome} (Total: {total}) | Roll Count: {stats.num_rolls}")

            # Check bets on the table
            table.check_bets(outcome, game_state)

            # Resolve bets for each player and update their bankroll
            for player in players:
                player.resolve_bets(table)
            
            # Update game state
            previous_phase = game_state.phase
            message = game_state.update_state(outcome)
            if message:
                print(message)

            # Check if the shooter 7-outs (only if the point was set)
            if previous_phase == "point" and total == 7:
                print(f"{shooter.name} has 7-ed out. Their turn is over.")
                break

    # Update player bankrolls and calculate statistics
    stats.update_player_bankrolls(players)
    stats.print_statistics()

if __name__ == "__main__":
    main()

# File: .\craps\bet.py

# File: .\craps\bet.py

class Bet:
    """Base class for all bet types."""
    def __init__(self, bet_type, amount, owner, payout_ratio=(1, 1), locked=True, vig=0):
        """
        Initialize a bet.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Come").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param payout_ratio: The payout ratio as a tuple (numerator, denominator).
        :param locked: Whether the bet is locked (cannot be taken down).
        :param vig: The vig (commission) as a percentage of the bet amount.
        """
        self.bet_type = bet_type
        self.amount = amount
        self.owner = owner
        self.payout_ratio = payout_ratio
        self.locked = locked
        self.vig = vig
        self.status = "active"  # Can be "active", "won", "lost", or "pushed"

    def resolve(self, outcome, game_state):
        """
        Resolve the bet based on the dice outcome and game state.
        
        :param outcome: The result of the dice roll (e.g., [3, 4]).
        :param game_state: The current state of the game (e.g., come-out phase, point phase).
        """
        raise NotImplementedError("Subclasses must implement this method.")

    def payout(self):
        """
        Calculate the payout for the bet, including the vig (if applicable).
        
        :return: The payout amount.
        """
        if self.status != "won":
            return 0
        
        # Calculate the payout based on the payout ratio
        numerator, denominator = self.payout_ratio
        payout = self.amount * numerator // denominator
        
        # Deduct the vig (if applicable)
        if self.vig > 0:
            vig_amount = self.amount * self.vig // 100
            payout -= vig_amount
        
        return payout

    def is_resolved(self):
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def __str__(self):
        return f"{self.owner}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"

# File: .\craps\betting_strategy.py

class BettingStrategy:
    """Base class for all betting strategies."""
    def __init__(self, min_bet):
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Determine the bet to place based on the game state and player."""
        raise NotImplementedError("Subclasses must implement this method.")


class PassLineStrategy(BettingStrategy):
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        super().__init__(min_bet)
        self.has_bet = False  # Track if the player has an active Pass Line bet

    def get_bet(self, game_state, player):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            if not self.has_bet:
                self.has_bet = True
                return {"bet_type": "Pass Line", "amount": self.min_bet}
            else:
                # Reset the bet flag if the previous bet was resolved (win or lose)
                self.has_bet = False
                return {"bet_type": "Pass Line", "amount": self.min_bet}
        return None  # No bet to place  

# File: .\craps\dice.py

import random

class Dice:
    def __init__(self):
        self.values = [1, 1]

    def roll(self):
        self.values = [random.randint(1, 6), random.randint(1, 6)]
        return self.values

# File: .\craps\game_state.py

from colorama import Fore, Style
from craps.puck import Puck

class GameState:
    def __init__(self):
        self.phase = "come-out"
        self.point = None
        self.puck = Puck()

    def set_shooter(self, shooter):
        self.shooter = shooter
        self.shooter.point = self.point  # Pass the point to the shooter

    def update_state(self, dice_outcome):
        total = sum(dice_outcome)
        message = None

        if self.phase == "come-out":
            if total in [7, 11]:
                self.puck.reset()
                message = f"{Fore.GREEN}✅ 7-Winner: Pass Line bets win!{Style.RESET_ALL}"
            elif total in [2, 3, 12]:
                self.puck.reset()
                message = f"{Fore.RED}❌ Craps: Pass Line bets lose!{Style.RESET_ALL}"
            else:
                self.phase = "point"
                self.puck.set_point(total)
                self.point = total
                message = f"{Fore.YELLOW}Point Set: {total}{Style.RESET_ALL}"
        else:  # Point phase
            if total == self.puck.point:
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"{Fore.GREEN}✅ Point Hit: {total}. Pass Line bets win!{Style.RESET_ALL}"
            elif total == 7:
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"{Fore.RED}❌ 7-Out: Pass Line bets lose!{Style.RESET_ALL}"

        return message

    def get_puck_state(self):
        if self.puck.position == "On":
            return f"Puck is ON (Point: {self.puck.point})"
        else:
            return "Puck is OFF (Come-out phase)"

    def __str__(self):
        return f"Game State: {self.get_puck_state()}"

# File: .\craps\player.py

# File: .\craps\player.py

from craps.bet import Bet

class Player:
    def __init__(self, name, initial_balance=500, betting_strategy=None):
        """
        Initialize a player.
        
        :param name: The name of the player.
        :param initial_balance: The initial bankroll of the player.
        :param betting_strategy: The betting strategy used by the player.
        """
        self.name = name
        self.balance = initial_balance
        self.betting_strategy = betting_strategy
        self.active_bets = []  # Track active bets for this player

    def place_bet(self, bet, table):
        """Place a bet (or multiple bets) on the table and deduct the amount from the player's balance."""
        if isinstance(bet, list):  # Handle multiple bets
            for b in bet:
                self._place_single_bet(b, table)
        else:  # Handle a single bet
            self._place_single_bet(bet, table)

    def _place_single_bet(self, bet, table):
        """Place a single bet on the table and deduct the amount from the player's balance."""
        if bet.amount > self.balance:
            # print(f"{self.name} has insufficient funds to place a ${bet.amount} bet.")
            return False
        
        self.balance -= bet.amount
        table.place_bet(bet)
        self.active_bets.append(bet)
        print(f"{self.name} placed a ${bet.amount} {bet.bet_type} bet. Bankroll: ${self.balance}")
        return True

    def resolve_bets(self, table):
        """Resolve all active bets for the player and update the bankroll."""
        for bet in self.active_bets:
            if bet.status == "won":
                payout = bet.payout()
                self.balance += payout
                print(f"{self.name} WON ${payout} on a ${bet.amount} {bet.bet_type} bet. Bankroll: ${self.balance}")
            elif bet.status == "lost":
                print(f"{self.name} LOST a ${bet.amount} {bet.bet_type} bet. Bankroll: ${self.balance}")

        # Remove resolved bets (won or lost) from the active bets list
        self.active_bets = [bet for bet in self.active_bets if bet.status == "active"]

    def __str__(self):
        return f"Player: {self.name}, Balance: ${self.balance}"

# File: .\craps\puck.py

class Puck:
    def __init__(self):
        self.position = "Off"
        self.point = None

    def set_point(self, value):
        self.position = "On"
        self.point = value

    def reset(self):
        self.position = "Off"
        self.point = None

# File: .\craps\shooter.py

from craps.player import Player
from craps.dice import Dice

class Shooter(Player):
    def __init__(self, name, initial_balance=0, betting_strategy=None):
        super().__init__(name, initial_balance, betting_strategy)  # Pass betting_strategy to Player
        self.dice = Dice()

    def roll_dice(self):
        return self.dice.roll()

    def __str__(self):
        return f"Shooter: {self.name}, Balance: ${self.balance}"

# File: .\craps\statistics.py

# File: .\craps\statistics.py

class Statistics:
    """Class to track and calculate simulation statistics."""
    def __init__(self, table_minimum, num_shooters, num_players):
        """
        Initialize the statistics tracker.
        
        :param table_minimum: The minimum bet for the table.
        :param num_shooters: The number of shooters in the simulation.
        :param num_players: The number of players in the simulation.
        """
        self.table_minimum = table_minimum
        self.num_shooters = num_shooters
        self.num_players = num_players
        self.num_rolls = 0
        self.total_house_win_loss = 0
        self.total_player_win_loss = 0
        self.player_bankrolls = []
        self.highest_bankroll = 0
        self.lowest_bankroll = float('inf')

    def update_rolls(self):
        """Increment the roll count."""
        self.num_rolls += 1

    def update_house_win_loss(self, amount):
        """Update the total house win/loss."""
        self.total_house_win_loss += amount

    def update_player_win_loss(self, amount):
        """Update the total player win/loss."""
        self.total_player_win_loss += amount

    def update_player_bankrolls(self, players):
        """Update player bankrolls and track highest/lowest bankroll."""
        self.player_bankrolls = [player.balance for player in players]
        self.highest_bankroll = max(self.player_bankrolls)
        self.lowest_bankroll = min(self.player_bankrolls)

    def print_statistics(self):
        """Print the simulation statistics."""
        print("\n=== Simulation Statistics ===")
        print(f"Table Minimum: ${self.table_minimum}")
        print(f"Number of Shooters: {self.num_shooters}")
        print(f"Number of Players: {self.num_players}")
        print(f"Number of Rolls: {self.num_rolls}")
        print(f"Total House Win/Loss: ${self.total_house_win_loss}")
        print(f"Total Player Win/Loss: ${self.total_player_win_loss}")
        print(f"Player Bankrolls: {self.player_bankrolls}")
        print(f"Highest Player Bankroll: ${self.highest_bankroll}")
        print(f"Lowest Player Bankroll: ${self.lowest_bankroll}")

# File: .\craps\table.py

# File: .\craps\table.py

class Table:
    def __init__(self, table_minimum=5):
        """
        Initialize the table with a minimum bet.
        
        :param table_minimum: The minimum bet for the table (e.g., 5, 10, 15, 25).
        """
        self.bets = []
        self.table_minimum = table_minimum
        self.unit = table_minimum // 5  # Unit is table minimum divided by 5

    def place_bet(self, bet):
        """Place a bet on the table."""
        self.bets.append(bet)

    def check_bets(self, outcome, game_state):
        """Resolve all bets on the table based on the dice outcome and game state."""
        for bet in self.bets:
            bet.resolve(outcome, game_state)

        # Remove all resolved bets (won or lost), but keep active/pushed bets
        self.bets = [bet for bet in self.bets if bet.status == "active"]

    def get_minimum_bet(self, number):
        """
        Get the minimum bet for a Place bet on a specific number.
        
        :param number: The number being bet on (4, 5, 6, 8, 9, or 10).
        :return: The minimum bet amount.
        """
        if number in [6, 8]:
            # For 6 and 8, the minimum bet is table minimum + unit
            return self.table_minimum + self.unit
        else:
            # For other numbers, the minimum bet is the table minimum
            return self.table_minimum

# File: .\craps\__init__.py



# File: .\craps\bets\pass_line.py

# File: .\craps\bets\pass_line.py

from ..bets import Bet  # Import the base Bet class

class PassLineBet(Bet):
    """Class representing a Pass Line bet."""
    def __init__(self, amount, owner):
        super().__init__("Pass Line", amount, owner, payout_ratio=(1, 1), locked=True)

    def resolve(self, outcome, game_state):
        """Resolve the Pass Line bet based on the dice outcome and game state."""
        total = sum(outcome)
        
        if game_state.phase == "come-out":
            # Come-out phase rules
            if total in [7, 11]:
                self.status = "won"  # Pass Line bet wins
            elif total in [2, 3, 12]:
                self.status = "lost"  # Pass Line bet loses
            else:
                # Point is set; bet remains active
                self.status = "active"
        else:  # Point phase
            if total == game_state.point:
                self.status = "won"  # Pass Line bet wins
            elif total == 7:
                self.status = "lost"  # Pass Line bet loses
            else:
                # Bet remains active
                self.status = "active"

# File: .\craps\bets\pass_line_odds.py

# File: .\craps\bets\pass_line_odds.py

from ..bets import Bet  # Import the base Bet class

class PassLineOddsBet(Bet):
    """Class representing a Pass Line Odds bet."""
    def __init__(self, amount, owner):
        super().__init__("Pass Line Odds", amount, owner, payout_ratio=(1, 1), locked=False)

    def resolve(self, outcome, game_state):
        """Resolve the Pass Line Odds bet based on the dice outcome and game state."""
        total = sum(outcome)
        
        if game_state.phase == "point":
            if total == game_state.point:
                # Determine the payout ratio based on the point
                if game_state.point in [4, 10]:
                    self.payout_ratio = (2, 1)  # 2:1 payout for 4 and 10
                elif game_state.point in [5, 9]:
                    self.payout_ratio = (3, 2)  # 3:2 payout for 5 and 9
                elif game_state.point in [6, 8]:
                    self.payout_ratio = (6, 5)  # 6:5 payout for 6 and 8
                self.status = "won"  # Pass Line Odds bet wins
            elif total == 7:
                self.status = "lost"  # Pass Line Odds bet loses
            else:
                # Bet remains active
                self.status = "active"

# File: .\craps\bets\place_bet.py

# File: .\craps\bets\place_bet.py

from ..bets import Bet  # Import the base Bet class

class PlaceBet(Bet):
    """Class representing a Place bet."""
    def __init__(self, amount, owner, number):
        """
        Initialize a Place bet.
        
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param number: The number being bet on (4, 5, 6, 8, 9, or 10).
        """
        super().__init__(f"Place {number}", amount, owner, locked=False)
        self.number = number

    def resolve(self, outcome, game_state):
        """Resolve the Place bet based on the dice outcome and game state."""
        total = sum(outcome)
        
        if total == self.number:
            # Determine the payout ratio based on the number
            if self.number in [4, 10]:
                self.payout_ratio = (9, 5)  # 9:5 payout for 4 and 10
            elif self.number in [5, 9]:
                self.payout_ratio = (7, 5)  # 7:5 payout for 5 and 9
            elif self.number in [6, 8]:
                self.payout_ratio = (7, 6)  # 7:6 payout for 6 and 8
            self.status = "won"  # Place bet wins
        elif total == 7:
            self.status = "lost"  # Place bet loses
        else:
            # Bet remains active
            self.status = "active"

# File: .\craps\bets\__init__.py

# File: .\craps\bets\__init__.py

class Bet:
    """Base class for all bet types."""
    def __init__(self, bet_type, amount, owner, payout_ratio=(1, 1), locked=True, vig=0):
        """
        Initialize a bet.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Come").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param payout_ratio: The payout ratio as a tuple (numerator, denominator).
        :param locked: Whether the bet is locked (cannot be taken down).
        :param vig: The vig (commission) as a percentage of the bet amount.
        """
        self.bet_type = bet_type
        self.amount = amount
        self.owner = owner
        self.payout_ratio = payout_ratio
        self.locked = locked
        self.vig = vig
        self.status = "active"  # Can be "active", "won", "lost", or "pushed"

    def resolve(self, outcome, game_state):
        """
        Resolve the bet based on the dice outcome and game state.
        
        :param outcome: The result of the dice roll (e.g., [3, 4]).
        :param game_state: The current state of the game (e.g., come-out phase, point phase).
        """
        raise NotImplementedError("Subclasses must implement this method.")

    def payout(self):
        """
        Calculate the payout for the bet, including the vig (if applicable).
        
        :return: The payout amount.
        """
        if self.status != "won":
            return 0
        
        # Calculate the payout based on the payout ratio
        numerator, denominator = self.payout_ratio
        payout = self.amount * numerator // denominator
        
        # Deduct the vig (if applicable)
        if self.vig > 0:
            vig_amount = self.amount * self.vig // 100
            payout -= vig_amount
        
        return payout

    def is_resolved(self):
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def __str__(self):
        return f"{self.owner}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"

# File: .\craps\strategies\pass_line.py

# File: .\craps\strategies\pass_line.py

from craps.bets.pass_line import PassLineBet  # Import the PassLineBet class

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                # print(f"{player.name} already has an active Pass Line bet.")
                return None  # No new bet to place

            # Place a new Pass Line bet
            return PassLineBet(self.min_bet, player.name)  # Use PassLineBet instead of Bet
        return None  # No bet to place

# File: .\craps\strategies\pass_line_odds.py

# File: .\craps\strategies\pass_line_odds.py

from craps.bets.pass_line import PassLineBet
from craps.bets.pass_line_odds import PassLineOddsBet

class PassLineOddsStrategy:
    """Betting strategy for Pass Line with Odds bets."""
    def __init__(self, min_bet, odds_multiple=1):
        self.min_bet = min_bet
        self.odds_multiple = odds_multiple

    def get_bet(self, game_state, player):
        """Place a Pass Line or Pass Line Odds bet based on the game state."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                # print(f"{player.name} already has an active Pass Line bet.")
                return None  # No new bet to place

            # Place a new Pass Line bet
            return PassLineBet(self.min_bet, player.name)
        
        elif game_state.phase == "point":
            # Check if the player already has an active Pass Line Odds bet
            if any(b.bet_type == "Pass Line Odds" for b in player.active_bets):
                # print(f"{player.name} already has an active Pass Line Odds bet.")
                return None  # No new bet to place

            # Place a new Pass Line Odds bet
            return PassLineOddsBet(self.min_bet * self.odds_multiple, player.name)
        
        return None  # No bet to place

# File: .\craps\strategies\place_bet.py

# File: .\craps\strategies\place_bet.py

from craps.bets.place_bet import PlaceBet

class PlaceBetStrategy:
    """Betting strategy for Place Bets."""
    def __init__(self, table, numbers_or_strategy):
        """
        Initialize the Place Bet strategy.
        
        :param table: The table object to determine minimum bets.
        :param numbers_or_strategy: A list of numbers (e.g., [5, 6, 8, 9]) or a strategy ("inside", "across").
        """
        self.table = table
        self.numbers_or_strategy = numbers_or_strategy

    def get_bet(self, game_state, player):
        """Place Place Bets based on the strategy and game state."""
        if game_state.phase != "point":
            return None  # Only place bets after the point is established

        # Determine which numbers to bet on
        if isinstance(self.numbers_or_strategy, str):
            if self.numbers_or_strategy == "inside":
                numbers = [5, 6, 8, 9]  # Inside numbers
            elif self.numbers_or_strategy == "across":
                numbers = [4, 5, 6, 8, 9, 10]  # Across numbers
            else:
                raise ValueError(f"Invalid strategy: {self.numbers_or_strategy}")
        else:
            numbers = self.numbers_or_strategy  # Specific numbers provided

        # Filter out numbers already covered by a Pass Line bet or a Place bet
        numbers = [
            num for num in numbers
            if not any(
                (b.bet_type == "Pass Line" and b.point == num) or  # Pass Line covers the point
                (b.bet_type.startswith("Place") and b.number == num)  # Place Bet covers the number
                for b in player.active_bets
            )
        ]

        # Place bets on the remaining numbers
        bets = []
        for number in numbers:
            min_bet = self.table.get_minimum_bet(number)
            bets.append(PlaceBet(min_bet, player.name, number))

        return bets if bets else None

# File: .\tests\test_dice.py

import unittest
from craps.dice import Dice

class TestDice(unittest.TestCase):
    def test_roll(self):
        dice = Dice()
        for _ in range(100):  # Test 100 rolls
            outcome = dice.roll()
            self.assertIsInstance(outcome, list)
            self.assertEqual(len(outcome), 2)
            self.assertTrue(1 <= outcome[0] <= 6)
            self.assertTrue(1 <= outcome[1] <= 6)
            total = sum(outcome)
            self.assertTrue(2 <= total <= 12)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_player.py

import unittest
from craps.player import Player
from craps.table import Table
from craps.bet import Bet

class TestPlayer(unittest.TestCase):
    def test_place_bet(self):
        player = Player("Alice", 1000)
        table = Table()
        player.place_bet("Pass Line", 100, table)
        self.assertEqual(player.balance, 900)
        self.assertEqual(len(player.bets), 1)
        self.assertEqual(len(table.bets), 1)

    def test_resolve_bets(self):
        player = Player("Alice", 1000)
        table = Table()
        bet = Bet("Pass Line", 100, "Alice")
        table.place_bet(bet)
        player.bets.append(bet)

        # Simulate a win
        bet.status = "won"
        player.resolve_bets(table)
        self.assertEqual(player.balance, 1100)
        self.assertEqual(len(player.bets), 0)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_puck.py

import unittest
from craps.puck import Puck

class TestPuck(unittest.TestCase):
    def test_puck(self):
        puck = Puck()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

        puck.set_point(4)
        self.assertEqual(puck.position, "On")
        self.assertEqual(puck.point, 4)

        puck.reset()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_shooter.py

import unittest
from craps.shooter import Shooter

class TestShooter(unittest.TestCase):
    def test_roll_dice(self):
        shooter = Shooter("Alice")
        outcome = shooter.roll_dice()
        self.assertIsInstance(outcome, list)
        self.assertEqual(len(outcome), 2)
        self.assertTrue(1 <= outcome[0] <= 6)
        self.assertTrue(1 <= outcome[1] <= 6)

if __name__ == "__main__":
    unittest.main()

