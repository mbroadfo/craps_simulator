# File: .\config.py

# File: .\config.py

ACTIVE_PLAYERS = {
    "Pass-Line": False,
    "Pass-Line w/ Odds": True,
    "$44 Inside": False,
    "$54 Across": False,
    "Field": False,
    "Iron Cross": True,
    "3-Point Molly": True,
}

# Add a new configuration entry for session mode
SESSION_MODE = "live"  # Options: "live" or "history"

# House Rules Configuration
HOUSE_RULES = {
    "field_bet_payout_2": (2, 1),  # 2:1 payout for 2
    "field_bet_payout_12": (3, 1),  # 3:1 payout for 12
    "table_minimum": 10,  # Minimum bet amount
    "table_maximum": 5000,  # Maximum bet amount
    "come_odds_working_on_come_out": False,  # Whether Come odds bets are working during the come-out roll
}


# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.py'):  # Only process Python files
                    file_path = os.path.join(root, file)
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory (change as needed)
output_file = 'combined_files.txt'

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")

# File: .\main.py

# File: .\main.py

from colorama import init, Fore, Style
from config import ACTIVE_PLAYERS, SESSION_MODE, HOUSE_RULES
from craps.session_initializer import InitializeSession
from craps.player_setup import SetupPlayers
from craps.single_session import run_single_session
from craps.visualizer import Visualizer
from craps.view_log import InteractiveLogViewer

def main():
    init()  # Initialize colorama for colored text

    # Initialize the session
    session_initializer = InitializeSession(SESSION_MODE, HOUSE_RULES)
    result = session_initializer.prepare_session()
    if not result:
        return  # Exit if session initialization fails

    house_rules, table, roll_history_manager, log_manager, play_by_play = result

    # Set up players
    player_setup = SetupPlayers(house_rules, table, ACTIVE_PLAYERS)
    strategies, player_names = player_setup.setup()

    # Get the roll history file based on the session mode
    roll_history_file = roll_history_manager.get_roll_history_file(SESSION_MODE)

    # Run the session
    stats = run_single_session(
        house_rules,
        strategies,
        player_names=player_names,
        roll_history_file=roll_history_file,
        play_by_play=play_by_play
    )

    # Save the roll history if running in live mode
    if SESSION_MODE == "live":
        roll_history_manager.save_roll_history(stats.roll_history)

    # Print statistics
    stats.print_statistics()
    stats.print_shooter_report()
    stats.print_player_statistics()
    
    # View the log file interactively
    log_viewer = InteractiveLogViewer()
    log_viewer.view(play_by_play.play_by_play_file)
    
    # Visualize player bankrolls
    visualizer = Visualizer(stats)
    visualizer.visualize_bankrolls()

if __name__ == "__main__":
    main()

# File: .\setup.py

from setuptools import setup, find_packages

setup(
    name="craps_simulator",
    version="0.1",
    packages=find_packages(),
)

# File: .\craps\bet.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, List, Optional, Tuple
import logging

if TYPE_CHECKING:
    from craps.player import Player  # Prevent circular imports
    from craps.rules_engine import RulesEngine  # Ensure correct type hint for resolve method

class Bet:
    """Represents a single bet in the game of Craps."""

    VALID_PHASES: List[str] = ["come-out", "point"]  # Ensures class-level definition

    def __init__(
        self,
        bet_type: str,
        amount: int,
        owner: Player,
        payout_ratio: Tuple[int, int],  # Updated to a tuple
        locked: bool = False,
        vig: bool = False,  # Updated to a boolean
        unit: int = 1,
        valid_phases: Optional[List[str]] = None,
        number: Optional[int] = None,
        parent_bet: Optional[Bet] = None,
        is_contract_bet: bool = False
    ) -> None:
        """
        Initializes a Bet.

        :param bet_type: Type of bet (e.g., "Pass Line", "Come", "Place 6").
        :param amount: Amount wagered.
        :param owner: The player who owns the bet.
        :param payout_ratio: Multiplier for payouts as a tuple (e.g., (3, 2) for 3:2 odds).
        :param locked: Whether the bet is locked and cannot be removed.
        :param vig: Whether the bet has a vigorish (commission).
        :param unit: Minimum bet unit.
        :param valid_phases: Game phases where this bet is valid.
        :param number: The number associated with the bet (if applicable).
        :param parent_bet: Reference to the original bet (for odds bets).
        :param is_contract_bet: Whether the bet is a contract bet (cannot be removed).
        """
        self.bet_type: str = bet_type
        self.amount: int = amount
        self.owner: Player = owner
        self.payout_ratio: Tuple[int, int] = payout_ratio  # Ensuring payout is stored as a ratio tuple
        self.locked: bool = locked
        self.vig: bool = vig  # Vig is now a boolean
        self.unit: int = unit
        self.valid_phases: List[str] = valid_phases if valid_phases is not None else self.VALID_PHASES
        self.number: Optional[int] = number
        self.status: str = "active"
        self.parent_bet: Optional[Bet] = parent_bet
        self.is_contract_bet: bool = is_contract_bet  # Whether the bet is a contract bet

    def validate_bet(self, phase: str, table_minimum: int, table_maximum: int) -> bool:
        """
        Validate the bet based on the game phase, table limits, and bet type.

        :param phase: The current game phase ("come-out" or "point").
        :param table_minimum: The table's minimum bet amount.
        :param table_maximum: The table's maximum bet amount.
        :return: True if the bet is valid, False otherwise.
        """
        # Check if the bet can be placed during the current phase
        if phase not in self.valid_phases:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet cannot be placed during the {phase} phase.")
            return False

        # Check if the bet amount is within table limits
        if self.amount < table_minimum:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} is below the table minimum of ${table_minimum}.")
            return False
        if self.amount > table_maximum:
            logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} exceeds the table maximum of ${table_maximum}.")
            return False

        # Check if the bet amount is valid for the bet type
        if self.bet_type in ["Place", "Buy"]:
            if self.amount % self.unit != 0:
                logging.warning(f"{self.owner.name}'s {self.bet_type} bet amount ${self.amount} must be a multiple of ${self.unit}.")
                return False

        return True

    def resolve(self, rules_engine: RulesEngine, dice_outcome: Tuple[int, int], phase: str, point: Optional[int]) -> None:
        """
        Resolve the bet based on the dice outcome, phase, and point.
        Delegates resolution logic to the RulesEngine.

        :param rules_engine: The RulesEngine instance to use for resolution.
        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        rules_engine.resolve_bet(self, dice_outcome, phase, point)

    def is_resolved(self) -> bool:
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def payout(self) -> int:
        """
        Calculate the payout for the bet.
        - Contract bets return original bet amount + winnings.
        - Non-contract bets return only winnings.
        """
        if self.status != "won":
            return 0  # No payout if the bet was lost

        numerator, denominator = self.payout_ratio
        profit = (self.amount * numerator) // denominator

        return self.amount + profit if self.is_contract_bet else profit

    def __str__(self) -> str:
        """Return a string representation of the bet."""
        if self.number is not None:
            return f"{self.owner.name}'s ${self.amount} {self.bet_type} {self.number} bet (Status: {self.status})"
        else:
            return f"{self.owner.name}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"


# File: .\craps\common.py

from typing import Optional, List, Tuple
from craps.house_rules import HouseRules
from craps.table import Table
from craps.play_by_play import PlayByPlay
from craps.rules_engine import RulesEngine
from craps.player import Player
from craps.dice import Dice
from craps.statistics import Statistics
from craps.bet import Bet
from craps.session_initializer import InitializeSession

class CommonTableSetup:
    """Common setup for all craps tests, now using InitializeSession for consistency."""

    def __init__(self) -> None:
        """Initialize the table, players, and other components for testing."""

        # âœ… InitializeSession 
        self.rules_engine = RulesEngine()
        self.play_by_play = PlayByPlay()

        session_initializer = InitializeSession(
            session_mode="test",
            house_rules_config={"table_minimum": 10, "table_maximum": 5000},
            play_by_play=self.play_by_play,
            rules_engine=self.rules_engine,
            log_manager=None  # Tests likely donâ€™t need full logging
        )

        session_data = session_initializer.prepare_session(num_shooters=10, num_players=1)

        if session_data is None:
            raise RuntimeError("Failed to initialize common test session.")

        self.house_rules, self.table, self.roll_history_manager, _, self.play_by_play, self.stats, self.game_state = session_data

        # âœ… Setup Player
        self.player_name = "Alice"
        self.initial_balance = 1000
        self.player = Player(self.player_name, self.initial_balance)

        # âœ… Setup Gamestate
        self.game_state.set_table(self.table)

    def place_bet(self, bet_type: str, amount: int, phase: str = "come-out", number: Optional[int] = None) -> Bet:
        """
        Place a bet on the table for the player.

        :param bet_type: The type of bet (e.g., "Field", "Pass Line").
        :param amount: The amount of the bet.
        :param phase: The current game phase ("come-out" or "point").
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :return: The created bet.
        """
        if bet_type == "Come Odds":
            come_bet = next(
                (bet for bet in self.table.bets if bet.bet_type == "Come" and bet.owner == self.player), None
            )
            if come_bet is None or come_bet.number is None:
                raise ValueError("Cannot place Come Odds bet without an active Come bet with a number.")
            number = come_bet.number

        bet = self.rules_engine.create_bet(bet_type, amount, self.player, number=number)
        self.table.place_bet(bet, phase)
        return bet

    def simulate_roll(self, dice_outcome: Tuple[int, int], phase: str = "come-out", point: Optional[int] = None) -> List[Bet]:
        """
        Simulate a dice roll and resolve bets on the table.

        :param dice_outcome: The result of the dice roll (e.g., (3, 4)).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        :return: A list of resolved bets.
        """
        self.table.check_bets(dice_outcome, phase, point)
        return self.table.clear_resolved_bets()

    def reset_table(self) -> None:
        """Reset the table and player for a new test."""
        self.table.bets = []  # Clear all bets
        self.player.balance = self.initial_balance  # Reset player balance


# File: .\craps\dice.py

import csv
import random
import os
from typing import Optional, List, Dict, Tuple, cast

class Dice:
    def __init__(self, roll_history_file: Optional[str] = None) -> None:
        """
        Initialize the Dice class.
        
        :param roll_history_file: Path to a CSV file containing roll history. If None, rolls are random.
        """
        self.values: Tuple[int, int] = (1, 1)  # Ensure this is a fixed-size tuple
        self.roll_history_file: Optional[str] = roll_history_file
        self.roll_history: List[Dict[str, int | Tuple[int, int]]] = []
        self.current_roll_index: int = 0

        if self.roll_history_file:
            self._load_roll_history()

    def _load_roll_history(self) -> None:
        """Load roll history from a CSV file."""
        if not self.roll_history_file:
            return  # Prevent passing None to open()

        if not os.path.exists(self.roll_history_file):
            raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found.")

        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to proper types
                dice_list = row["dice"].strip('[]').split(', ')
                if len(dice_list) != 2:
                    raise ValueError(f"Invalid dice format in roll history: {row['dice']}")
                
                dice: Tuple[int, int] = (int(dice_list[0]), int(dice_list[1]))  # Ensure exactly two values
                total: int = int(row["total"])
                shooter_num: int = int(row["shooter_num"])
                self.roll_history.append({
                    "dice": dice,
                    "total": total,
                    "shooter_num": shooter_num
                })

    def roll(self) -> Tuple[int, int]:
        """Roll the dice. If roll history is loaded, use the next roll from the history."""
        if self.roll_history:
            if self.current_roll_index >= len(self.roll_history):
                raise IndexError("No more rolls in the history.")
            roll = self.roll_history[self.current_roll_index]
            dice = cast(Tuple[int, int], roll["dice"])
            if len(dice) != 2:
                raise ValueError(f"Invalid dice format in roll history: {roll['dice']}")

            self.values = dice  # Ensure it's a valid (int, int) tuple
            self.current_roll_index += 1
        else:
            # Generate random rolls if no history is loaded
            self.values = (random.randint(1, 6), random.randint(1, 6))  # Ensure it's a tuple
        
        return self.values


# File: .\craps\game_state.py

from typing import List, Optional, Any, Tuple
from colorama import Fore, Style
from craps.player import Player

class GameState:
    def __init__(self, stats: Any, play_by_play: Optional[Any] = None) -> None:
        """
        Initialize the game state.

        :param stats: The Statistics object for recording game data.
        :param play_by_play: The PlayByPlay instance for logging messages.
        """
        self._point: Optional[int] = None  # Encapsulated point
        self.previous_point: Optional[int] = None  # Track the last point before changes
        self.stats = stats
        self.play_by_play = play_by_play
        self.shooter: Optional[Player] = None  # Store current shooter (now a Player)

    def set_table(self, table: Any) -> None:
        """Set the table reference."""
        self.table = table

    def assign_new_shooter(self, shooter: Player) -> None:
        """
        Assigns a new shooter and resets their stats.

        :param shooter: The new shooter for the game.
        """
        self.shooter = shooter
        self.shooter.is_shooter = True  # Mark player as the shooter
        if self.play_by_play:
            self.play_by_play.write(f"ðŸŽ² New shooter: {self.shooter.name} steps up!")

    def clear_shooter(self) -> None:
        """
        Clears the current shooter when a new shooter is needed.
        """
        if self.shooter:
            self.shooter.is_shooter = False
        self.shooter = None

    @property
    def point(self) -> Optional[int]:
        """Get the current point."""
        return self._point

    @point.setter
    def point(self, value: Optional[int]) -> None:
        """Set the point while tracking the previous point."""
        if self._point != value:
            self.previous_point = self._point  # Store previous point before change
            self._point = value  # Update point
            if self.play_by_play:
                self.play_by_play.write(f"GameState: Point changed from {self.previous_point} to {self._point}")

    @property
    def phase(self) -> str:
        """Determine the game phase based on whether a point is set."""
        return "point" if self._point else "come-out"

    @property
    def puck_on(self) -> bool:
        """Check if the puck should be 'ON' (point is set)."""
        return self._point is not None

    def update_state(self, dice_outcome: Tuple[int, int]) -> str:
        """
        Update the game state based on the dice outcome.

        :param dice_outcome: The result of the dice roll (e.g., (3, 4)).
        :return: A message describing the state change.
        """
        total = sum(dice_outcome)
        message = "No change in game state."

        if self.phase == "come-out":
            if total in [7, 11]:  # Natural win
                self.point = None  # Reset to come-out phase
                message = f"{Fore.GREEN}âœ… 7-Winner: Pass Line bets win! Puck is OFF.{Style.RESET_ALL}"
            elif total in [2, 3, 12]:  # Craps loss
                self.point = None  # Stay in come-out phase
                message = f"{Fore.RED}âŒ Craps: Pass Line bets lose! Puck is OFF.{Style.RESET_ALL}"
            else:  # Set the point
                self.point = total
                message = f"{Fore.YELLOW}Point Set: {total}. Puck is ON.{Style.RESET_ALL}"
        else:  # Point phase
            if total == self.point:  # Point hit, pass line wins
                self.stats.record_point_number_roll()
                self.point = None  # Reset back to come-out
                message = f"{Fore.GREEN}âœ… Point Hit: {total}. Pass Line bets win! Puck is OFF.{Style.RESET_ALL}"
            elif total == 7:  # Seven out, pass line loses
                self.stats.record_seven_out()
                self.point = None  # Reset back to come-out
                message = f"{Fore.RED}âŒ 7-Out: Pass Line bets lose! Puck is OFF.{Style.RESET_ALL}"

        if self.play_by_play:
            self.play_by_play.write(message)

        return message


# File: .\craps\house_rules.py

from typing import Any

class HouseRules:
    """Class representing house rules for payouts and table limits."""

    def __init__(self, config: dict[str, Any]) -> None:
        """
        Initialize the HouseRules with configuration from config.py.

        :param config: A dictionary containing house rules configuration.
        """
        self.table_minimum: int = config.get("table_minimum", 10)  # Default to $10
        self.table_maximum: int = config.get("table_maximum", 5000)  # Default to $5000

    def set_table_limits(self, minimum: int, maximum: int) -> None:
        """Set the table limits."""
        self.table_minimum = minimum
        self.table_maximum = maximum


# File: .\craps\lineup.py

# File: .\craps\lineup.py

from typing import Dict, Tuple, List, Any
from .strategies.pass_line_strategy import PassLineStrategy
from .strategies.pass_line_odds_strategy import PassLineOddsStrategy
from .strategies.place_strategy import PlaceBetStrategy
from .strategies.field_strategy import FieldBetStrategy
from .strategies.iron_cross_strategy import IronCrossStrategy
from .strategies.three_point_molly_strategy import ThreePointMollyStrategy
from .rules_engine import RulesEngine

class PlayerLineup:
    """Class to manage the lineup of players and their strategies."""
    
    def __init__(self, house_rules: Any, table: Any, play_by_play: Any, rules_engine: RulesEngine) -> None:
        """
        Initialize the player lineup.

        :param house_rules: The HouseRules object for table limits and payouts.
        :param table: The Table object for placing bets.
        :param play_by_play: The PlayByPlay instance for logging game actions.
        :param rules_engine: The RulesEngine instance for bet validation.
        """
        self.house_rules = house_rules
        self.table = table
        self.play_by_play = play_by_play
        self.rules_engine = rules_engine

        # Define all possible strategies and their names
        self.all_strategies: Dict[str, Any] = {
            "Pass-Line": PassLineStrategy(min_bet=self.house_rules.table_minimum),  # âŒ NO rules_engine
            "Pass-Line w/ Odds": PassLineOddsStrategy(table=self.table, odds_multiple=1, rules_engine=self.rules_engine),  # âœ…
            "$44 Inside": PlaceBetStrategy(table=self.table, numbers_or_strategy="inside", rules_engine=self.rules_engine),  # âœ…
            "$54 Across": PlaceBetStrategy(table=self.table, numbers_or_strategy="across", rules_engine=self.rules_engine),  # âœ…
            "Field": FieldBetStrategy(min_bet=self.house_rules.table_minimum),  # âŒ NO rules_engine
            "Iron Cross": IronCrossStrategy(
                table=self.table, min_bet=self.house_rules.table_minimum, play_by_play=self.play_by_play, rules_engine=self.rules_engine
            ),  # âœ…
            "3-Point Molly": ThreePointMollyStrategy(
                table=self.table, min_bet=self.house_rules.table_minimum, odds_multiple=1, rules_engine=self.rules_engine
            )  # âœ…
        }

    def get_active_players(self, active_players_config: Dict[str, bool]) -> Tuple[List[Any], List[str]]:
        """
        Get the list of active strategies and player names based on the configuration.
        
        :param active_players_config: A dictionary specifying which players are active.
        :return: A tuple of (strategies, player_names).
        """
        strategies: List[Any] = [
            strategy for name, strategy in self.all_strategies.items() if active_players_config.get(name, False)
        ]
        player_names: List[str] = [
            name for name, active in active_players_config.items() if active
        ]
        return strategies, player_names


# File: .\craps\log_manager.py

import os
import logging

class LogManager:
    """Handles log file management."""

    def __init__(self, output_folder: str = "output", log_file: str = "simulation.log") -> None:
        """
        Initialize the LogManager.

        :param output_folder: The directory where log files will be stored.
        :param log_file: The name of the log file.
        """
        self.output_folder: str = output_folder
        self.log_file: str = os.path.join(output_folder, log_file)
        self.ensure_output_folder_exists()
        self.configure_logging()

    def ensure_output_folder_exists(self) -> None:
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def configure_logging(self) -> None:
        """Set up logging to write to the log file."""
        logging.basicConfig(
            filename=self.log_file,
            level=logging.INFO,
            format="%(asctime)s - %(levelname)s - %(message)s",
        )

    def delete_log_file(self) -> None:
        """Delete the log file if it exists."""
        if os.path.exists(self.log_file):
            os.remove(self.log_file)


# File: .\craps\player.py

from colorama import Fore, Style
from typing import List, Union, Optional, Any, Tuple
from craps.bet import Bet
from craps.table import Table
from craps.play_by_play import PlayByPlay
import random

class Player:
    def __init__(self, name: str, initial_balance: int = 500, betting_strategy: Optional[Any] = None):
        """
        Initialize a player.

        :param name: The name of the player.
        :param initial_balance: The initial bankroll of the player.
        :param betting_strategy: The betting strategy used by the player.
        """
        self.name: str = name
        self.balance: int = initial_balance
        self.betting_strategy: Any = betting_strategy
        self.is_shooter: bool = False

    def place_bet(self, bet: Union[Bet, List[Bet]], table: Table, phase: str, play_by_play: PlayByPlay) -> bool:
        """
        Place a bet (or multiple bets) on the table and deduct the amount from the player's balance.

        :param bet: The bet(s) to place.
        :param table: The table to place the bet on.
        :param phase: The current game phase ("come-out" or "point").
        :param play_by_play: The PlayByPlay instance for logging messages.
        :return: True if the bet(s) were placed successfully, False otherwise.
        """
        bets: List[Bet] = [bet] if not isinstance(bet, list) else bet

        for b in bets:
            if hasattr(b, 'parent_bet') and b.parent_bet is not None:
                if b.parent_bet.owner != self:
                    raise ValueError("Cannot place odds bet on another player's bet")
                if not table.has_bet(b.parent_bet):
                    raise ValueError("Parent bet must be on the table before placing odds")

        total_amount: int = sum(b.amount for b in bets)

        if total_amount > self.balance:
            message: str = f"{Fore.RED}âŒ {self.name} has insufficient funds to place ${total_amount} in bets.{Style.RESET_ALL}"
            if play_by_play:
                play_by_play.write(message)
            return False

        for b in bets:
            if not table.place_bet(b, phase):
                message = f"{Fore.RED}âŒ Failed to place {b.bet_type} bet for {self.name}.{Style.RESET_ALL}"
                if play_by_play:
                    play_by_play.write(message)
                return False

            message = f"{Fore.GREEN}âœ… {self.name} placed a ${b.amount} {b.bet_type} bet. Bankroll: ${self.balance}.{Style.RESET_ALL}"
            if play_by_play:
                play_by_play.write(message)

        return True

    def receive_payout(self, payout: int, play_by_play: PlayByPlay) -> None:
        """
        Add the payout amount to the player's bankroll.

        :param payout: The payout amount.
        """
        self.balance += payout
        message: str = f"{Fore.GREEN}âœ… {self.name} received a payout of ${payout}. Bankroll: ${self.balance}.{Style.RESET_ALL}"
        if play_by_play:
            play_by_play.write(message)

    def has_active_bet(self, table: Table, bet_type: str, number: Optional[int] = None) -> bool:
        """
        Check if the player has an active bet of a specific type and number on the table.

        :param table: The table to check for active bets.
        :param bet_type: The type of bet to check for (e.g., "Pass Line", "Place").
        :param number: The number associated with the bet (e.g., 6 for Place 6).
        :return: True if the player has an active bet of the specified type and number, False otherwise.
        """
        return any(
            bet.owner == self and bet.bet_type == bet_type and (number is None or bet.number == number)
            for bet in table.bets
        )

    def roll_dice(self) -> Tuple[int, int]:
        """
        Roll the dice if this player is the shooter.

        :return: A tuple representing the dice roll (e.g., (3, 4)).
        """
        if self.is_shooter:
            return random.randint(1, 6), random.randint(1, 6)
        else:
            raise ValueError(f"{self.name} is not the shooter and cannot roll dice.")

    def reset_shooter(self) -> None:
        """
        Reset the shooter status when a new round begins.
        """
        self.is_shooter = False


# File: .\craps\player_setup.py

from typing import Tuple, List, Any, Dict
from craps.lineup import PlayerLineup
from craps.rules_engine import RulesEngine
from craps.play_by_play import PlayByPlay

class SetupPlayers:
    def __init__(self, house_rules: Any, table: Any, active_players_config: Dict[str, bool], play_by_play: PlayByPlay, rules_engine: RulesEngine) -> None:
        """
        Initialize player setup.

        :param house_rules: The HouseRules object for table limits and payouts.
        :param table: The Table object for placing bets.
        :param active_players_config: A dictionary specifying which players are active.
        :param play_by_play: The PlayByPlay instance for writing play-by-play messages.
        :param rules_engine: The RulesEngine instance to use for bet creation.
        """
        self.house_rules = house_rules
        self.table = table
        self.active_players_config = active_players_config
        self.play_by_play = play_by_play
        self.rules_engine = rules_engine

    def setup(self) -> Tuple[List[Any], List[str]]:
        """
        Set up the players and their strategies.

        :return: A tuple of (strategies, player_names).
        """
        player_lineup = PlayerLineup(self.house_rules, self.table, self.play_by_play, self.rules_engine)
        strategies, player_names = player_lineup.get_active_players(self.active_players_config)
        return strategies, player_names


# File: .\craps\play_by_play.py

import os
import logging
from typing import Optional

class PlayByPlay:
    def __init__(self, output_folder: str = "output", play_by_play_file: str = "play_by_play.txt") -> None:
        """
        Initialize the PlayByPlay writer.

        :param output_folder: The folder where the play-by-play file will be saved.
        :param play_by_play_file: The name of the play-by-play file.
        """
        self.output_folder: str = output_folder
        self.play_by_play_file: str = os.path.join(output_folder, play_by_play_file)
        self.ensure_output_folder_exists()

    def ensure_output_folder_exists(self) -> None:
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def write(self, message: str) -> None:
        """
        Write a pre-formatted message (with embedded Colorama colors) to the play-by-play file.

        :param message: The message to write.
        """
        with open(self.play_by_play_file, "a", encoding="utf-8") as file:
            file.write(message + "\n")

    def clear_play_by_play_file(self) -> None:
        """Clear the play-by-play file if it exists."""
        if os.path.exists(self.play_by_play_file):
            # Ensure the file is closed before attempting to delete it
            for handler in logging.root.handlers[:]:
                handler.close()
                logging.root.removeHandler(handler)
            os.remove(self.play_by_play_file)
            print(f"Deleted existing play-by-play file: {self.play_by_play_file}")


# File: .\craps\roll_history_manager.py

import os
import csv
from typing import List, Dict, Any, Optional

class RollHistoryManager:
    def __init__(self, output_folder: str = "output", roll_history_file: str = "single_session_roll_history.csv") -> None:
        self.output_folder: str = output_folder
        self.roll_history_file: str = os.path.join(output_folder, roll_history_file)

    def ensure_output_folder_exists(self) -> None:
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def delete_roll_history_file(self) -> None:
        """Delete the roll history file if it exists."""
        if os.path.exists(self.roll_history_file):
            os.remove(self.roll_history_file)
            print(f"Deleted existing roll history file: {self.roll_history_file}")

    def save_roll_history(self, roll_history: List[Dict[str, Any]]) -> None:
        """
        Save the roll history to a CSV file.

        :param roll_history: A list of dictionaries representing the roll history.
        """
        self.ensure_output_folder_exists()
        with open(self.roll_history_file, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ["shooter_num", "roll_number", "dice", "total", "phase", "point"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            # Write the header
            writer.writeheader()

            # Write the roll history
            for roll in roll_history:
                writer.writerow(roll)

        print(f"Roll history saved to: {self.roll_history_file}")

    def load_roll_history(self) -> List[Dict[str, Any]]:
        """
        Load the roll history from a CSV file.

        :return: A list of dictionaries representing the roll history.
        """
        if not os.path.exists(self.roll_history_file):
            raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found.")

        roll_history: List[Dict[str, Any]] = []
        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to integers
                row["roll_number"] = int(row["roll_number"])
                row["shooter_num"] = int(row["shooter_num"])
                row["dice"] = [int(die) for die in row["dice"].strip('[]').split(', ')]
                row["total"] = int(row["total"])
                roll_history.append(row)

        print(f"Roll history loaded from: {self.roll_history_file}")
        return roll_history

    def prepare_for_session(self, session_mode: str) -> None:
        """
        Prepare for the session based on the session mode.

        :param session_mode: The session mode ("live" or "history").
        :raises FileNotFoundError: If the roll history file is missing in history mode.
        """
        self.validate_session_mode(session_mode)
        self.ensure_output_folder_exists()

        if session_mode == "live":
            self.delete_roll_history_file()
            print("Running session in 'live' mode with random rolls.")
        elif session_mode == "history":
            if not os.path.exists(self.roll_history_file):
                raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found. Please run in 'live' mode first.")
            print(f"Running session in 'history' mode using roll history from: {self.roll_history_file}")

    def validate_session_mode(self, session_mode: str) -> None:
        """
        Validate the session mode.

        :param session_mode: The session mode ("live" or "history").
        :raises ValueError: If the session mode is invalid.
        """
        if session_mode not in ["live", "history"]:
            raise ValueError(f"Invalid SESSION_MODE '{session_mode}'. Must be 'live' or 'history'.")

    def get_roll_history_file(self, session_mode: str) -> Optional[str]:
        """
        Get the roll history file based on the session mode.

        :param session_mode: The session mode ("live" or "history").
        :return: The roll history file path if in "history" mode, otherwise None.
        """
        return self.roll_history_file if session_mode == "history" else None


# File: .\craps\rules.py

from typing import Tuple, Optional

# ================================
# Bet Rules (Grouped by Category)
# ================================
BET_RULES = {
    "Line Bets": {
        "is_contract_bet": True,
        "valid_numbers": None,
        "Pass Line": {
            "linked_bet": "Pass Line Odds",
            "valid_phases": ["come-out"],
            "payout_ratio": "Even Money",
            "resolution": {
                "come_out_win": [7, 11],
                "come_out_lose": [2, 3, 12],
                "point_win": ["point_made"],
                "point_lose": [7]
            },
        },
        "Don't Pass": {
            "linked_bet": "Don't Pass Odds",
            "valid_phases": ["come-out"],
            "payout_ratio": "Even Money",
            "resolution": {
                "come_out_win": [2, 3],
                "come_out_lose": [7, 11],
                "point_win": [7],
                "point_lose": ["point_made"]
            },
        },
        "Come": {
            "linked_bet": "Come Odds",
            "valid_phases": ["point"],
            "payout_ratio": "Even Money",
            "resolution": {
                "come_out_win": [7, 11],
                "come_out_lose": [2, 3, 12],
                "point_win": ["number_hit"],
                "point_lose": [7],
                "moves_on_roll": True,
            }
        },
        "Don't Come": {
            "linked_bet": "Don't Come Odds",
            "valid_phases": ["point"],
            "payout_ratio": "Even Money",
            "resolution": {
                "come_out_win": [2, 3],
                "come_out_lose": [7, 11],
                "point_win": [7],
                "point_lose": ["number_hit"],
                "moves_on_roll": True,
            }
        },    },
    "Odds Bets": {
        "is_contract_bet": False,
        "valid_numbers": None,
        "Pass Line Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "True Odds",
            "resolution": {
                "point_win": ["point_made"],
                "point_lose": [7],
            }
        },
        "Don't Pass Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "Don't True Odds",
            "resolution": {
                "point_win": [7],
                "point_lose": ["point_made"],
            }
        },
        "Come Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "True Odds",
            "resolution": {
                "point_win": ["number_hit"],
                "point_lose": [7],
            }
        },
        "Don't Come Odds": {
            "valid_phases": ["point"],
            "payout_ratio": "Don't True Odds",
            "resolution": {
                "point_win": [7],
                "point_lose": ["number_hit"],
            }
        },
    },
    "Place Bets": {
        "is_contract_bet": False,
        "valid_numbers": [4, 5, 6, 8, 9, 10],
        "Place": {
            "linked_bet": "Place Odds",
            "valid_phases": ["point"],
            "payout_ratio": "Place Odds",
            "resolution": {
                "point_win": ["number_hit"],
                "point_lose": [7],
            }
        },
        "Don't Place": {
            "linked_bet": "Don't Place Odds",
            "valid_phases": ["point"],
            "payout_ratio": "Don't Place Odds",
            "resolution": {
                "point_win": [7],
                "point_lose": ["number_hit"],
            }
        },
        "Buy": {
            "linked_bet": None,
            "valid_phases": ["point"],
            "payout_ratio": "True Odds",
            "has_vig": True,
            "resolution": {
                "point_win": ["number_hit"],
                "point_lose": [7],
            }
        },
        "Lay": {
            "linked_bet": None,
            "valid_phases": ["point"],
            "payout_ratio": "Don't True Odds",
            "has_vig": True,
            "resolution": {
                "point_win": [7],
                "point_lose": ["number_hit"],
            }
        }
    },
    "Field Bets": {
        "is_contract_bet": False,
        "valid_numbers": None,
        "Field": {
            "linked_bet": None,
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Field",
            "resolution": {
                "come_out_win": ["in-field"],
                "come_out_lose": ["out-field"],
                "point_win": ["in-field"],
                "point_lose": ["out-field"],
            }
        },
    },
    "Other Bets": {
        "is_contract_bet": False,
        "valid_numbers": None,
        "Proposition": {
            "valid_numbers": [2, 3, 7, 11, 12],
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Proposition",
            "resolution": {
                "come_out_win": ["number_hit"],
                "come_out_lose": ["any_other"], 
                "point_win": ["number_hit"],
                "point_lose": ["any_other"],
            },
        },
        "Hardways": {
            "valid_numbers": [4, 6, 8, 10],
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Hardways",
            "resolution": {
                "come_out_win": ["hardway_win"],
                "come_out_lose": ["hardway_lose"],
                "point_win": ["hardway_win"],
                "point_lose": ["hardway_lose"],
            },
        },
        "Hop": {
            "valid_numbers": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
            "valid_phases": ["come-out", "point"],
            "payout_ratio": "Hop",
            "resolution": {
                "come_out_win": ["hop_win"],
                "come_out_lose": ["hop_lose"],
                "point_win": ["hop_win"],
                "point_lose": ["hop_lose"],
            },
        }
    }
}

# ================================
# Payout Ratios (Now a Function)
# ================================

BET_PAYOUT = {
    "Even Money": {
        "default": (1, 1)
    },
    "True Odds": {
        4: (2, 1),
        5: (3, 2),
        6: (6, 5),
        8: (6, 5),
        9: (3, 2),
        10: (2, 1),
    },
    "Place Odds": {
        4: (9, 5),
        5: (7, 5),
        6: (7, 6),
        8: (7, 6),
        9: (7, 5),
        10: (9, 5),
    },
    "Don't True Odds": {
        4: (1, 2),
        5: (2, 3),
        6: (5, 6),
        8: (5, 6),
        9: (2, 3),
        10: (1, 2),
    },
    "Don't Place Odds": {
        4: (5, 9),
        5: (5, 7),
        6: (6, 7),
        8: (6, 7),
        9: (5, 7),
        10: (5, 9),
    },
    "Field": {
        2: (2, 1),
        3: (1, 1),
        4: (1, 1),
        9: (1, 1),
        10: (1, 1),
        11: (1, 1),
        12: (3, 1),
    },
    "Proposition": {
        2: (30, 1),
        3: (15, 1),
        7: (4, 1),
        11: (15, 1),
        12: (30, 1),
    },
    "Hardways": {
        4: (8, 1),
        6: (10, 1),
        8: (10, 1),
        10: (8, 1),
    },
    "Hop": {
        (1, 1): (30, 1),
        (1, 2): (15, 1),
        (1, 3): (15, 1),
        (2, 2): (30, 1),
        (2, 3): (15, 1),
        (2, 4): (15, 1),
        (3, 3): (30, 1),
        (3, 4): (15, 1),
        (3, 5): (15, 1),
        (4, 4): (30, 1),
        (4, 5): (15, 1),
        (4, 6): (15, 1),
        (5, 5): (30, 1),
        (5, 6): (15, 1),
        (6, 6): (30, 1),
    }
}



# File: .\craps\rules_engine.py

from typing import List, Optional, Dict, Any, Tuple, Union
from craps.rules import BET_RULES, BET_PAYOUT
from craps.bet import Bet
from craps.house_rules import HouseRules

class RulesEngine:
    """A rules engine for handling bets based on the rules defined in rules.py."""

    @staticmethod
    def get_bet_rules(bet_type: str) -> Dict[str, Any]:
        """
        Retrieve the rules for a given bet type, including category-level attributes.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Field", "Hardways").
        :return: A dictionary containing the rules for the bet.
        """
        for category, bets in BET_RULES.items():
            if isinstance(bets, dict) and bet_type in bets:
                bet_rules = bets[bet_type].copy() if isinstance(bets[bet_type], dict) else {}
                category_rules = {k: v for k, v in bets.items() if not isinstance(v, dict)}
                return {**category_rules, **bet_rules}

        raise ValueError(f"Unknown bet type: {bet_type}")

    @staticmethod
    def get_linked_bet_type(bet_type: str) -> Optional[str]:
        """Returns the linked bet type, if any (e.g., Pass Line â†’ Pass Line Odds)."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # âœ… Unified retrieval
        return bet_rules.get("linked_bet")

    @staticmethod
    def get_minimum_bet(bet_type: str, table: Any) -> int:
        """Returns the correct minimum bet amount for a given bet type based on table rules."""
        table_min = table.house_rules.table_minimum
        table_max = table.house_rules.table_maximum
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # âœ… Unified rule retrieval

        # ðŸŸ¢ **Base Minimum Bet: All bets must be at least $1**
        min_bet = 1

        # ðŸŸ¢ **Line & Field Bets: Must be within table min & max**
        if bet_rules.get("is_contract_bet", False) or bet_type == "Field":
            min_bet = max(table_min, min_bet)  # Ensure at least table minimum
            return min(table_max, min_bet)  # Ensure it doesn't exceed table max

        # ðŸŸ¢ **Prop, Hop, Hardways, Odds Bets: Can be as low as $1**
        elif bet_rules.get("valid_numbers") is not None and bet_type in ["Proposition", "Hardways", "Hop", "Odds"]:
            return min_bet  # No additional constraints

        # ðŸŸ¢ **Place & Don't Place Bets: Special Case for 6 & 8**
        elif bet_type in ["Place", "Don't Place"] and bet_rules.get("valid_numbers") == [6, 8]:
            return table_min + (table_min // 5)  # Ensure correct payout increments

        # ðŸŸ¢ **Odds on 5 & 9: Must be Even for Correct Payouts**
        elif bet_type in ["Pass Line Odds", "Don't Pass Odds", "Come Odds", "Don't Come Odds"] and bet_rules.get("valid_numbers") == [5, 9]:
            return max(2, (table_min // 2) * 2)  # Round up to the nearest even number

        return min_bet  # Default minimum bet

    @staticmethod
    def create_bet(bet_type: str, amount: int, owner: Any, number: Optional[int] = None, parent_bet: Optional[Bet] = None) -> Bet:
        """Create a bet based on the bet type."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # âœ… Unified retrieval

        if not bet_rules:
            raise ValueError(f"Unknown bet type: {bet_type}")

        # âœ… Check if the number is valid for this bet type
        valid_numbers = bet_rules.get("valid_numbers")  # Can be None or a list
        if valid_numbers is None and number is not None:
            raise ValueError(f"{bet_type} bet should not have a number")
        if valid_numbers and number not in valid_numbers:
            raise ValueError(f"Invalid number {number} for bet type {bet_type}")

        payout_ratio: Tuple[int, int] = RulesEngine.get_payout_ratio(bet_type, number) or (1, 1)

        return Bet(
            bet_type=bet_type,
            amount=amount,
            owner=owner,
            payout_ratio=payout_ratio,
            valid_phases=bet_rules["valid_phases"],
            number=number,
            parent_bet=parent_bet,
            is_contract_bet=bet_rules.get("is_contract_bet", False),
        )

    @staticmethod
    def can_make_bet(bet_type: str, phase: str, number: Optional[int] = None) -> bool:
        """Check if a bet can be placed in the given phase and with a specific number."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # âœ… Get the rules
        
        # âœ… Check valid phases (no change)
        if phase not in bet_rules["valid_phases"]:
            return False

        # âœ… Only check valid numbers **if the bet type has them defined**
        valid_numbers = bet_rules.get("valid_numbers")  # Get the valid numbers list
        if valid_numbers is not None and number is not None and number not in valid_numbers:
            return False  # âŒ Reject invalid numbers

        return True  # âœ… Bet is valid

    @staticmethod
    def can_turn_on(bet_type: str, phase: str) -> bool:
        """Determine if a bet of the given type can be turned on during the current phase."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # âœ… Unified retrieval
        return bet_rules.get("can_turn_on", False)
    
    @staticmethod
    def can_remove_bet(bet_type: str) -> bool:
        """
        Determine if a bet of the given type can be removed.
        Contract bets cannot be removed once placed.
        """
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # âœ… Fetch all bet rules in one go
        return not bet_rules.get("is_contract_bet", False)  # âŒ Contract bets cannot be removed

    @staticmethod
    def get_payout_ratio(bet_type: str, number: Optional[Union[int, Tuple[int, int]]] = None) -> Tuple[int, int]:
        """Get the payout ratio for a bet based on its type and number (if applicable)."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)
        payout_key = bet_rules.get("payout_ratio")

        # Ensure payout_key exists and its value in BET_PAYOUT is a dictionary
        if payout_key in BET_PAYOUT:
            payout_data = BET_PAYOUT[payout_key]
            if isinstance(payout_data, dict):
                # Case 1: If no number is provided, return the default payout ratio
                if number is None:
                    return payout_data.get("default", (1, 1))

                # Case 2: If number is an integer (e.g., True Odds, Place Bets)
                if isinstance(number, int):
                    return payout_data.get(number, payout_data.get("default", (1, 1)))

                # Case 3: If number is a tuple (e.g., Hop bets)
                if isinstance(number, tuple):
                    return payout_data.get(number, payout_data.get("default", (1, 1)))

        raise ValueError(f"Invalid payout type {payout_key} for bet {bet_type} (number={number})")

    @staticmethod
    def resolve_bet(bet: Bet, dice_outcome: Tuple[int, int], phase: str, point: Optional[int]) -> int:
        """
        Resolves a bet based on the dice outcome, phase, and point.
        Uses a structured approach based on bet categories.
        """
        total = sum(dice_outcome)
        is_pair = dice_outcome[0] == dice_outcome[1]
        sorted_dice = tuple(sorted(dice_outcome))
        bet_rules = RulesEngine.get_bet_rules(bet.bet_type)  # âœ… Unified retrieval
        resolution_rules = bet_rules["resolution"]
        phase_key = phase.replace("-", "_")  # âœ… Normalize phase key

        # ðŸŽ¯ **1. LINE BETS (Pass Line, Don't Pass, Come, Don't Come)**
        if bet_rules.get("is_contract_bet", False):  # âœ… Line bets use contract logic
            winning_numbers = resolution_rules.get(f"{phase_key}_win", [])
            losing_numbers = resolution_rules.get(f"{phase_key}_lose", [])

            # ðŸ† **Check if the bet wins**
            if total in winning_numbers:
                bet.status = "won"
            elif total in losing_numbers:
                bet.status = "lost"

        ### ðŸŽ¯ **2. FIELD BETS**
        elif bet.bet_type == "Field":
            if "in-field" in resolution_rules.get(f"{phase_key}_win", []):
                bet.status = "won"
                bet.number = total  # âœ… Assign the rolled number
            elif "out-field" in resolution_rules.get(f"{phase_key}_lose", []):
                bet.status = "lost"

        ### ðŸŽ¯ **3. PLACE, BUY, LAY BETS**
        elif bet_rules.get("valid_numbers") == [4, 5, 6, 8, 9, 10]:  # âœ… Uses category attribute
            if total == bet.number and "number_hit" in resolution_rules.get(f"{phase_key}_win", []):
                bet.status = "won"
            elif total == 7 and "point_lose" in resolution_rules.get(f"{phase_key}_lose", []):
                bet.status = "lost"

        ### ðŸŽ¯ **4. PROPOSITION BETS**
        elif bet.bet_type == "Proposition":
            if "number_hit" in resolution_rules.get(f"{phase_key}_win", []) and total == bet.number:
                bet.status = "won"
            elif "any_other" in resolution_rules.get(f"{phase_key}_lose", []) and total != bet.number:
                bet.status = "lost"

        ### ðŸŽ¯ **5. HARDWAYS**
        elif bet.bet_type == "Hardways":
            if "hardway_win" in resolution_rules.get(f"{phase_key}_win", []):
                if total == bet.number and is_pair:
                    bet.status = "won"

            if "hardway_lose" in resolution_rules.get(f"{phase_key}_lose", []):
                if total == 7 or (total == bet.number and not is_pair):  # âœ… Easy way loses
                    bet.status = "lost"

        ### ðŸŽ¯ **6. HOP BETS**
        elif bet.bet_type == "Hop":
            hop_payouts = BET_PAYOUT.get("Hop", {})

            if not isinstance(hop_payouts, (dict, list)):
                raise TypeError(f"Expected dict or list for Hop payouts, got {type(hop_payouts)}")

            if "hop_win" in resolution_rules.get(f"{phase_key}_win", []):
                if sorted_dice == (bet.number, bet.number) or sorted_dice in hop_payouts:
                    bet.status = "won"

            elif "hop_lose" in resolution_rules.get(f"{phase_key}_lose", []):
                if sorted_dice != (bet.number, bet.number) and sorted_dice not in hop_payouts:
                    bet.status = "lost"
                
        ### ðŸŽ¯ **7. ODDS BETS**
        elif bet.bet_type in ["Pass Line Odds", "Come Odds", "Don't Pass Odds", "Don't Come Odds"]:
            if bet.parent_bet and bet.parent_bet.status == "won":
                bet.status = "won"
            elif bet.parent_bet and bet.parent_bet.status == "lost":
                bet.status = "lost"

        ### ðŸŽ¯ **Calculate Payout if Won**
        payout = RulesEngine.calculate_payout(bet, total) if bet.status == "won" else 0
        return payout

    @staticmethod
    def calculate_payout(bet: Bet, roll: Optional[int] = None) -> int:
        """
        Calculate the payout for a resolved bet.
        """
        if bet.status != "won":
            return 0  # âœ… No payout if the bet didn't win

        # Ensure the correct roll value is used for bets that depend on it (e.g., Field)
        number = roll if bet.bet_type == "Field" else bet.number

        # âœ… Field bets should only request payout if they actually won
        field_payouts = BET_PAYOUT.get("Field", {})

        if not isinstance(field_payouts, (dict, list, set)):
            raise TypeError(f"Expected dict, list, or set for Field payouts, got {type(field_payouts)}")

        if bet.bet_type == "Field" and number not in field_payouts:
            return 0  # âœ… If the number isn't a winning Field number, payout is $0

        payout_ratio = RulesEngine.get_payout_ratio(bet.bet_type, number)
        numerator, denominator = payout_ratio
        profit = (bet.amount * numerator) // denominator

        return profit

    @staticmethod
    def has_vig(bet_type: str) -> bool:
        """Determine if a bet of the given type has a vig (commission)."""
        bet_rules = RulesEngine.get_bet_rules(bet_type)  # âœ… Unified retrieval
        return bet_rules.get("vig", False)


# File: .\craps\session_initializer.py

from typing import Dict, Tuple, Optional
from craps.house_rules import HouseRules
from craps.table import Table
from craps.roll_history_manager import RollHistoryManager
from craps.log_manager import LogManager
from craps.play_by_play import PlayByPlay
from craps.rules_engine import RulesEngine
from craps.statistics import Statistics
from craps.game_state import GameState

class InitializeSession:
    def __init__(
        self, 
        session_mode: str, 
        house_rules_config: Dict[str, int], 
        play_by_play: PlayByPlay, 
        rules_engine: RulesEngine, 
        log_manager: Optional[LogManager] = None
    ) -> None:
        """
        Initialize the session.

        :param session_mode: The session mode ("live" or "history").
        :param house_rules_config: The house rules configuration.
        :param play_by_play: The PlayByPlay instance for logging messages.
        :param rules_engine: The RulesEngine instance to use.
        :param log_manager: The LogManager instance for managing logs.
        """
        self.session_mode: str = session_mode
        self.house_rules_config: Dict[str, int] = house_rules_config
        self.roll_history_manager: RollHistoryManager = RollHistoryManager()
        self.log_manager = log_manager or LogManager()
        self.play_by_play: PlayByPlay = play_by_play
        self.rules_engine: RulesEngine = rules_engine

    def prepare_session(
        self, num_shooters: int, num_players: int
    ) -> Optional[Tuple[HouseRules, Table, RollHistoryManager, LogManager, PlayByPlay, Statistics, GameState]]:
        """Prepare the session based on the session mode."""
        try:
            self.roll_history_manager.prepare_for_session(self.session_mode)
        except (ValueError, FileNotFoundError) as e:
            print(f"Error: {e}")
            return None

        # Initialize house rules
        house_rules = HouseRules(self.house_rules_config)

        # âœ… Pass RulesEngine to Table
        table = Table(house_rules, self.play_by_play, self.rules_engine)

        # Initialize Statistics and GameState
        stats = Statistics(house_rules.table_minimum, num_shooters, num_players)
        game_state = GameState(stats, play_by_play=self.play_by_play)
        game_state.set_table(table)

        # Delete the existing log file before starting the session
        self.log_manager.delete_log_file()

        # Clear the play-by-play file before starting the session
        self.play_by_play.clear_play_by_play_file()

        return house_rules, table, self.roll_history_manager, self.log_manager, self.play_by_play, stats, game_state


# File: .\craps\simulation_manager.py

# File: craps/simulation_manager.py
from typing import List
from craps.single_session import run_single_session
from craps.house_rules import HouseRules
from craps.statistics import Statistics

class SimulationManager:
    def __init__(self, house_rules: HouseRules, num_tables: int, num_shooters: int, strategies: List):
        """
        Initialize the SimulationManager.
        
        :param house_rules: The HouseRules object for payout rules and limits.
        :param num_tables: The number of tables to simulate.
        :param num_shooters: The number of shooters per session.
        :param strategies: A list of betting strategies to evaluate.
        """
        self.house_rules = house_rules
        self.num_tables = num_tables
        self.num_shooters = num_shooters
        self.strategies = strategies
        self.stats = Statistics(house_rules.table_minimum, num_shooters, len(strategies))

    def run_simulation(self, num_sessions: int) -> None:
        """Run multiple sessions and collect statistics."""
        for _ in range(num_sessions):
            for _ in range(self.num_tables):
                stats = run_single_session(self.house_rules, self.strategies, num_shooters=self.num_shooters)
                self.stats.merge(stats)  # Merge session stats into overall stats

        self.stats.print_statistics()
        self.stats.print_shooter_report()


# File: .\craps\single_session.py

from colorama import init, Fore, Style
from typing import List, Optional, Any
from craps.table import Table
from craps.game_state import GameState
from craps.player import Player
from craps.dice import Dice
from craps.statistics import Statistics
from craps.house_rules import HouseRules
from craps.log_manager import LogManager
from craps.session_initializer import InitializeSession
from craps.rules_engine import RulesEngine
from craps.log_manager import LogManager
from craps.play_by_play import PlayByPlay
import os

def run_single_session(
    house_rules: HouseRules,
    strategies: List[Any],
    player_names: Optional[List[str]] = None, 
    initial_bankroll: int = 500, 
    num_shooters: int = 10, 
    roll_history_file: Optional[str] = None
) -> Statistics:
    """
    Run a single session of craps and log the roll history.
    """
    init()  # Initialize colorama

    # Set dice mode
    dice = Dice(roll_history_file) if roll_history_file and os.path.exists(roll_history_file) else Dice()

    # âœ… Initialize session level objects
    rules_engine = RulesEngine()
    play_by_play = PlayByPlay()
    log_manager = LogManager()

    # âœ… Pass RulesEngine to InitializeSession
    session_initializer = InitializeSession(
        session_mode="live", 
        house_rules_config={"table_minimum": house_rules.table_minimum, "table_maximum": house_rules.table_maximum},
        play_by_play=play_by_play,  # âœ… Fix: Now passing PlayByPlay
        log_manager=log_manager,  # âœ… Fix: Now passing LogManager
        rules_engine=rules_engine
    )
    session_data = session_initializer.prepare_session(num_shooters, len(strategies))
    
    if session_data is None:
        raise RuntimeError("Failed to initialize session.")

    house_rules, table, roll_history_manager, log_manager, play_by_play, stats, game_state = session_data

    # Create players with different betting strategies
    if player_names is None:
        player_names = [f"Player {i+1}" for i in range(len(strategies))]

    players = [
        Player(player_names[i], initial_balance=initial_bankroll, betting_strategy=strategy)
        for i, strategy in enumerate(strategies)
    ]

    # Initialize bankroll history with the starting bankroll for each player
    stats.initialize_bankroll_history(players)

    # Initialize roll history
    roll_history = []

    # Simulate shooters
    for shooter_num in range(1, num_shooters + 1):
        player_index = (shooter_num - 1) % len(players)
        shooter = players[player_index]

        # Assign new shooter via GameState
        game_state.assign_new_shooter(shooter)

        while True:
            # Allow all players to place bets
            for player in players:
                bet = player.betting_strategy.get_bet(game_state, player, table)
                if bet:
                    player.place_bet(bet, table, game_state.phase, play_by_play)

            # Roll the dice and resolve bets
            outcome = (dice.roll())  # Now returns Tuple[int, int]
            total = sum(outcome)
            stats.update_rolls()
            stats.update_shooter_stats(shooter)

            # Log the dice roll and total
            message = f"{Fore.LIGHTMAGENTA_EX}{shooter.name} rolled: {outcome} (Total: {total}) | Roll Count: {stats.num_rolls}{Style.RESET_ALL}"
            play_by_play.write(message)

            # Log the roll to the history
            roll_history.append({
                "shooter_num": shooter_num,
                "roll_number": stats.num_rolls,
                "dice": outcome,
                "total": total,
                "phase": game_state.phase,
                "point": game_state.point
            })

            # Check bets on the table
            table.check_bets(outcome, game_state.phase, game_state.point)

            # Clear resolved bets and update player bankrolls
            resolved_bets = table.clear_resolved_bets()
            for bet in resolved_bets:
                if bet.status == "won":
                    payout = bet.payout()
                    bet.owner.receive_payout(payout, play_by_play)
                elif bet.status == "lost":
                    message = f"{Fore.RED}âŒ {bet.owner.name}'s {bet.bet_type} bet LOST ${bet.amount}.{Style.RESET_ALL}"
                    play_by_play.write(message)
                stats.update_win_loss(bet)

            # Update player bankrolls in statistics
            stats.update_player_bankrolls(players)

            # Update game state
            previous_phase = game_state.phase
            message = game_state.update_state(outcome)
            if message:
                play_by_play.write(message)

            # Check if the shooter 7-outs
            if previous_phase == "point" and total == 7:
                stats.record_seven_out()
                game_state.clear_shooter()  # Reset shooter status
                break  # Move to next shooter

    # Return stats and roll history
    stats.roll_history = roll_history
    return stats


# File: .\craps\statistics.py

# File: craps/statistics.py

import logging
from typing import List, Dict, Any, Optional

class Statistics:
    def __init__(self, table_minimum: int, num_shooters: int, num_players: int) -> None:
        self.table_minimum: int = table_minimum
        self.num_shooters: int = num_shooters
        self.num_players: int = num_players
        self.num_rolls: int = 0
        self.total_house_win_loss: int = 0
        self.total_player_win_loss: int = 0
        self.player_bankrolls: List[int] = []
        self.highest_bankroll: int = 0
        self.lowest_bankroll: float = float('inf')
        self.shooter_stats: Dict[int, Dict[str, Any]] = {}
        self.player_stats: Dict[str, Dict[str, Any]] = {}
        self.shooter: Optional[Any] = None
        self.shooter_num: Optional[int] = None
        self.roll_history: List[Dict[str, Any]] = []

        # For visualization
        self.roll_numbers: List[int] = [0]  # Start with roll 0
        self.bankroll_history: Dict[str, List[int]] = {}  # Track bankroll history for each player
        self.seven_out_rolls: List[int] = []  # Track rolls where a 7-out occurs
        self.point_number_rolls: List[int] = []  # Track rolls where a point number (4, 5, 6, 8, 9, 10) is rolled
        
    def initialize_player_stats(self, players: List[Any]) -> None:
        """Initialize player statistics with their starting bankroll."""
        for player in players:
            self.player_stats[player.name] = {
                "initial_bankroll": player.balance,
                "final_bankroll": player.balance,
                "net_win_loss": 0,
            }
            
    def update_player_stats(self, players: List[Any]) -> None:
        """Update player statistics at the end of the session."""
        for player in players:
            if player.name in self.player_stats:
                self.player_stats[player.name]["final_bankroll"] = player.balance
                self.player_stats[player.name]["net_win_loss"] = (
                    player.balance - self.player_stats[player.name]["initial_bankroll"]
                )
                
    def print_player_statistics(self) -> None:
        """Print player-specific statistics."""
        logging.info("\n=== Player Performance Report ===")
        for player_name, stats in self.player_stats.items():
            net_win_loss = stats["net_win_loss"]
            result = "Won" if net_win_loss >= 0 else "Lost"
            logging.info(f"\nPlayer: {player_name}")
            logging.info(f"  Initial Bankroll: ${stats['initial_bankroll']}")
            logging.info(f"  Final Bankroll: ${stats['final_bankroll']}")
            logging.info(f"  Net Win/Loss: ${net_win_loss} ({result})")
    
    def set_shooter(self, shooter: Any, shooter_num: int) -> None:
        """Set the current shooter and their turn number."""
        self.shooter = shooter
        self.shooter_num = shooter_num  # Track the shooter's turn number
        if shooter_num not in self.shooter_stats:
            self.shooter_stats[shooter_num] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "total_rolls": 0,
            }
            
    def initialize_bankroll_history(self, players: List[Any]) -> None:
        """Initialize bankroll history with the starting bankroll for each player."""
        for player in players:
            self.bankroll_history[player.name] = [player.balance]  # Roll 0: initial bankroll

    def merge(self, other_stats: "Statistics") -> None:
        """Merge statistics from another session."""
        self.num_rolls += other_stats.num_rolls
        self.total_house_win_loss += other_stats.total_house_win_loss
        self.total_player_win_loss += other_stats.total_player_win_loss
        self.player_bankrolls.extend(other_stats.player_bankrolls)
        self.highest_bankroll = max(self.highest_bankroll, other_stats.highest_bankroll)
        self.lowest_bankroll = min(self.lowest_bankroll, other_stats.lowest_bankroll)
        self.roll_numbers.extend(other_stats.roll_numbers)
        self.seven_out_rolls.extend(other_stats.seven_out_rolls)
        self.point_number_rolls.extend(other_stats.point_number_rolls)

        # Merge shooter stats
        for shooter_name, stats in other_stats.shooter_stats.items():
            if shooter_name not in self.shooter_stats:
                self.shooter_stats[shooter_name] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "total_rolls": 0,
                }
            self.shooter_stats[shooter_name]["points_rolled"] += stats["points_rolled"]
            self.shooter_stats[shooter_name]["rolls_before_7_out"].extend(stats["rolls_before_7_out"])
            self.shooter_stats[shooter_name]["total_rolls"] += stats["total_rolls"]

        # Merge bankroll history
        for player, bankrolls in other_stats.bankroll_history.items():
            if player not in self.bankroll_history:
                self.bankroll_history[player] = []
            self.bankroll_history[player].extend(bankrolls)

    def update_rolls(self) -> None:
        """Increment the roll count."""
        self.num_rolls += 1
        self.roll_numbers.append(self.num_rolls)

    def update_win_loss(self, bet: Any) -> None:
        """
        Update the house and player win/loss based on the resolved bet.

        :param bet: The resolved bet.
        """
        if bet.status == "won":
            payout = bet.payout()
            self.total_house_win_loss -= payout
            self.total_player_win_loss += payout
        elif bet.status == "lost":
            self.total_house_win_loss += bet.amount
            self.total_player_win_loss -= bet.amount
    
    def update_player_bankrolls(self, players: List[Any]) -> None:
        """Update player bankrolls and track highest/lowest bankroll."""
        self.player_bankrolls = [player.balance for player in players]
        self.highest_bankroll = max(self.player_bankrolls)
        self.lowest_bankroll = min(self.player_bankrolls)

        for player in players:
            if player.name not in self.bankroll_history:
                self.bankroll_history[player.name] = []
            self.bankroll_history[player.name].append(player.balance)

    def record_seven_out(self) -> None:
        """Record the roll number where a 7-out occurs."""
        self.seven_out_rolls.append(self.num_rolls)
        if self.shooter and self.shooter_num is not None:  # Ensure shooter_num is an int
            if self.shooter_num not in self.shooter_stats:
                self.shooter_stats[self.shooter_num] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "total_rolls": 0,
                }
            self.shooter_stats[self.shooter_num]["rolls_before_7_out"].append(self.shooter.current_roll_count)
            self.shooter.current_roll_count = 0
        
    def record_point_number_roll(self) -> None:
        """Record the roll number where a point number (4, 5, 6, 8, 9, 10) is rolled."""
        self.point_number_rolls.append(self.num_rolls)
        if self.shooter and self.shooter_num is not None:  # Ensure shooter_num is an int
            if self.shooter_num not in self.shooter_stats:
                self.shooter_stats[self.shooter_num] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "total_rolls": 0,
                }
            self.shooter_stats[self.shooter_num]["points_rolled"] += 1

    def update_shooter_stats(self, shooter: Any) -> None:
        """Update shooter statistics."""
        if self.shooter_num is None:
            return  # Avoid indexing with None

        if self.shooter_num not in self.shooter_stats:
            self.shooter_stats[self.shooter_num] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "total_rolls": 0,
            }
        self.shooter_stats[self.shooter_num]["total_rolls"] = shooter.current_roll_count
        self.shooter_stats[self.shooter_num]["rolls_before_7_out"].append(shooter.rolls_before_7_out)


    def print_statistics(self) -> None:
        """Print the simulation statistics."""
        logging.info("\n=== Simulation Statistics ===")
        logging.info(f"Table Minimum: ${self.table_minimum}")
        logging.info(f"Number of Shooters: {self.num_shooters}")
        logging.info(f"Number of Players: {self.num_players}")
        logging.info(f"Number of Rolls: {self.num_rolls}")
        logging.info(f"Total House Win/Loss: ${self.total_house_win_loss}")
        logging.info(f"Total Player Win/Loss: ${self.total_player_win_loss}")
        logging.info(f"Player Bankrolls: {self.player_bankrolls}")
        logging.info(f"Highest Player Bankroll: ${self.highest_bankroll}")
        logging.info(f"Lowest Player Bankroll: ${self.lowest_bankroll}")

    def print_shooter_report(self) -> None:
        """Print a report summarizing each shooter's performance."""
        logging.info("\n=== Shooter Performance Report ===")
        for shooter_num, stats in self.shooter_stats.items():
            total_points_rolled = stats["points_rolled"]
            total_rolls = stats["total_rolls"]
            rolls_before_7_out = stats["rolls_before_7_out"]
            avg_rolls_before_7_out = sum(rolls_before_7_out) / len(rolls_before_7_out) if rolls_before_7_out else 0


# File: .\craps\table.py

# File: .\craps\table.py

from colorama import Fore, Style
from typing import List, Optional, Tuple
from craps.bet import Bet
from craps.play_by_play import PlayByPlay
from craps.house_rules import HouseRules
from craps.rules_engine import RulesEngine

class Table:
    def __init__(self, house_rules: HouseRules, play_by_play: PlayByPlay, rules_engine: RulesEngine) -> None:
        """
        Initialize the table.

        :param house_rules: The HouseRules object for payout rules and limits.
        :param play_by_play: The PlayByPlay instance for logging.
        :param rules_engine: The RulesEngine instance for resolving bets.
        """
        self.house_rules = house_rules
        self.play_by_play = play_by_play
        self.rules_engine = rules_engine  # Use the passed RulesEngine
        self.bets: List[Bet] = []  # All bets on the table
        self.unit = self.house_rules.table_minimum // 5  # Unit for Place/Buy bets

    def get_rules_engine(self) -> RulesEngine:
            """Expose RulesEngine for other classes to query."""
            return self.rules_engine
    
    def has_bet(self, bet: Bet) -> bool:
        """
        Check if a specific bet is on the table.

        :param bet: The bet to check for.
        :return: True if the bet is on the table, False otherwise.
        """
        return bet in self.bets

    def reactivate_inactive_bets(self) -> None:
        """
        Reactivate inactive Place bets when the point is set.
        """
        reactivated_bets = []
        for bet in self.bets:
            if bet.bet_type.startswith("Place") and bet.status == "inactive":
                bet.status = "active"
                reactivated_bets.append(f"{bet.owner.name}'s {bet.bet_type}")

        if reactivated_bets:
            message = f"{', '.join(reactivated_bets)} are now ON."
            self.play_by_play.write(message)

    def place_bet(self, bet: Bet, phase: str) -> bool:
        """
        Place a bet on the table after validating it.

        :param bet: The bet to place.
        :param phase: The current game phase ("come-out" or "point").
        :return: True if the bet was placed successfully, False otherwise.
        """
        # Validate the bet before placing it
        if not bet.validate_bet(phase, self.house_rules.table_minimum, self.house_rules.table_maximum):
            message = f"Invalid bet: {bet}"
            self.play_by_play.write(message)
            return False

        # Place the bet on the table
        self.bets.append(bet)
        message = f"Bet placed: {bet}"
        self.play_by_play.write(message)
        return True

    def check_bets(self, dice_outcome: Tuple[int, int], phase: str, point: Optional[int]) -> None:
        """
        Check and resolve all bets on the table based on the dice outcome, phase, and point.

        :param dice_outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        for bet in self.bets:
            bet.resolve(self.rules_engine, dice_outcome, phase, point)
            message = f"Bet resolved: {bet} (Status: {bet.status})"
            self.play_by_play.write(message)

    def clear_resolved_bets(self) -> List[Bet]:
        """
        Remove resolved bets from the table and update player bankrolls accordingly.
        """
        resolved_bets = []
        for bet in self.bets:
            if (bet.is_contract_bet and bet.status in ["won", "lost"]) or \
            (not bet.is_contract_bet and bet.status == "lost"):
                resolved_bets.append(bet)

        # Process bankroll updates for each resolved bet
        for bet in resolved_bets:
            if bet.status == "won":
                payout = bet.payout()
                bet.owner.receive_payout(payout, self.play_by_play)
            elif bet.status == "lost":
                bet.owner.balance -= bet.amount  # Deduct bet amount on loss
                message = f"{Fore.RED}âŒ {bet.owner.name} lost ${bet.amount} on {bet.bet_type}. New Bankroll: ${bet.owner.balance}.{Style.RESET_ALL}"
                self.play_by_play.write(message)

        # Remove resolved bets from active table bets
        self.bets = [bet for bet in self.bets if bet not in resolved_bets]
        return resolved_bets


# File: .\craps\view_log.py

# File: .\craps\view_log.py

import subprocess
from abc import ABC, abstractmethod
import os
import sys

class LogViewer(ABC):
    """
    Abstract base class for log viewers.
    """

    @abstractmethod
    def view(self, log_file: str) -> None:
        """
        View the log file.
        
        :param log_file: Path to the log file.
        """
        pass


class InteractiveLogViewer(LogViewer):
    """
    Concrete class for interactive log viewing.
    """

    def view(self, log_file: str) -> None:
        """
        Open the log file interactively.
        
        :param log_file: Path to the log file.
        """
        # Check if the log file exists
        if not os.path.exists(log_file):
            print(f"Log file '{log_file}' not found.")
            return

        # Handle Windows and Unix-like systems differently
        if sys.platform == "win32":
            # Windows: Use Python to print the file contents
            try:
                with open(log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        print(line, end='')
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")
        else:
            # Unix-like systems: Use `less -R`
            try:
                subprocess.run(['less', '-R', log_file])
            except FileNotFoundError:
                print("'less' command not found. Falling back to plain text viewing.")
                self._view_plain_text(log_file)
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")

    def _view_plain_text(self, log_file: str) -> None:
        """
        Fallback method to view the log file as plain text.
        
        :param log_file: Path to the log file.
        """
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")


class PlainTextLogViewer(LogViewer):
    """
    Concrete class for plain text log viewing.
    """

    def view(self, log_file: str) -> None:
        """
        Print the log file to the console.
        
        :param log_file: Path to the log file.
        """

        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")

# File: .\craps\visualizer.py

# File: .\craps\visualizer.py

import matplotlib.pyplot as plt
from typing import Any

class Visualizer:
    def __init__(self, stats: Any) -> None:
        """
        Initialize the Visualizer.

        :param stats: The statistics object containing bankroll history and roll numbers.
        """
        self.stats = stats

    def visualize_bankrolls(self) -> None:
        """Visualize player bankrolls over time."""
        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.stats.bankroll_history.items():
            # Ensure bankrolls and roll_numbers have the same length
            if len(bankrolls) != len(self.stats.roll_numbers):
                # Trim the longer list to match the shorter one
                min_length = min(len(bankrolls), len(self.stats.roll_numbers))
                bankrolls = bankrolls[:min_length]
                roll_numbers = self.stats.roll_numbers[:min_length]
            else:
                roll_numbers = self.stats.roll_numbers
            plt.plot(roll_numbers, bankrolls, label=player)

        # Add red vertical lines for 7-out events
        for roll in self.stats.seven_out_rolls:
            plt.axvline(x=roll, color='red', linestyle='--', alpha=0.5, label='7-Out' if roll == self.stats.seven_out_rolls[0] else "")

        # Add green dashed lines for point number rolls
        for roll in self.stats.point_number_rolls:
            plt.axvline(x=roll, color='green', linestyle=':', alpha=0.5, label='Point Number Rolled' if roll == self.stats.point_number_rolls[0] else "")

        # Set x-axis limits to start at 0 and end at the last roll
        last_roll = self.stats.roll_numbers[-1]
        plt.xlim(left=0, right=last_roll)

        # Customize x-axis ticks to include the last roll number
        x_ticks = list(range(0, last_roll + 1, 10))  # Major ticks every 10 rolls

        # Remove the next-to-last tick if it is within 3 of the last roll and the last roll is not a multiple of 10
        if len(x_ticks) >= 2:
            next_to_last_tick = x_ticks[-2]
            if (last_roll - next_to_last_tick) <= 3 and (last_roll % 10 != 0):
                x_ticks.pop(-2)  # Remove the next-to-last tick

        # Add the last roll number if it's not already included
        if last_roll not in x_ticks:
            x_ticks.append(last_roll)

        plt.xticks(x_ticks)

        # Add labels and title
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)
        plt.show()


# File: .\craps\__init__.py



# File: .\craps\strategies\field_strategy.py

# File: .\craps\strategies\field_strategy.py

from __future__ import annotations
from typing import TYPE_CHECKING, Optional
if TYPE_CHECKING:
    from craps.rules_engine import RulesEngine  # Prevents circular imports
    from craps.game_state import GameState
    from craps.player import Player
    from craps.table import Table
    from craps.bet import Bet

class FieldBetStrategy:
    """Betting strategy for Field bets."""
    
    def __init__(self, min_bet: int) -> None:
        """
        Initialize the Field Bet strategy.
        
        :param min_bet: The minimum bet amount for the table.
        """
        self.min_bet: int = min_bet

    def get_bet(self, game_state: GameState, player: Player, table: Table) -> Optional[Bet]:
        """
        Place a Field bet during the point roll if no active bet exists.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :param table: The table where bets are placed.
        :return: A Field bet if one does not already exist, otherwise None.
        """
        if game_state.phase != "point":
            return None  # Only place bets after the point is established
        
        # Check if the player already has an active Field bet
        if player.has_active_bet(table, "Field"):
            return None  # No new bet to place

        # Use RulesEngine to create a Field bet
        rules_engine = table.get_rules_engine()
        return rules_engine.create_bet("Field", self.min_bet, player)


# File: .\craps\strategies\free_odds_strategy.py

from enum import Enum
from __future__ import annotations
from typing import TYPE_CHECKING, List, Optional

if TYPE_CHECKING:
    from craps.table import Table
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.bet import Bet

class OddsMultiple(Enum):
    ONE_X = "1x"
    TWO_X = "2x"
    THREE_X = "3x"
    ONE_TWO_THREE = "1-2-3"
    THREE_FOUR_FIVE = "3-4-5"

class FreeOddsStrategy:
    """Betting strategy for Free Odds on any active bet."""

    def __init__(self, table: Table, odds_multiple: OddsMultiple = OddsMultiple.ONE_X) -> None:
        """
        Initialize the Free Odds strategy.

        :param table: The table object to determine minimum bets.
        :param odds_multiple: Enum representing odds multiple.
        """
        self.table: Table = table
        self.odds_multiple: OddsMultiple = odds_multiple

    def get_odds_amount(self, original_bet_amount: int) -> int:
        """Calculate the odds amount based on the original bet amount and the selected multiple."""
        if self.odds_multiple == OddsMultiple.ONE_X:
            return original_bet_amount
        elif self.odds_multiple == OddsMultiple.TWO_X:
            return original_bet_amount * 2
        elif self.odds_multiple == OddsMultiple.THREE_X:
            return original_bet_amount * 3
        elif self.odds_multiple == OddsMultiple.ONE_TWO_THREE:
            return original_bet_amount
        elif self.odds_multiple == OddsMultiple.THREE_FOUR_FIVE:
            return original_bet_amount
        else:
            raise ValueError(f"Invalid odds multiple: {self.odds_multiple}")

    def get_bet(self, game_state: GameState, player: Player) -> Optional[List[Bet]]:
        """
        Place Free Odds bets on any active bets for the player.
        
        :param game_state: The current game state.
        :param player: The player placing the bet.
        :return: A list of bets to place, or None if no bets are placed.
        """
        bets: List[Bet] = []
        rules_engine = self.table.get_rules_engine()

        # Retrieve active bets belonging to the player from the table
        active_bets = [bet for bet in self.table.bets if bet.owner == player]

        for active_bet in active_bets:
            if active_bet.bet_type in ["Pass Line", "Place"]:
                odds_amount = self.get_odds_amount(active_bet.amount)

                if active_bet.bet_type == "Pass Line":
                    bets.append(rules_engine.create_bet(
                        "Pass Line Odds", odds_amount, player, parent_bet=active_bet
                    ))
                elif active_bet.bet_type == "Place":
                    bets.append(rules_engine.create_bet(
                        "Place Odds", odds_amount, player, number=active_bet.number, parent_bet=active_bet
                    ))

        return bets if bets else None  # Return bets if any were created


# File: .\craps\strategies\iron_cross_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, Optional, List
from craps.bet import Bet

if TYPE_CHECKING:
    from craps.table import Table  # Prevents circular imports
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.play_by_play import PlayByPlay

class IronCrossStrategy:
    """Betting strategy for Iron Cross."""

    def __init__(self, table: Table, rules_engine: RulesEngine, min_bet: int, play_by_play: PlayByPlay) -> None:
        """
        Initialize the Iron Cross strategy.

        :param table: The table object to determine minimum bets.
        :param rules_engine: The RulesEngine instance from the table.
        :param min_bet: The minimum bet amount for the table.
        :param play_by_play: The play-by-play logging instance.
        """
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine
        self.min_bet: int = min_bet
        self.play_by_play: PlayByPlay = play_by_play

    def get_bet(self, game_state: GameState, player: Player, table: Table) -> Optional[List[Bet]]:
        """
        Place bets for the Iron Cross strategy.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :param table: The table where the bet will be placed.
        :return: A list of bets to place, or None if no bets are placed.
        """
        
        rules_engine = self.rules_engine

        if game_state.phase == "come-out":
            # Place a Pass Line bet during the come-out roll if no active bet exists
            if not any(bet.owner == player and bet.bet_type == "Pass Line" for bet in table.bets):
                return [rules_engine.create_bet("Pass Line", self.min_bet, player)]

        elif game_state.phase == "point":
            # Reactivate inactive Place bets
            for bet in table.bets:
                if bet.owner == player and bet.bet_type.startswith("Place") and bet.status == "inactive":
                    bet.status = "active"
                    message = f"{player.name}'s {bet.bet_type} bet is now ON."
                    self.play_by_play.write(message)

            # Place Place bets on 5, 6, and 8 during the point phase (excluding the point number)
            numbers = [5, 6, 8]  # Numbers for the Iron Cross

            # Exclude the point number
            if game_state.point in numbers:
                numbers.remove(game_state.point)

            # Filter out numbers already covered by a Place bet
            numbers = [
                num for num in numbers
                if not any(
                    bet.owner == player and bet.bet_type.startswith("Place") and bet.number == num
                    for bet in table.bets
                )
            ]

            # Use RulesEngine to create Place bets
            bets: List[Bet] = []
            for number in numbers:
                min_bet = rules_engine.get_minimum_bet("Place", table)  # âœ… Correct
                bets.append(rules_engine.create_bet("Place", min_bet, player, number=number))

            # Add a Field bet if no active Field bet exists
            if not any(bet.owner == player and bet.bet_type == "Field" for bet in table.bets):
                bets.append(rules_engine.create_bet("Field", self.min_bet, player))

            return bets if bets else None

        return None  # No bet to place


# File: .\craps\strategies\pass_line_odds_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, Optional
from craps.bet import Bet

if TYPE_CHECKING:
    from craps.table import Table  # Prevents circular imports
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player

class PassLineOddsStrategy:
    """Betting strategy for Pass Line with Odds bets."""

    def __init__(self, table: Table, rules_engine: RulesEngine, odds_multiple: int = 1) -> None:
        """
        Initialize the Pass Line Odds strategy.

        :param table: The table object to determine minimum bets.
        :param rules_engine: The RulesEngine instance from the table.
        :param odds_multiple: The multiple of the minimum bet to use for odds (e.g., 1x, 2x).
        """
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine
        self.odds_multiple: int = odds_multiple


    def get_bet(self, game_state: GameState, player: Player, table: Table) -> Optional[Bet]:
        """
        Place a Pass Line or Pass Line Odds bet based on the game state.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :param table: The table where the bet will be placed.
        :return: A Pass Line or Pass Line Odds bet, or None if no bet is placed.
        """
        rules_engine = self.rules_engine  # Use the passed RulesEngine

        if game_state.phase not in ["come-out", "point"]:
            return None  # Do not place the bet if the phase is invalid

        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if player.has_active_bet(table, "Pass Line"):
                return None  # No new bet to place

            # Use RulesEngine to create a Pass Line bet
            return rules_engine.create_bet("Pass Line", self.table.house_rules.table_minimum, player)

        elif game_state.phase == "point":
            # Check if the player already has an active Pass Line Odds bet
            if player.has_active_bet(table, "Pass Line Odds"):
                return None  # No new bet to place

            # Find the player's active Pass Line bet
            pass_line_bet = next(
                (bet for bet in table.bets if bet.owner == player and bet.bet_type == "Pass Line"),
                None
            )
            if pass_line_bet is None:
                return None  # No Pass Line bet found

            # Use RulesEngine to create a Pass Line Odds bet linked to the Pass Line bet
            return rules_engine.create_bet(
                "Pass Line Odds",
                self.table.house_rules.table_minimum * self.odds_multiple,  # Bet amount
                player,  # Owner
                number=game_state.point,  # Pass the current point number
                parent_bet=pass_line_bet  # Parent Pass Line bet
            )

        return None  # No bet to place

# File: .\craps\strategies\pass_line_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, Optional
from craps.bet import Bet

if TYPE_CHECKING:
    from craps.rules_engine import RulesEngine  
    from craps.game_state import GameState
    from craps.player import Player
    from craps.table import Table

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    
    def __init__(self, min_bet: int) -> None:
        """
        Initialize the Pass Line Strategy.

        :param min_bet: Minimum bet required for Pass Line.
        """
        self.min_bet: int = min_bet  # Fixed type

    def get_bet(self, game_state: GameState, player: Player, table: Table) -> Optional[Bet]:
        """
        Place a Pass Line bet during the come-out roll if no active bet exists.

        :param game_state: The current game state.
        :param player: The player placing the bet.
        :param table: The table where the bet will be placed.
        :return: A Pass Line bet or None if no bet is placed.
        """
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if player.has_active_bet(table, "Pass Line"):
                return None  # No new bet to place

            # Get RulesEngine from the table to create the bet
            rules_engine = table.get_rules_engine()
            return rules_engine.create_bet("Pass Line", self.min_bet, player)
        
        return None  # No bet to place


# File: .\craps\strategies\place_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import Union, TYPE_CHECKING, Optional, List

if TYPE_CHECKING:
    from craps.table import Table  # Prevents circular imports
    from craps.rules_engine import RulesEngine
    from craps.game_state import GameState
    from craps.player import Player
    from craps.bet import Bet

class PlaceBetStrategy:
    """Betting strategy for Place Bets."""

    def __init__(self, table: Table, rules_engine: RulesEngine, numbers_or_strategy: Union[str, list[int]]) -> None:
        """
        Initialize the Place Bet strategy.

        :param table: The table object to determine minimum bets.
        :param rules_engine: The RulesEngine instance from the table.
        :param numbers_or_strategy: A list of numbers (e.g., [5, 6, 8, 9]) or a strategy ("inside", "across").
        """
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine  # Use the existing RulesEngine
        self.numbers_or_strategy: Union[str, list[int]] = numbers_or_strategy

    def get_bet(self, game_state: GameState, player: Player, table: Table) -> Optional[List[Bet]]:
        """Place Place Bets based on the strategy and game state."""
        if game_state.phase != "point":
            return None  # Only place bets after the point is established

        rules_engine = table.get_rules_engine()

        # Determine which numbers to bet on
        if isinstance(self.numbers_or_strategy, str):
            if self.numbers_or_strategy == "inside":
                numbers = [5, 6, 8, 9]  # Inside numbers
            elif self.numbers_or_strategy == "across":
                numbers = [4, 5, 6, 8, 9, 10]  # Across numbers
            else:
                raise ValueError(f"Invalid strategy: {self.numbers_or_strategy}")
        else:
            numbers = self.numbers_or_strategy  # Specific numbers provided

        # Filter out numbers already covered by a Pass Line bet or a Place bet
        numbers = [
            num for num in numbers
            if not any(
                (bet.owner == player and bet.bet_type == "Pass Line" and game_state.point == num) or  # Pass Line covers the point
                (bet.owner == player and bet.bet_type.startswith("Place") and bet.number == num)  # Place Bet covers the number
                for bet in table.bets
            )
        ]

        # Use Table's RulesEngine to create Place bets
        bets: List[Bet] = []
        for number in numbers:
            min_bet = rules_engine.get_minimum_bet("Place", table)  # Use correct RulesEngine reference
            bets.append(rules_engine.create_bet("Place", min_bet, player, number=number))

        return bets if bets else None  # Return bets if any were created

# File: .\craps\strategies\three_point_molly_strategy.py

from __future__ import annotations  # Enable forward references for type hints
from typing import TYPE_CHECKING, List, Optional

if TYPE_CHECKING:
    from craps.table import Table  # Prevents circular imports
    from craps.rules_engine import RulesEngine  
    from craps.game_state import GameState
    from craps.player import Player
    from craps.bet import Bet

class ThreePointMollyStrategy:
    """Betting strategy for the 3-Point Molly system."""
    
    def __init__(self, table: Table, rules_engine: RulesEngine, min_bet: int, odds_multiple: int = 1, come_odds_working_on_come_out: bool = False) -> None:
        """
        Initialize the 3-Point Molly strategy.

        :param table: The table object to determine minimum bets.
        :param rules_engine: The RulesEngine instance from the table.
        :param min_bet: The minimum bet amount for the table.
        :param odds_multiple: The multiple of the minimum bet to use for odds (e.g., 1x, 2x).
        :param come_odds_working_on_come_out: Whether Come odds bets are working during the come-out roll.
        """
        self.table: Table = table
        self.rules_engine: RulesEngine = rules_engine  # Use existing RulesEngine, do not create a new one
        self.min_bet: int = min_bet
        self.odds_multiple: int = odds_multiple
        self.come_odds_working_on_come_out: bool = come_odds_working_on_come_out

    def get_bet(self, game_state: GameState, player: Player, table: Table) -> Optional[List[Bet]]:
        """
        Place bets according to the 3-Point Molly strategy.

        :param game_state: The current game state.
        :param player: The player placing the bets.
        :param table: The table to place the bets on.
        :return: A list of bets to place, or None if no bets are placed.
        """
        rules_engine = self.rules_engine  # Use the passed RulesEngine
        bets: List[Bet] = []

        # Place a Pass Line bet if no active Pass Line bet exists (only during come-out phase)
        if game_state.phase == "come-out":
            if not any(bet.bet_type == "Pass Line" for bet in table.bets if bet.owner == player):
                bets.append(rules_engine.create_bet(
                    "Pass Line",
                    self.min_bet,
                    player
                ))

        # Place up to 3 Come bets if fewer than 3 active Come bets exist (only during point phase)
        if game_state.phase == "point":
            active_come_bets = [bet for bet in table.bets if bet.bet_type == "Come" and bet.owner == player]
            if len(active_come_bets) < 3:
                bets.append(rules_engine.create_bet(
                    "Come",
                    self.min_bet,
                    player
                ))

        # Place odds on active Pass Line and Come bets (only during point phase)
        if game_state.phase == "point":
            for bet in table.bets:
                if bet.owner == player:
                    if bet.bet_type == "Pass Line" and bet.status == "active":
                        # Place Pass Line Odds
                        odds_amount = self.min_bet * self.odds_multiple
                        bets.append(rules_engine.create_bet(
                            "Pass Line Odds",
                            odds_amount,
                            player,
                            number=game_state.point,  # Pass the current point number
                            parent_bet=bet
                        ))
                    elif bet.bet_type == "Come" and bet.status == "active" and bet.number is not None:
                        # Place Come Odds
                        odds_amount = self.min_bet * self.odds_multiple
                        bets.append(rules_engine.create_bet(
                            "Come Odds",
                            odds_amount,
                            player,
                            number=bet.number,  # Pass the Come bet's number
                            parent_bet=bet
                        ))

        return bets if bets else None

# File: .\tests\test_bet_creation.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.player import Player

class TestBetCreationValidation(unittest.TestCase):
    
    def setUp(self):
        """Set up a player instance for testing."""
        self.player = Player("Test Player")  # Remove 'bankroll' if it's not a valid argument
        self.player.bankroll = 1000  # Set bankroll manually if needed

    
    def test_valid_bet_creation(self):
        """Ensure bets can be created correctly in valid phases."""
        bet = RulesEngine.create_bet("Pass Line", 10, self.player)
        self.assertEqual(bet.bet_type, "Pass Line")
        self.assertEqual(bet.amount, 10)
        self.assertEqual(bet.owner, self.player)
    
    def test_invalid_bet_creation(self):
        """Ensure invalid bets raise an exception."""
        with self.assertRaises(ValueError):
            RulesEngine.create_bet("Invalid Bet", 10, self.player)  
    
    def test_contract_bet_cannot_be_removed(self):
        """Ensure contract bets cannot be removed once placed."""
        bet = RulesEngine.create_bet("Pass Line", 10, self.player)
        self.assertFalse(RulesEngine.can_remove_bet(bet.bet_type))
    
    def test_valid_phases_for_bets(self):
        """Ensure bets are only allowed in correct game phases."""
        self.assertTrue(RulesEngine.can_make_bet("Pass Line", "come-out"))
        self.assertFalse(RulesEngine.can_make_bet("Pass Line", "point"))
        self.assertTrue(RulesEngine.can_make_bet("Come", "point"))
        self.assertFalse(RulesEngine.can_make_bet("Come", "come-out"))
    
    def test_bet_linkage(self):
        """Ensure linked bets (e.g., Pass Line â†’ Pass Line Odds) are valid."""
        linked_bet = RulesEngine.get_linked_bet_type("Pass Line")
        self.assertEqual(linked_bet, "Pass Line Odds")
        
    def test_create_hardways_bet_valid(self):
        """Ensure a valid Hardways bet is created correctly."""
        bet = RulesEngine.create_bet("Hardways", 10, self.player, number=8)
        self.assertEqual(bet.bet_type, "Hardways")
        self.assertEqual(bet.amount, 10)
        self.assertEqual(bet.number, 8)  # âœ… Should correctly store the Hardway number

    def test_create_hardways_bet_invalid(self):
        """Ensure an invalid Hardways bet (wrong number) raises an error."""
        with self.assertRaises(ValueError):
            RulesEngine.create_bet("Hardways", 10, self.player, number=5)  # âŒ Invalid number (not 4,6,8,10)
        
        with self.assertRaises(ValueError):
            RulesEngine.create_bet("Hardways", 10, self.player)  # âŒ Missing number
    
if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_bet_resolution.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.player import Player

class TestBetResolution(unittest.TestCase):

    def setUp(self):
        """Set up common test data."""
        self.player = Player("Test Player")
        self.rules_engine = RulesEngine()

    ### âœ… Line Bets ###
    def test_pass_line_win_come_out(self):
        """Pass Line bet should win on come-out roll with 7 or 11."""
        bet = self.rules_engine.create_bet("Pass Line", 10, self.player)
        payout = self.rules_engine.resolve_bet(bet, [4, 3], "come-out", None)  # Roll: 7

        self.assertEqual(bet.status, "won")
        self.assertEqual(payout, 10)  # Even money

    def test_pass_line_lose_come_out(self):
        """Pass Line bet should lose on come-out roll with 2, 3, or 12."""
        bet = self.rules_engine.create_bet("Pass Line", 10, self.player)
        payout = self.rules_engine.resolve_bet(bet, [1, 1], "come-out", None)  # Roll: 2

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    ### âœ… Proposition Bets (Updated) ###
    def test_proposition_win(self):
        """Proposition bet should win when the exact number is rolled."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=11)  # Yo (11)
        payout = self.rules_engine.resolve_bet(bet, [6, 5], "point", 8)  # Roll: 11

        self.assertEqual(bet.status, "won")
        self.assertGreater(payout, 0)

    def test_proposition_loss(self):
        """Proposition bet should lose on any number except its specific value."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=11)  # Yo (11)
        payout = self.rules_engine.resolve_bet(bet, [3, 4], "point", 8)  # Roll: 7

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    ### âœ… Any 7 Bet (Updated to Proposition) ###
    def test_proposition_7_win(self):
        """Any 7 bet should win when a 7 is rolled."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=7)
        payout = self.rules_engine.resolve_bet(bet, [5, 2], "point", 8)  # Roll: 7

        self.assertEqual(bet.status, "won")
        self.assertGreater(payout, 0)

    def test_proposition_7_loss(self):
        """Any 7 bet should lose on any roll except 7."""
        bet = self.rules_engine.create_bet("Proposition", 10, self.player, number=7)
        payout = self.rules_engine.resolve_bet(bet, [6, 5], "point", 8)  # Roll: 11

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    ### âœ… Field Bets (Ensure Proper Payouts) ###
    def test_field_bet_special_payout(self):
        """Field bet should pay 2:1 for 2 and 3:1 for 12."""
        bet = self.rules_engine.create_bet("Field", 10, self.player)
        payout = self.rules_engine.resolve_bet(bet, [1, 1], "point", 8)  # Roll: 2

        self.assertEqual(bet.status, "won")
        self.assertEqual(payout, 20)  # 2:1 payout for rolling a 2

    ### âœ… Hardways ###
    def test_hardways_win(self):
        """Hardways bet should win when the exact hardway is rolled."""
        bet = self.rules_engine.create_bet("Hardways", 10, self.player, number=8)
        payout = self.rules_engine.resolve_bet(bet, [4, 4], "point", 8)  # Hard 8

        self.assertEqual(bet.status, "won")
        self.assertGreater(payout, 0)

    def test_hardways_loss_easy_way(self):
        """Hardways bet should lose if the same total is rolled the easy way."""
        bet = self.rules_engine.create_bet("Hardways", 10, self.player, number=8)
        payout = self.rules_engine.resolve_bet(bet, [5, 3], "point", 8)  # Easy 8

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

    def test_hardways_loss_seven(self):
        """Hardways bet should lose when a 7 is rolled."""
        bet = self.rules_engine.create_bet("Hardways", 10, self.player, number=8)
        payout = self.rules_engine.resolve_bet(bet, [5, 2], "point", 8)  # Roll: 7

        self.assertEqual(bet.status, "lost")
        self.assertEqual(payout, 0)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_dice.py

import sys
import os
import unittest
from craps.dice import Dice

class TestDice(unittest.TestCase):
    def test_roll(self):
        dice = Dice()
        num_rolls = 1_000_000  # Number of rolls to simulate
        tolerance = 0.001  # Tolerance for probability comparison

        # Initialize counters for single die outcomes
        single_die_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}

        # Initialize counters for total outcomes
        total_counts = {
            2: 0, 3: 0, 4: 0, 5: 0, 6: 0,
            7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0
        }

        # Roll the dice 1 million times
        for _ in range(num_rolls):
            outcome = dice.roll()
            total = sum(outcome)

            # Count single die outcomes
            for die in outcome:
                single_die_counts[die] += 1

            # Count total outcomes
            total_counts[total] += 1

        # Calculate observed probabilities for single die outcomes
        single_die_probs = {
            die: count / (num_rolls * 2)  # Each roll involves 2 dice
            for die, count in single_die_counts.items()
        }

        # Calculate observed probabilities for total outcomes
        total_probs = {
            total: count / num_rolls
            for total, count in total_counts.items()
        }

        # Expected probabilities for single die outcomes
        expected_single_die_prob = 1 / 6

        # Expected probabilities for total outcomes
        expected_total_probs = {
            2: 1 / 36,
            3: 2 / 36,
            4: 3 / 36,
            5: 4 / 36,
            6: 5 / 36,
            7: 6 / 36,
            8: 5 / 36,
            9: 4 / 36,
            10: 3 / 36,
            11: 2 / 36,
            12: 1 / 36,
        }

        # Display results for single die outcomes
        print("\nSingle Die Outcomes:")
        print(f"{'Outcome':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for die in range(1, 7):
            actual = single_die_probs[die]
            expected = expected_single_die_prob
            deviation = actual - expected
            print(f"{die:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Display results for total outcomes
        print("\nTotal Outcomes:")
        print(f"{'Total':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for total in range(2, 13):
            actual = total_probs[total]
            expected = expected_total_probs[total]
            deviation = actual - expected
            print(f"{total:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Test single die outcomes
        for die, prob in single_die_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_single_die_prob,
                delta=tolerance,
                msg=f"Single die outcome {die} probability is not within tolerance."
            )

        # Test total outcomes
        for total, prob in total_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_total_probs[total],
                delta=tolerance,
                msg=f"Total outcome {total} probability is not within tolerance."
            )

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_invalid_bets.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.player import Player

class TestInvalidBets(unittest.TestCase):

    def setUp(self):
        """Create a mock player for testing."""
        self.player = Player("Test Player", 1000)  # âœ… Fixed positional args

    def test_invalid_place_bets(self):
        """Test invalid Place bets (should only allow 4, 5, 6, 8, 9, 10)."""
        invalid_numbers = [2, 3, 7, 11, 12]
        for num in invalid_numbers:
            with self.assertRaises(ValueError, msg=f"Place bet on {num} should be invalid"):
                RulesEngine.create_bet("Place", 10, self.player, number=num)

    def test_invalid_hardways(self):
        """Test invalid Hardways bets (should only allow 4, 6, 8, 10)."""
        invalid_numbers = [2, 3, 5, 7, 9, 11, 12]
        for num in invalid_numbers:
            with self.assertRaises(ValueError, msg=f"Hardways bet on {num} should be invalid"):
                RulesEngine.create_bet("Hardways", 10, self.player, number=num)

    def test_invalid_field_bets(self):
        """Test invalid Field bets (should not take a number)."""
        with self.assertRaises(ValueError, msg="Field bet should not have a number"):
            RulesEngine.create_bet("Field", 10, self.player, number=5)

    def test_invalid_pass_line_bets(self):
        """Test invalid Pass Line bets (should not take a number)."""
        with self.assertRaises(ValueError, msg="Pass Line bet should not have a number"):
            RulesEngine.create_bet("Pass Line", 10, self.player, number=7)

    def test_invalid_dont_pass_bets(self):
        """Test invalid Don't Pass bets (should not take a number)."""
        with self.assertRaises(ValueError, msg="Don't Pass bet should not have a number"):
            RulesEngine.create_bet("Don't Pass", 10, self.player, number=7)

    def test_invalid_hop_bets(self):
        """Test invalid Hop bets (e.g., Hop 7-7 is not possible)."""
        with self.assertRaises(ValueError, msg="Hop 7-7 should be invalid"):
            RulesEngine.create_bet("Hop", 10, self.player, number=7)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_payouts.py

import unittest
from craps.common import CommonTableSetup
from craps.rules_engine import RulesEngine

class TestPayouts(unittest.TestCase):
    def setUp(self):
        """Initialize the common table setup for testing."""
        self.common_setup = CommonTableSetup()
        self.rules_engine = RulesEngine()
        self.min_bet = self.common_setup.house_rules.table_minimum
        self.player = self.common_setup.player

    def test_payouts_for_all_bet_types(self):
        """Test that each bet type pays out correctly with the minimum bet."""
        bet_scenarios = [
            ("Pass Line", (4,3), "come-out", None, None),
            ("Pass Line Odds", (3,3), "point", None, 6),
            ("Come", (5,2), "come-out", None, None),
            ("Come", (3,3), "point", None, 6),
            ("Come Odds", (2,2), "point", 4, None),
            ("Place", (3,3), "point", 6, None),
            ("Place Odds", (3,3), "point", 6, None),
            ("Field", (1,1), "any", None, None),
            ("Field", (6,6), "any", None, None),
            ("Buy", (2,2), "point", 4, None),
            ("Lay", (5,5), "point", 10, None),
            ("Don't Pass", (1,1), "come-out", None, None),
            ("Don't Pass Odds", (5,5), "point", None, 10),
            ("Don't Come", (1,1), "come-out", None, None),
            ("Don't Come", (3,3), "point", 6, None),
            ("Don't Come Odds", (5,5), "point", 10, None),
            ("Hard 4", (2,2), "point", 4, None),
            ("Hard 6", (3,3), "point", 6, None),
            ("Hard 8", (4,4), "point", 8, None),
            ("Hard 10", (5,5), "point", 10, None),
            ("Any Craps", (1,1), "any", None, None),
            ("Any Seven", (4,3), "any", None, None),
            ("Proposition 12", (6,6), "any", None, None),
            ("Proposition 5", (2,3), "any", None, None),
            ("Hop 5-1", (5,1), "any", None, None),
            ("Hop 3-3", (3,3), "any", None, None)
        ]

        placed_bets = {}  # Dictionary to track placed bets by type

        print("\nPayout Validation for Minimum Bets")
        print("=" * 95)
        print(f"{'Bet Type':<20}{'Dice Roll':<15}{'Phase':<15}{'Bet Is On':<15}{'Point On':<15}{'Expected Payout':<15}{'Actual Payout':<15}")
        print("-" * 95)

        for bet_type, dice_roll, phase, bet_is_on, point_on in bet_scenarios:
            # Set the point number explicitly from test case
            self.point = point_on

            # Handle Odds bets that require a parent bet
            if "Odds" in bet_type:
                parent_bet_type = "Pass Line" if "Pass Line" in bet_type else "Come" if "Come" in bet_type else "Don't Pass" if "Don't Pass" in bet_type else "Don't Come"
                parent_bet = placed_bets.get(parent_bet_type)
                if parent_bet:
                    bet = self.rules_engine.create_bet(bet_type, self.min_bet, self.player, number=parent_bet.number, parent_bet=parent_bet)
                else:
                    print(f"Skipping {bet_type} bet as no parent bet exists.")
                    continue  # Skip if no parent bet exists
            else:
                bet = self.rules_engine.create_bet(bet_type, self.min_bet, self.player, number=bet_is_on)
                placed_bets[bet_type] = bet  # Store bet for later reference
            
            self.common_setup.table.place_bet(bet, phase)
            
            # Ensure dice outcome is correctly formatted as a tuple of two integers
            dice_outcome = tuple(map(int, dice_roll))
            
            # Resolve the bet, passing the correct point value
            bet.resolve(self.rules_engine, dice_outcome, phase, self.point)
            
            # Get the payout after resolution
            payout = bet.payout()
            
            # Expected payout based on rules
            expected_payout = bet.payout()
            
            # Print formatted results
            print(f"{bet_type:<20}{str(dice_roll):<15}{phase:<15}{str(bet_is_on):<15}{str(point_on):<15}{expected_payout:<15}{payout:<15}")
            
            # Validate payout
            self.assertEqual(payout, expected_payout)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_player.py

import unittest
from craps.house_rules import HouseRules
from craps.player import Player
from craps.play_by_play import PlayByPlay  # Import PlayByPlay

class TestPlayer(unittest.TestCase):
    def setUp(self):
        """Set up a player for testing."""
        house_rules_config = {
            "table_minimum": 5,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.play_by_play = PlayByPlay()  # Create a PlayByPlay instance
        self.player = Player(name="Test Player", initial_balance=1000, play_by_play=self.play_by_play)  # Pass it to Player
    
    def test_player_bankroll_persistence(self):
        """Test that a player's bankroll persists across rounds."""
        initial_balance = self.player.balance
        self.player.receive_payout(100)
        self.assertEqual(self.player.balance, initial_balance + 100)
    
    def test_player_can_place_bet(self):
        """Test that a player can place a valid bet."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.assertEqual(self.house_rules.table_minimum, 10)
    
    def test_player_cannot_bet_below_minimum(self):
        """Test that a player cannot place a bet below the table minimum."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.assertLess(5, self.house_rules.table_minimum)
    
    def test_player_cannot_bet_above_maximum(self):
        """Test that a player cannot place a bet above the table maximum."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        self.assertGreater(6000, self.house_rules.table_maximum)
    
    def test_player_balance_after_losing_bet(self):
        """Test that a player's balance decreases after losing a bet."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        initial_balance = self.player.balance
        lost_amount = 50
        self.player.balance -= lost_amount
        self.assertEqual(self.player.balance, initial_balance - lost_amount)
    
    def test_player_balance_after_winning_bet(self):
        """Test that a player's balance increases after winning a bet."""
        house_rules_config = {
            "table_minimum": 10,
            "table_maximum": 5000
        }
        self.house_rules = HouseRules(house_rules_config)
        initial_balance = self.player.balance
        win_amount = 150
        self.player.receive_payout(win_amount)
        self.assertEqual(self.player.balance, initial_balance + win_amount)
    
if __name__ == "__main__":
    unittest.main()


# File: .\tests\test_shooter_resolution.py

import unittest
from craps.shooter import Shooter
from craps.dice import Dice

class TestPlayerAndShooter(unittest.TestCase):

    def setUp(self):
        """Set up test environment with a player and a shooter."""
        self.shooter = Shooter(name="Test Shooter", initial_balance=1000, betting_strategy=None, dice=Dice(), play_by_play=None)

    def test_player_initialization(self):
        """Test that a player (shooter) is initialized correctly."""
        self.assertEqual(self.shooter.name, "Test Shooter")
        self.assertEqual(self.shooter.balance, 1000)
        self.assertIsNone(self.shooter.betting_strategy)

    def test_player_betting_outcome(self):
        """Test that a player only loses money when a bet is lost."""
        initial_balance = self.shooter.balance
        
        bet_amount = 100  # Amount bet
        bet_lost = True    # Simulating a loss
        bet_won = False    # Simulating a win
        
        # Balance should stay the same when placing a bet
        self.assertEqual(self.shooter.balance, initial_balance)

        # Simulate losing a bet
        if bet_lost:
            self.shooter.balance -= bet_amount

        self.assertEqual(self.shooter.balance, initial_balance - bet_amount, "Balance should decrease only on a loss.")

        # Reset balance for next check
        self.shooter.balance = initial_balance

        # Simulate winning a bet (double payout)
        if bet_won:
            self.shooter.balance += bet_amount * 2  # Assuming a 1:1 payout

        self.assertEqual(self.shooter.balance, initial_balance, "Winning should not decrease the balance.")

    def test_shooter_roll_dice(self):
        """Test that the shooter rolls dice and gets valid results."""
        outcome = self.shooter.roll_dice()
        self.assertEqual(len(outcome), 2)  # Should always roll two dice
        self.assertTrue(1 <= outcome[0] <= 6)
        self.assertTrue(1 <= outcome[1] <= 6)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\old_tests\test_come_bet_rules.py

# File: .\tests\test_come_bet_rules.py

import unittest
from craps.common import CommonTableSetup  # Import the common setup

class TestComeBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize the common table setup for testing."""
        self.common_setup = CommonTableSetup()

    def test_come_bet_resolution(self):
        """Test Come bet resolution during the point phase."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100, phase="point")

        # Simulate a roll of 6 to move the Come bet to number 6
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, phase="point")

        # Check that the Come bet has moved to number 6
        self.assertEqual(come_bet.number, 6, "Come bet should move to number 6")

        # Simulate a point roll of 6 (win)
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, phase="point")

        # Check that the Come bet is resolved as won
        self.assertEqual(come_bet.status, "won", "Come bet should win on 6")

    def test_come_odds_bet_resolution(self):
        """Test Come Odds bet resolution after the Come bet has moved to a number."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100, phase="point")

        # Simulate a roll of 6 to move the Come bet to number 6
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, phase="point")

        # Place a Come Odds bet linked to the Come bet
        come_odds_bet = self.common_setup.place_bet("Come Odds", 100)

        # Simulate a point roll of 6 (win)
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, phase="point")

        # Check that the Come Odds bet is resolved as won
        self.assertEqual(come_odds_bet.status, "won", "Come Odds bet should win on 6")

    def test_come_odds_bet_cannot_be_placed_before_come_bet_moves(self):
        """Test that Come Odds bets cannot be placed before the Come bet moves to a number."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100)

        # Attempt to place a Come Odds bet before the Come bet moves to a number
        with self.assertRaises(ValueError):
            self.common_setup.place_bet("Come Odds", 100)

    def test_come_odds_bet_can_be_placed_after_come_bet_moves(self):
        """Test that Come Odds bets can be placed after the Come bet moves to a number."""
        # Place a Come bet
        come_bet = self.common_setup.place_bet("Come", 100, phase="point")

        # Simulate a roll of 6 to move the Come bet to number 6
        dice_outcome = [3, 3]  # Total of 6
        self.common_setup.simulate_roll(dice_outcome, phase="point")

        # Place a Come Odds bet after the Come bet has moved to a number
        come_odds_bet = self.common_setup.place_bet("Come Odds", 100)

        # Check that the Come Odds bet is placed successfully
        self.assertEqual(come_odds_bet.status, "active", "Come Odds bet should be active")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\old_tests\test_field_bet.py

import unittest
from craps.bet import Bet
from craps.rules_engine import RulesEngine
from craps.player import Player
from craps.house_rules import HouseRules

class TestFieldBet(unittest.TestCase):
    def setUp(self):
        """Set up test environment."""
        self.house_rules = HouseRules({
            "field_bet_payout_2": (2, 1),
            "field_bet_payout_12": (3, 1),
            "table_minimum": 10,
            "table_maximum": 5000
        })
        self.rules_engine = RulesEngine()
        self.player = Player("TestPlayer", 100)
        self.bet = Bet("Field", 10, self.player)
    
    def test_field_bet_wins(self):
        """Test Field bet winning conditions and payouts."""
        winning_rolls = {
            2: (2, 1),   # Special payout for 2
            3: (1, 1),
            4: (1, 1),
            9: (1, 1),
            10: (1, 1),
            11: (1, 1),
            12: (3, 1)   # Special payout for 12
        }
        
        for roll, expected_payout in winning_rolls.items():
            with self.subTest(roll=roll):
                self.bet.status = "active"  # Reset bet status
                payout = self.rules_engine.resolve_bet(self.bet, [roll], "come-out", None)
                expected_amount = (self.bet.amount * expected_payout[0]) // expected_payout[1]
                self.assertEqual(self.bet.status, "won")
                self.assertEqual(payout, expected_amount)
    
    def test_field_bet_loses(self):
        """Test Field bet losing conditions."""
        losing_rolls = [5, 6, 7, 8]
        for roll in losing_rolls:
            with self.subTest(roll=roll):
                self.bet.status = "active"  # Reset bet status
                payout = self.rules_engine.resolve_bet(self.bet, [roll], "come-out", None)
                self.assertEqual(self.bet.status, "lost")
                self.assertEqual(payout, 0)

if __name__ == "__main__":
    unittest.main()


# File: .\tests\old_tests\test_multiple_place_bets.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.table import Table
from craps.house_rules import HouseRules
from craps.play_by_play import PlayByPlay
from craps.player import Player

class TestMultiplePlaceBets(unittest.TestCase):
    def setUp(self):
        """Initialize multiple Place bets and the RulesEngine for testing."""
        # Initialize a player
        self.player = Player(name="Alice", initial_balance=1000)

        # Initialize house rules
        self.house_rules = HouseRules({
            "table_minimum": 10,
            "table_maximum": 5000,
        })

        # Initialize play-by-play and rules engine
        self.play_by_play = PlayByPlay()
        self.rules_engine = RulesEngine()

        # Initialize the table
        self.table = Table(self.house_rules, self.play_by_play, self.rules_engine)

        # Create Place bets on multiple numbers
        self.place_bet_6 = self.rules_engine.create_bet("Place", 100, self.player, number=6)
        self.place_bet_8 = self.rules_engine.create_bet("Place", 100, self.player, number=8)
        self.place_bet_5 = self.rules_engine.create_bet("Place", 100, self.player, number=5)

        # Place the bets on the table
        self.table.place_bet(self.place_bet_6, "point")
        self.table.place_bet(self.place_bet_8, "point")
        self.table.place_bet(self.place_bet_5, "point")

    def test_multiple_place_bets_resolution(self):
        """Test resolution of multiple Place bets."""
        # Simulate a roll of 6
        dice_outcome = [3, 3]  # Total of 6
        self.table.check_bets(dice_outcome, "point", None)
        resolved_bets = self.table.clear_resolved_bets()

        # Check that the Place bet on 6 is resolved as won
        self.assertEqual(self.place_bet_6.status, "won", "Place bet on 6 should win on 6")
        self.assertIn(self.place_bet_6, resolved_bets, "Place bet on 6 should be resolved")

        # Simulate a roll of 8
        dice_outcome = [4, 4]  # Total of 8
        self.table.check_bets(dice_outcome, "point", None)
        resolved_bets = self.table.clear_resolved_bets()

        # Check that the Place bet on 8 is resolved as won
        self.assertEqual(self.place_bet_8.status, "won", "Place bet on 8 should win on 8")
        self.assertIn(self.place_bet_8, resolved_bets, "Place bet on 8 should be resolved")

        # Simulate a roll of 7
        dice_outcome = [3, 4]  # Total of 7
        self.table.check_bets(dice_outcome, "point", None)
        resolved_bets = self.table.clear_resolved_bets()

        # Check that the Place bet on 5 is resolved as lost
        self.assertEqual(self.place_bet_5.status, "lost", "Place bet on 5 should lose on 7")
        self.assertIn(self.place_bet_5, resolved_bets, "Place bet on 5 should be resolved")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\old_tests\test_pass_line_bet_rules.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.table import Table
from craps.house_rules import HouseRules
from craps.play_by_play import PlayByPlay
from craps.player import Player

class TestPassLineBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize a Pass Line bet and the RulesEngine for testing."""
        # Initialize a player
        self.player = Player(name="Alice", initial_balance=1000)

        # Initialize house rules
        self.house_rules = HouseRules({
            "table_minimum": 10,
            "table_maximum": 5000,
        })

        # Initialize play-by-play and rules engine
        self.play_by_play = PlayByPlay()
        self.rules_engine = RulesEngine()

        # Initialize the table
        self.table = Table(self.house_rules, self.play_by_play, self.rules_engine)

        # Create a Pass Line bet
        self.pass_line_bet = self.rules_engine.create_bet("Pass Line", 100, self.player)

        # Place the bet on the table
        self.table.place_bet(self.pass_line_bet, "come-out")

    def test_come_out_phase(self):
        """Test Pass Line bet behavior during the come-out phase."""
        # Test winning rolls (7, 11)
        for dice_total in [7, 11]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = [dice_total // 2, dice_total // 2] if dice_total % 2 == 0 else [dice_total // 2, dice_total // 2 + 1]
                self.table.check_bets(dice_outcome, "come-out", None)
                self.assertEqual(self.pass_line_bet.status, "won", f"Pass Line bet should win on {dice_total}")

        # Test losing rolls (2, 3, 12)
        for dice_total in [2, 3, 12]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = [dice_total // 2, dice_total // 2] if dice_total % 2 == 0 else [dice_total // 2, dice_total // 2 + 1]
                self.table.check_bets(dice_outcome, "come-out", None)
                self.assertEqual(self.pass_line_bet.status, "lost", f"Pass Line bet should lose on {dice_total}")

        # Test setting the point (4, 5, 6, 8, 9, 10)
        for dice_total in [4, 5, 6, 8, 9, 10]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = [dice_total // 2, dice_total // 2] if dice_total % 2 == 0 else [dice_total // 2, dice_total // 2 + 1]
                self.table.check_bets(dice_outcome, "come-out", None)
                self.assertEqual(self.pass_line_bet.status, "active", f"Pass Line bet should remain active on {dice_total}")

    def test_point_phase(self):
        """Test Pass Line bet behavior during the point phase."""
        # Set the point to 6
        point = 6
        dice_outcome = [3, 3]  # Total of 6
        self.table.check_bets(dice_outcome, "come-out", None)
        self.assertEqual(self.pass_line_bet.status, "active", f"Pass Line bet should remain active on {point}")

        # Test rolls that do not resolve the bet (2, 3, 4, 5, 8, 9, 10, 11, 12)
        for dice_total in [2, 3, 4, 5, 8, 9, 10, 11, 12]:
            with self.subTest(dice_total=dice_total):
                dice_outcome = [dice_total // 2, dice_total // 2] if dice_total % 2 == 0 else [dice_total // 2, dice_total // 2 + 1]
                self.table.check_bets(dice_outcome, "point", point)
                self.assertEqual(self.pass_line_bet.status, "active", f"Pass Line bet should remain active on {dice_total}")

        # Test winning roll (point number)
        dice_outcome = [3, 3]  # Total of 6
        self.table.check_bets(dice_outcome, "point", point)
        self.assertEqual(self.pass_line_bet.status, "won", f"Pass Line bet should win on {point}")

        # Reset the bet for the next test
        self.pass_line_bet = self.rules_engine.create_bet("Pass Line", 100, self.player)
        self.table.place_bet(self.pass_line_bet, "come-out")
        self.table.check_bets([3, 3], "come-out", None)  # Set the point to 6 again

        # Test losing roll (7)
        dice_outcome = [3, 4]  # Total of 7
        self.table.check_bets(dice_outcome, "point", point)
        self.assertEqual(self.pass_line_bet.status, "lost", "Pass Line bet should lose on 7")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\old_tests\test_payouts.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bet import Bet
from craps.table import Table
from craps.house_rules import HouseRules
from craps.play_by_play import PlayByPlay
from craps.player import Player

class TestPayouts(unittest.TestCase):
    def setUp(self):
        """Initialize the test environment."""
        # Initialize a player
        self.player = Player(name="Alice", initial_balance=1000)

        # Initialize house rules
        self.house_rules = HouseRules({
            "table_minimum": 10,
            "table_maximum": 5000,
        })

        # Initialize play-by-play and rules engine
        self.play_by_play = PlayByPlay()
        self.rules_engine = RulesEngine()

        # Initialize the table
        self.table = Table(self.house_rules, self.play_by_play, self.rules_engine)

    def test_pass_line_bet_payout(self):
        """Test payout for a Pass Line bet."""
        # Create a Pass Line bet
        pass_line_bet = self.rules_engine.create_bet("Pass Line", 100, self.player)

        # Simulate a winning roll (7 during come-out)
        pass_line_bet.status = "won"
        payout = pass_line_bet.payout()
        self.assertEqual(payout, 200, "Pass Line bet should pay 1:1 ($100 bet + $100 profit)")

    def test_place_bet_payout(self):
        """Test payout for a Place bet."""
        # Create a Place bet on 6
        place_bet = self.rules_engine.create_bet("Place", 120, self.player, number=6)

        # Simulate a winning roll (6)
        place_bet.status = "won"
        payout = place_bet.payout()
        self.assertEqual(payout, 242, "Place bet on 6 should pay 7:6 ($120 bet + $122 profit)")

    def test_field_bet_payout(self):
        """Test payout for a Field bet."""
        # Create a Field bet
        field_bet = self.rules_engine.create_bet("Field", 100, self.player)

        # Simulate a winning roll (2)
        field_bet.status = "won"
        field_bet.payout_ratio = (2, 1)  # 2:1 payout for 2
        payout = field_bet.payout()
        self.assertEqual(payout, 300, "Field bet on 2 should pay 2:1 ($100 bet + $200 profit)")

        # Simulate a winning roll (12)
        field_bet.status = "won"
        field_bet.payout_ratio = (3, 1)  # 3:1 payout for 12
        payout = field_bet.payout()
        self.assertEqual(payout, 400, "Field bet on 12 should pay 3:1 ($100 bet + $300 profit)")

        # Simulate a winning roll (3, 4, 9, 10, 11)
        field_bet.status = "won"
        field_bet.payout_ratio = (1, 1)  # 1:1 payout for other winning numbers
        payout = field_bet.payout()
        self.assertEqual(payout, 200, "Field bet on other winning numbers should pay 1:1 ($100 bet + $100 profit)")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\old_tests\test_place_bet_rules.py

# File: .\tests\test_place_bet_rules.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bets.place_bet import PlaceBet

class TestPlaceBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize a Place bet and the RulesEngine for testing."""
        self.player_name = "Alice"
        self.bet_amount = 100
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)  # Place bet on 6
        self.rules_engine = RulesEngine()

    def test_point_phase(self):
        """Test Place bet behavior during the point phase."""
        # Test winning roll (6)
        dice_outcome = [3, 3]  # Total of 6
        self.rules_engine.resolve_bet(self.place_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_bet.status, "won", "Place bet should win on 6")

        # Reset the bet for the next test
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)

        # Test losing roll (7)
        dice_outcome = [3, 4]  # Total of 7
        self.rules_engine.resolve_bet(self.place_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_bet.status, "lost", "Place bet should lose on 7")

        # Reset the bet for the next test
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)

        # Test non-resolving roll (8)
        dice_outcome = [4, 4]  # Total of 8
        self.rules_engine.resolve_bet(self.place_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_bet.status, "active", "Place bet should remain active on 8")

if __name__ == "__main__":
    unittest.main()

# File: .\tests\old_tests\test_place_odds_bet_rules.py

import unittest
from craps.rules_engine import RulesEngine
from craps.bets.free_odds_bet import FreeOddsBet
from craps.bets.place_bet import PlaceBet

class TestPlaceOddsBetRules(unittest.TestCase):
    def setUp(self):
        """Initialize a Place Odds bet and the RulesEngine for testing."""
        self.player_name = "Alice"
        self.bet_amount = 100
        self.rules_engine = RulesEngine()

        # Create a Place bet and a Place Odds bet linked to it
        self.place_bet = PlaceBet(self.bet_amount, self.player_name, number=6)
        self.place_odds_bet = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet)

    def test_place_odds_resolution(self):
        """Test Place Odds bet resolution during the point phase."""
        # Test winning roll (6)
        dice_outcome = [3, 3]  # Total of 6
        self.rules_engine.resolve_bet(self.place_odds_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_odds_bet.status, "won", "Place Odds bet should win on 6")

        # Reset the bet for the next test
        self.place_odds_bet = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet)

        # Test losing roll (7)
        dice_outcome = [3, 4]  # Total of 7
        self.rules_engine.resolve_bet(self.place_odds_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_odds_bet.status, "lost", "Place Odds bet should lose on 7")

        # Reset the bet for the next test
        self.place_odds_bet = FreeOddsBet("Place Odds", self.bet_amount, self.player_name, parent_bet=self.place_bet)

        # Test non-resolving roll (8)
        dice_outcome = [4, 4]  # Total of 8
        self.rules_engine.resolve_bet(self.place_odds_bet, dice_outcome, "point", None)
        self.assertEqual(self.place_odds_bet.status, "active", "Place Odds bet should remain active on 8")

    def test_payout_ratio(self):
        """Test payout ratio for Place Odds bets."""
        # Test payout ratio for Place Odds on 6
        payout_ratio = self.rules_engine.get_payout_ratio("Place Odds", number=6)
        self.assertEqual(payout_ratio, (6, 5), "Place Odds bet on 6 should have a payout ratio of 6:5")

        # Test payout ratio for Place Odds on 4
        payout_ratio = self.rules_engine.get_payout_ratio("Place Odds", number=4)
        self.assertEqual(payout_ratio, (2, 1), "Place Odds bet on 4 should have a payout ratio of 2:1")

    def test_place_odds_linked_to_place_bet(self):
        """Test that Place Odds bets are linked to Place bets."""
        linked_bet_type = self.rules_engine.get_linked_bet_type("Place")
        self.assertEqual(linked_bet_type, "Place Odds", "Place bets should be linked to Place Odds")

    def test_place_odds_cannot_be_placed_during_come_out(self):
        """Test that Place Odds bets cannot be placed during the come-out phase."""
        self.assertFalse(
            self.rules_engine.can_make_bet("Place Odds", "come-out", parent_bet=self.place_bet),
            "Place Odds bets should not be allowed during the come-out phase"
        )

    def test_place_odds_can_be_placed_during_point_phase(self):
        """Test that Place Odds bets can be placed during the point phase."""
        self.assertTrue(
            self.rules_engine.can_make_bet("Place Odds", "point", parent_bet=self.place_bet),
            "Place Odds bets should be allowed during the point phase"
        )

if __name__ == "__main__":
    unittest.main()

# File: .\tests\old_tests\test_player.py

import unittest
from craps.player import Player
from craps.table import Table
from craps.bet import Bet

class TestPlayer(unittest.TestCase):
    def test_place_bet(self):
        player = Player("Alice", 1000)
        table = Table()
        player.place_bet("Pass Line", 100, table)
        self.assertEqual(player.balance, 900)
        self.assertEqual(len(player.bets), 1)
        self.assertEqual(len(table.bets), 1)

    def test_resolve_bets(self):
        player = Player("Alice", 1000)
        table = Table()
        bet = Bet("Pass Line", 100, "Alice")
        table.place_bet(bet)
        player.bets.append(bet)

        # Simulate a win
        bet.status = "won"
        player.resolve_bets(table)
        self.assertEqual(player.balance, 1100)
        self.assertEqual(len(player.bets), 0)

if __name__ == "__main__":
    unittest.main()

