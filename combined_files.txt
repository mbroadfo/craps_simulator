# File: .\config.py

# File: config.py

ACTIVE_PLAYERS = {
    "Pass-Line": True,
    "Pass-Line w/ Odds": True,
    "$44 Inside": True,
    "$54 Across": True,
    "Field": True,
    "Iron Cross": True,
}

# Add a new configuration entry for session mode
SESSION_MODE = "history"  # Options: "live" or "history"

# File: .\dump_py.py

import os

def dump_python_files(directory, output_file):
    # Open the output file in write mode
    with open(output_file, 'w', encoding='utf-8') as outfile:
        # Walk through the directory
        for root, _, files in os.walk(directory):
            for file in files:
                if file.endswith('.py'):  # Only process Python files
                    file_path = os.path.join(root, file)
                    # Write the file name as a header
                    outfile.write(f"# File: {file_path}\n\n")
                    # Read and write the content of the file
                    with open(file_path, 'r', encoding='utf-8') as infile:
                        outfile.write(infile.read())
                    outfile.write("\n\n")  # Add some space between files

# Specify the directory containing your Python files and the output file
project_directory = '.'  # Current directory (change as needed)
output_file = 'combined_files.txt'

# Combine the files
dump_python_files(project_directory, output_file)
print(f"All Python files have been combined into {output_file}")

# File: .\main.py

# File: main.py
from colorama import init, Fore, Style
init()  # Initialize colorama for colored text

from config import ACTIVE_PLAYERS, SESSION_MODE
from craps.house_rules import HouseRules
from craps.table import Table
from craps.lineup import PlayerLineup
from craps.single_session import run_single_session
from craps.roll_history_manager import RollHistoryManager  # Import the new class

def main():
    # Initialize the RollHistoryManager
    roll_history_manager = RollHistoryManager()

    try:
        # Prepare for the session based on the session mode
        roll_history_manager.prepare_for_session(SESSION_MODE)
    except (ValueError, FileNotFoundError) as e:
        print(f"Error: {e}")
        return

    # Initialize house rules
    house_rules = HouseRules()
    house_rules.set_field_bet_payouts((3, 1), (2, 1))  # 3:1 for 2, 2:1 for 12
    house_rules.set_table_limits(10, 1000)  # Table limits

    # Create the Table object
    table = Table(house_rules)

    # Initialize the player lineup
    player_lineup = PlayerLineup(house_rules, table)

    # Get active strategies and player names
    strategies, player_names = player_lineup.get_active_players(ACTIVE_PLAYERS)

    # Run the session
    stats = run_single_session(
        house_rules,
        strategies,
        player_names=player_names,
        roll_history_file=roll_history_manager.roll_history_file if SESSION_MODE == "history" else None
    )

    # Save the roll history if running in live mode
    if SESSION_MODE == "live":
        roll_history_manager.save_roll_history(stats.roll_history)

    # Print statistics
    stats.print_statistics()
    stats.print_shooter_report()

if __name__ == "__main__":
    main()

# File: .\setup.py

from setuptools import setup, find_packages

setup(
    name="craps_simulator",
    version="0.1",
    packages=find_packages(),
)

# File: .\craps\bet.py

# File: .\craps\bet.py

class Bet:
    """Base class for all bet types."""
    def __init__(self, bet_type, amount, owner, payout_ratio=(1, 1), locked=True, vig=0):
        """
        Initialize a bet.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Come").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param payout_ratio: The payout ratio as a tuple (numerator, denominator).
        :param locked: Whether the bet is locked (cannot be taken down).
        :param vig: The vig (commission) as a percentage of the bet amount.
        """
        self.bet_type = bet_type
        self.amount = amount
        self.owner = owner
        self.payout_ratio = payout_ratio
        self.locked = locked
        self.vig = vig
        self.status = "active"  # Can be "active", "won", "lost", or "pushed"

    def resolve(self, outcome, phase, point):
        """
        Resolve the bet based on the dice outcome, phase, and point.
        
        :param outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        raise NotImplementedError("Subclasses must implement this method.")

    def payout(self):
        """
        Calculate the payout for the bet.
        - For Pass-Line bets: Return the total payout (original bet + profit).
        - For Place bets: Return the profit only (original bet remains on the table).
        """
        if self.status != "won":
            return 0  # No payout if the bet is not won
        
        # Calculate the profit based on the payout ratio
        numerator, denominator = self.payout_ratio
        profit = self.amount * numerator // denominator
        
        # Deduct the vig (if applicable)
        if self.vig > 0:
            vig_amount = self.amount * self.vig // 100
            profit -= vig_amount
        
        # Return the total payout for Pass-Line bets or profit only for Place bets
        if self.bet_type == "Pass Line":
            return self.amount + profit  # Total payout (original bet + profit)
        else:
            return profit  # Profit only (original bet remains on the table)

    def is_resolved(self):
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def __str__(self):
        return f"{self.owner}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"

# File: .\craps\betting_strategy.py

# File: .\craps\strategies\pass_line.py

from craps.bet_factory import BetFactory

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                return None  # No new bet to place

            # Use the BetFactory to create a Pass Line bet
            return BetFactory.create_pass_line_bet(self.min_bet, player.name)
        return None  # No bet to place

# File: .\craps\bet_factory.py

# File: craps/bet_factory.py

from .bets.pass_line import PassLineBet  # Import PassLineBet
from .bets.place_bet import PlaceBet  # Import PlaceBet
from .bets.free_odds import FreeOddsBet  # Import PlaceOddsBet
from .bets.field_bet import FieldBet  # Import FieldBet

class BetFactory:
    @staticmethod
    def create_pass_line_bet(amount, owner):
        """Create a Pass Line bet."""
        return PassLineBet(amount, owner)

    @staticmethod
    def create_place_bet(amount, owner, number):
        """Create a Place bet."""
        return PlaceBet(amount, owner, number)

    @staticmethod
    def create_pass_line_odds_bet(amount, owner):
        """Create a Pass Line Odds bet."""
        return FreeOddsBet("Pass Line Odds", amount, owner)

    @staticmethod
    def create_place_odds_bet(amount, owner, number):
        """Create a Place Odds bet."""
        return FreeOddsBet("Place Odds", amount, owner, number)

    @staticmethod
    def create_field_bet(amount, owner):
        """Create a Field bet."""
        return FieldBet(amount, owner)

    @staticmethod
    def create_bets(bet_type, amount, owner, number=None):
        """
        Create one or more bets based on the bet type.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Place", "Place Odds", "Field").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param number: The number for Place or Place Odds bets (optional).
        :return: A single bet or a list of bets.
        """
        if bet_type == "Pass Line":
            return BetFactory.create_pass_line_bet(amount, owner)
        elif bet_type == "Place":
            return BetFactory.create_place_bet(amount, owner, number)
        elif bet_type == "Place Odds":
            return BetFactory.create_place_odds_bet(amount, owner, number)
        elif bet_type == "Field":
            return BetFactory.create_field_bet(amount, owner)
        else:
            raise ValueError(f"Unknown bet type: {bet_type}")

# File: .\craps\dice.py

import csv
import random

class Dice:
    def __init__(self, roll_history_file=None):
        """
        Initialize the Dice class.
        
        :param roll_history_file: Path to a CSV file containing roll history. If None, rolls are random.
        """
        self.values = [1, 1]
        self.roll_history_file = roll_history_file
        self.roll_history = []
        self.current_roll_index = 0

        if self.roll_history_file:
            self._load_roll_history()

    def _load_roll_history(self):
        """Load roll history from a CSV file."""
        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to integers
                dice = [int(die) for die in row["dice"].strip('[]').split(', ')]
                total = int(row["total"])
                shooter_num = int(row["shooter_num"])
                self.roll_history.append({
                    "dice": dice,
                    "total": total,
                    "shooter_num": shooter_num
                })

    def roll(self):
        """Roll the dice. If roll history is loaded, use the next roll from the history."""
        if self.roll_history:
            if self.current_roll_index >= len(self.roll_history):
                raise IndexError("No more rolls in the history.")
            roll = self.roll_history[self.current_roll_index]
            self.values = roll["dice"]
            self.current_roll_index += 1
            return roll["dice"]
        else:
            # Generate random rolls if no history is loaded
            self.values = [random.randint(1, 6), random.randint(1, 6)]
            return self.values

# File: .\craps\game_state.py

# File: craps/game_state.py

from colorama import Fore, Style
from craps.puck import Puck
import logging
class GameState:
    def __init__(self, stats, players):
        """
        Initialize the game state.
        
        :param stats: The Statistics object to track point number rolls.
        :param players: The list of players in the game.
        """
        self.phase = "come-out"
        self.point = None
        self.puck = Puck()
        self.shooter = None
        self.stats = stats  # Store the stats object
        self.players = players  # Store the players list

    def set_shooter(self, shooter):
        """Set the current shooter and reset their statistics."""
        self.shooter = shooter
        self.shooter.reset_stats()
        logging.info(f"\n{Fore.CYAN}New Shooter: {shooter.name}{Fore.YELLOW} Puck is {self.puck.position.upper()}{Style.RESET_ALL}")

    def update_state(self, dice_outcome):
        """Update the game state based on the dice outcome."""
        total = sum(dice_outcome)
        message = None

        if self.phase == "come-out":
            if total in [7, 11]:
                self.puck.reset()
                message = f"{Fore.GREEN}✅ 7-Winner: Pass Line bets win!{Fore.YELLOW} Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
            elif total in [2, 3, 12]:
                self.puck.reset()
                message = f"{Fore.RED}❌ Craps: Pass Line bets lose!{Fore.YELLOW} Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
            else:
                self.phase = "point"
                self.puck.set_point(total)
                self.point = total
                message = f"{Fore.YELLOW}Point Set: {total}. Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
                # Reactivate inactive Place bets
                reactivated_bets = []
                for player in self.players:
                    for bet in player.active_bets:
                        if bet.bet_type.startswith("Place") and bet.status == "inactive":
                            bet.status = "active"
                            reactivated_bets.append(f"{player.name}'s {bet.bet_type}")
                if reactivated_bets:
                    logging.info(f"{', '.join(reactivated_bets)} are now ON.")
        else:  # Point phase
            if total == self.puck.point:
                self.shooter.points_rolled += 1  # Increment points rolled
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"{Fore.GREEN}✅ Point Hit: {total}. Pass Line bets win!{Fore.YELLOW} Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
            elif total == 7:
                self.shooter.rolls_before_7_out = self.shooter.current_roll_count  # Record rolls before 7-out
                self.puck.reset()
                self.phase = "come-out"
                self.point = None
                message = f"{Fore.RED}❌ 7-Out: Pass Line bets lose!{Fore.YELLOW} Puck is {self.puck.position.upper()}.{Style.RESET_ALL}"
            elif total in [4, 5, 6, 8, 9, 10]:  # Point number rolled during point phase
                self.stats.record_point_number_roll()  # Record the roll number

        return message

    def get_puck_state(self):
        if self.puck.position == "On":
            return f"Puck is ON (Point: {self.puck.point})"
        else:
            return "Puck is OFF (Come-out phase)"

    def __str__(self):
        return f"Game State: {self.get_puck_state()}"

# File: .\craps\house_rules.py

# File: craps/house_rules.py
class HouseRules:
    """Class representing house rules for payouts and table limits."""
    def __init__(self):
        # Default payout ratios for Field Bet
        self.field_bet_payout_2 = (2, 1)  # 2:1 payout for 2
        self.field_bet_payout_12 = (3, 1)  # 3:1 payout for 12

        # Table limits
        self.table_minimum = 10  # Minimum bet amount
        self.table_maximum = 5000  # Maximum bet amount

    def set_field_bet_payouts(self, payout_2, payout_12):
        """Set the payout ratios for the Field Bet."""
        self.field_bet_payout_2 = payout_2
        self.field_bet_payout_12 = payout_12

    def set_table_limits(self, minimum, maximum):
        """Set the table limits."""
        self.table_minimum = minimum
        self.table_maximum = maximum

# File: .\craps\lineup.py

# File: lineup.py
from craps.strategies.pass_line import PassLineStrategy
from craps.strategies.pass_line_odds import PassLineOddsStrategy
from craps.strategies.place_bet import PlaceBetStrategy
from craps.strategies.field_bet import FieldBetStrategy
from craps.strategies.iron_cross import IronCrossStrategy

class PlayerLineup:
    """Class to manage the lineup of players and their strategies."""
    def __init__(self, house_rules, table):
        """
        Initialize the player lineup.
        
        :param house_rules: The HouseRules object for table limits and payouts.
        :param table: The Table object for placing bets.
        """
        self.house_rules = house_rules
        self.table = table

        # Define all possible strategies and their names
        self.all_strategies = {
            "Pass-Line": PassLineStrategy(min_bet=self.house_rules.table_minimum),
            "Pass-Line w/ Odds": PassLineOddsStrategy(table=self.table, odds_multiple=1),
            "$44 Inside": PlaceBetStrategy(table=self.table, numbers_or_strategy="inside"),
            "$54 Across": PlaceBetStrategy(table=self.table, numbers_or_strategy="across"),
            "Field": FieldBetStrategy(min_bet=self.house_rules.table_minimum),
            "Iron Cross": IronCrossStrategy(table=self.table, min_bet=self.house_rules.table_minimum),
        }

    def get_active_players(self, active_players_config):
        """
        Get the list of active strategies and player names based on the configuration.
        
        :param active_players_config: A dictionary specifying which players are active.
        :return: A tuple of (strategies, player_names).
        """
        strategies = [strategy for name, strategy in self.all_strategies.items() if active_players_config.get(name, False)]
        player_names = [name for name, active in active_players_config.items() if active]
        return strategies, player_names

# File: .\craps\player.py

# File: .\craps\player.py

from craps.bet import Bet
import logging

class Player:
    def __init__(self, name, initial_balance=500, betting_strategy=None):
        """
        Initialize a player.
        
        :param name: The name of the player.
        :param initial_balance: The initial bankroll of the player.
        :param betting_strategy: The betting strategy used by the player.
        """
        self.name = name
        self.balance = initial_balance
        self.betting_strategy = betting_strategy
        self.active_bets = []  # Track active bets for this player

    def place_bet(self, bet, table):
        """Place a bet (or multiple bets) on the table and deduct the amount from the player's balance."""
        # Convert single bet to a list for uniform handling
        bets = [bet] if not isinstance(bet, list) else bet

        # Calculate the total amount to be wagered
        total_amount = sum(b.amount for b in bets)

        # Check if the player has sufficient funds
        if total_amount > self.balance:
            logging.info(f"{self.name} has insufficient funds to place ${total_amount} in bets.")
            return False

        # Place each bet and deduct the amount from the player's balance
        for b in bets:
            self.balance -= b.amount
            table.place_bet(b)
            self.active_bets.append(b)

        # Calculate the total amount at risk on the table
        total_at_risk = sum(b.amount for b in self.active_bets)

        # Summarize the bets placed
        if len(bets) == 1:
            logging.info(f"{self.name} placed a ${bets[0].amount} {bets[0].bet_type} bet. Bankroll: ${self.balance}. Bet: ${total_at_risk}")
        else:
            bet_summary = ", ".join(f"{b.bet_type} ${b.amount}" for b in bets)
            logging.info(f"{self.name} bet ${total_amount} on {bet_summary}. Bankroll: ${self.balance}. Bet: ${total_at_risk}")

        return True

    def resolve_bets(self, table, stats, outcome, phase, point):
        """Resolve all active bets for the player and update the bankroll."""
        won_lost_bets = []
        total_payout = 0
        bets_changed = False  # Track if any bets were resolved or changed

        # Create a copy of active_bets to avoid modifying the list while iterating
        active_bets_copy = self.active_bets.copy()

        for bet in active_bets_copy:
            # Resolve the bet (let the bet class handle the logic)
            bet.resolve(outcome, phase, point)  # Pass phase and point directly

            if bet.status == "won":
                # Calculate the payout
                payout = bet.payout()
                total_payout += payout
                won_lost_bets.append(f"{bet.bet_type} bet WON ${payout}")
                self.balance += payout  # Add the payout to the player's bankroll
                stats.total_player_win_loss += payout  # Update player win/loss (total payout)
                stats.total_house_win_loss -= payout  # Update house win/loss (loss of total payout)

                # Remove Pass-Line bets from the table when won
                if bet.bet_type == "Pass Line":
                    self.active_bets.remove(bet)
                    bets_changed = True
                # Reset the Place bet status to "active" after winning
                elif bet.bet_type.startswith("Place"):
                    bet.status = "active"
                    bets_changed = True
            elif bet.status == "lost":
                won_lost_bets.append(f"{bet.bet_type} bet LOST ${bet.amount}")
                # Do NOT deduct the bet amount again (it was already deducted when the bet was placed)
                stats.total_player_win_loss -= 0  # No additional loss for the player
                stats.total_house_win_loss += bet.amount  # House collects the original bet

                # Remove lost bets from the table
                self.active_bets.remove(bet)
                bets_changed = True
            elif bet.status == "inactive":
                # Do NOT remove inactive bets; they will be reactivated when the puck is turned on
                pass

        # Print summary of resolved bets
        if won_lost_bets:
            logging.info(f"{self.name}'s resolved bets: {', '.join(won_lost_bets)}. Total Payout: ${total_payout}. Updated Bankroll: ${self.balance}. Bet: ${sum(b.amount for b in self.active_bets)}")

        # Summarize bets still on the table for the player (only if bets changed)
        if bets_changed:
            active_bets_summary = [
                f"{bet.bet_type}{' (Off)' if bet.status == 'inactive' else ''}"
                for bet in self.active_bets
            ]
            if active_bets_summary:
                logging.info(f"{self.name}'s active bets: {', '.join(active_bets_summary)}")
            else:
                logging.info(f"{self.name} has no active bets.")

    def __str__(self):
        return f"Player: {self.name}, Balance: ${self.balance}"

# File: .\craps\puck.py

class Puck:
    def __init__(self):
        self.position = "Off"
        self.point = None

    def set_point(self, value):
        self.position = "On"
        self.point = value

    def reset(self):
        self.position = "Off"
        self.point = None

# File: .\craps\roll_history_manager.py

import os
import csv

class RollHistoryManager:
    def __init__(self, output_folder="output", roll_history_file="single_session_roll_history.csv"):
        """
        Initialize the RollHistoryManager.
        
        :param output_folder: The folder where roll history files are stored.
        :param roll_history_file: The name of the roll history file.
        """
        self.output_folder = output_folder
        self.roll_history_file = os.path.join(output_folder, roll_history_file)

    def ensure_output_folder_exists(self):
        """Ensure the output folder exists. Create it if it doesn't."""
        if not os.path.exists(self.output_folder):
            os.makedirs(self.output_folder)
            print(f"Created output folder: {self.output_folder}")

    def delete_roll_history_file(self):
        """Delete the roll history file if it exists."""
        if os.path.exists(self.roll_history_file):
            os.remove(self.roll_history_file)
            print(f"Deleted existing roll history file: {self.roll_history_file}")

    def save_roll_history(self, roll_history):
        """
        Save the roll history to a CSV file.
        
        :param roll_history: A list of dictionaries representing the roll history.
        """
        with open(self.roll_history_file, 'w', newline='', encoding='utf-8') as csvfile:
            fieldnames = ["shooter_num", "roll_number", "dice", "total", "phase", "point"]
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

            # Write the header
            writer.writeheader()

            # Write the roll history
            for roll in roll_history:
                writer.writerow(roll)

        print(f"Roll history saved to: {self.roll_history_file}")

    def load_roll_history(self):
        """
        Load the roll history from a CSV file.
        
        :return: A list of dictionaries representing the roll history.
        """
        if not os.path.exists(self.roll_history_file):
            raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found.")

        roll_history = []
        with open(self.roll_history_file, 'r', newline='', encoding='utf-8') as csvfile:
            reader = csv.DictReader(csvfile)
            for row in reader:
                # Convert dice and total to integers
                row["roll_number"] = int(row["roll_number"])
                row["shooter_num"] = int(row["shooter_num"])
                row["dice"] = [int(die) for die in row["dice"].strip('[]').split(', ')]
                row["total"] = int(row["total"])
                roll_history.append(row)

        print(f"Roll history loaded from: {self.roll_history_file}")
        return roll_history

    def validate_session_mode(self, session_mode):
        """
        Validate the session mode.
        
        :param session_mode: The session mode ("live" or "history").
        :raises ValueError: If the session mode is invalid.
        """
        if session_mode not in ["live", "history"]:
            raise ValueError(f"Invalid SESSION_MODE '{session_mode}'. Must be 'live' or 'history'.")

    def prepare_for_session(self, session_mode):
        """
        Prepare for the session based on the session mode.
        
        :param session_mode: The session mode ("live" or "history").
        :raises FileNotFoundError: If the roll history file is missing in history mode.
        """
        self.validate_session_mode(session_mode)
        self.ensure_output_folder_exists()

        if session_mode == "live":
            self.delete_roll_history_file()
            print("Running session in 'live' mode with random rolls.")
        elif session_mode == "history":
            if not os.path.exists(self.roll_history_file):
                raise FileNotFoundError(f"Roll history file '{self.roll_history_file}' not found. Please run in 'live' mode first.")
            print(f"Running session in 'history' mode using roll history from: {self.roll_history_file}")

# File: .\craps\shooter.py

from craps.player import Player
from craps.dice import Dice

class Shooter(Player):
    def __init__(self, name, initial_balance=0, betting_strategy=None, dice=None):
        super().__init__(name, initial_balance, betting_strategy)
        self.dice = dice if dice else Dice()  # Use provided Dice instance or create a new one
        self.points_rolled = 0  # Number of times the shooter rolled the point
        self.rolls_before_7_out = 0  # Number of rolls before 7-ing out
        self.current_roll_count = 0  # Tracks rolls in the current turn

    def roll_dice(self):
        """Roll the dice and update shooter statistics."""
        outcome = self.dice.roll()
        self.current_roll_count += 1
        return outcome

    def reset_stats(self):
        """Reset shooter statistics for a new turn."""
        self.points_rolled = 0
        self.rolls_before_7_out = 0
        self.current_roll_count = 0

# File: .\craps\simulation_manager.py

# File: craps/simulation_manager.py
from craps.single_session import run_single_session

class SimulationManager:
    def __init__(self, house_rules, num_tables, num_shooters, strategies):
        """
        Initialize the SimulationManager.
        
        :param house_rules: The HouseRules object for payout rules and limits.
        :param num_tables: The number of tables to simulate.
        :param num_shooters: The number of shooters per session.
        :param strategies: A list of betting strategies to evaluate.
        """
        self.house_rules = house_rules
        self.num_tables = num_tables
        self.num_shooters = num_shooters
        self.strategies = strategies
        self.stats = Statistics(house_rules.table_minimum, num_shooters, len(strategies))

    def run_simulation(self, num_sessions):
        """Run multiple sessions and collect statistics."""
        for _ in range(num_sessions):
            for _ in range(self.num_tables):
                stats = run_single_session(self.house_rules, self.strategies, num_shooters=self.num_shooters)
                self.stats.merge(stats)  # Merge session stats into overall stats

        self.stats.print_statistics()
        self.stats.print_shooter_report()

# File: .\craps\single_session.py

# File: craps/single_session.py

from colorama import init, Fore, Style
from craps.table import Table
from craps.game_state import GameState
from craps.shooter import Shooter
from craps.dice import Dice
from craps.statistics import Statistics
from craps.visualizer import Visualizer
import os

def run_single_session(house_rules, strategies, player_names=None, initial_bankroll=500, num_shooters=10, roll_history_file=None):
    """
    Run a single session of craps and log the roll history.
    """
    # Print session mode
    if roll_history_file and os.path.exists(roll_history_file):
        print(f"Running session in 'history' mode using roll history from: {roll_history_file}")
        dice = Dice(roll_history_file)  # Use the roll history file for dice rolls
    else:
        print("Running session in 'live' mode with random rolls.")
        dice = Dice()  # Use random rolls

    # Initialize components
    table = Table(house_rules)
    stats = Statistics(house_rules.table_minimum, num_shooters, len(strategies))
    game_state = GameState(stats, players=[])

    # Create players with different betting strategies
    if player_names is None:
        player_names = [f"Player {i+1}" for i in range(len(strategies))]

    players = [
        Shooter(player_names[i], initial_balance=initial_bankroll, betting_strategy=strategy, dice=dice)
        for i, strategy in enumerate(strategies)
    ]
    game_state.players = players

    # Initialize bankroll history with the starting bankroll for each player
    stats.initialize_bankroll_history(players)

    # Initialize roll history
    roll_history = []

    # Simulate shooters
    for shooter_num in range(1, num_shooters + 1):
        player_index = (shooter_num - 1) % len(players)
        shooter = players[player_index]
        game_state.set_shooter(shooter)

        while True:
            # Allow all players to place bets
            for player in players:
                bet = player.betting_strategy.get_bet(game_state, player)
                if bet:
                    player.place_bet(bet, table)

            # Roll the dice and resolve bets
            outcome = shooter.roll_dice()
            total = sum(outcome)
            stats.update_rolls()

            # Log the roll to the history
            roll_history.append({
                "shooter_num": shooter_num,
                "roll_number": stats.num_rolls,
                "dice": outcome,
                "total": total,
                "phase": game_state.phase,
                "point": game_state.point
            })

            # Print the dice roll and total
            print(f"{Fore.LIGHTMAGENTA_EX}{shooter.name} rolled: {outcome} (Total: {total}) | Roll Count: {stats.num_rolls}{Style.RESET_ALL}")

            # Check bets on the table
            table.check_bets(outcome, game_state.phase, game_state.point)

            # Resolve bets for each player and update their bankroll
            for player in players:
                player.resolve_bets(table, stats, outcome, game_state.phase, game_state.point)

            # Update player bankrolls in statistics
            stats.update_player_bankrolls(players)
            
            # Update game state
            previous_phase = game_state.phase
            message = game_state.update_state(outcome)
            if message:
                print(message)

            # Check if the shooter 7-outs
            if previous_phase == "point" and total == 7:
                stats.record_seven_out()
                break

    # Visualize player bankrolls
    visualizer = Visualizer(stats)
    visualizer.visualize_bankrolls()

    # Return stats and roll history
    stats.roll_history = roll_history
    return stats

# File: .\craps\statistics.py

## File: craps/statistics.py

import logging
class Statistics:
    def __init__(self, table_minimum, num_shooters, num_players):
        self.table_minimum = table_minimum
        self.num_shooters = num_shooters
        self.num_players = num_players
        self.num_rolls = 0
        self.total_house_win_loss = 0
        self.total_player_win_loss = 0
        self.player_bankrolls = []
        self.highest_bankroll = 0
        self.lowest_bankroll = float('inf')
        self.shooter_stats = {}

        # For visualization
        self.roll_numbers = [0]  # Start with roll 0
        self.bankroll_history = {}  # Track bankroll history for each player
        self.seven_out_rolls = []  # Track rolls where a 7-out occurs
        self.point_number_rolls = []  # Track rolls where a point number (4, 5, 6, 8, 9, 10) is rolled
        
    def initialize_bankroll_history(self, players):
        """Initialize bankroll history with the starting bankroll for each player."""
        for player in players:
            self.bankroll_history[player.name] = [player.balance]  # Roll 0: initial bankroll

    def merge(self, other_stats):
        """Merge statistics from another session."""
        self.num_rolls += other_stats.num_rolls
        self.total_house_win_loss += other_stats.total_house_win_loss
        self.total_player_win_loss += other_stats.total_player_win_loss
        self.player_bankrolls.extend(other_stats.player_bankrolls)
        self.highest_bankroll = max(self.highest_bankroll, other_stats.highest_bankroll)
        self.lowest_bankroll = min(self.lowest_bankroll, other_stats.lowest_bankroll)
        self.roll_numbers.extend(other_stats.roll_numbers)
        self.seven_out_rolls.extend(other_stats.seven_out_rolls)
        self.point_number_rolls.extend(other_stats.point_number_rolls)

        # Merge shooter stats
        for shooter_name, stats in other_stats.shooter_stats.items():
            if shooter_name not in self.shooter_stats:
                self.shooter_stats[shooter_name] = {
                    "points_rolled": 0,
                    "rolls_before_7_out": [],
                    "total_rolls": 0,
                }
            self.shooter_stats[shooter_name]["points_rolled"] += stats["points_rolled"]
            self.shooter_stats[shooter_name]["rolls_before_7_out"].extend(stats["rolls_before_7_out"])
            self.shooter_stats[shooter_name]["total_rolls"] += stats["total_rolls"]

        # Merge bankroll history
        for player, bankrolls in other_stats.bankroll_history.items():
            if player not in self.bankroll_history:
                self.bankroll_history[player] = []
            self.bankroll_history[player].extend(bankrolls)

    def update_rolls(self):
        """Increment the roll count."""
        self.num_rolls += 1
        self.roll_numbers.append(self.num_rolls)

    def update_player_bankrolls(self, players):
        """Update player bankrolls and track highest/lowest bankroll."""
        self.player_bankrolls = [player.balance for player in players]
        self.highest_bankroll = max(self.player_bankrolls)
        self.lowest_bankroll = min(self.player_bankrolls)

        # Track bankroll history for visualization
        for player in players:
            if player.name not in self.bankroll_history:
                self.bankroll_history[player.name] = []
            self.bankroll_history[player.name].append(player.balance)

    def record_seven_out(self):
        """Record the roll number where a 7-out occurs."""
        self.seven_out_rolls.append(self.num_rolls)
        
    def record_point_number_roll(self):
        """Record the roll number where a point number (4, 5, 6, 8, 9, 10) is rolled."""
        self.point_number_rolls.append(self.num_rolls)

    def visualize_bankrolls(self):
        """Visualize player bankrolls over time."""
        import matplotlib.pyplot as plt

        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.bankroll_history.items():
            # Ensure bankrolls and roll_numbers have the same length
            if len(bankrolls) != len(self.roll_numbers):
                # Trim the longer list to match the shorter one
                min_length = min(len(bankrolls), len(self.roll_numbers))
                bankrolls = bankrolls[:min_length]
                roll_numbers = self.roll_numbers[:min_length]
            else:
                roll_numbers = self.roll_numbers
            plt.plot(roll_numbers, bankrolls, label=player)

        # Add red vertical lines for 7-out events
        for roll in self.seven_out_rolls:
            plt.axvline(x=roll, color='red', linestyle='--', alpha=0.5, label='7-Out' if roll == self.seven_out_rolls[0] else "")

        # Add green dotted lines for point number rolls
        for roll in self.point_number_rolls:
            plt.axvline(x=roll, color='green', linestyle=':', alpha=0.5, label='Point Number Rolled' if roll == self.point_number_rolls[0] else "")

        # Add labels and title
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)
        plt.show()

    def update_shooter_stats(self, shooter):
        """Update shooter statistics."""
        if shooter.name not in self.shooter_stats:
            self.shooter_stats[shooter.name] = {
                "points_rolled": 0,
                "rolls_before_7_out": [],
                "total_rolls": 0,
            }
        self.shooter_stats[shooter.name]["points_rolled"] += shooter.points_rolled
        self.shooter_stats[shooter.name]["rolls_before_7_out"].append(shooter.rolls_before_7_out)
        self.shooter_stats[shooter.name]["total_rolls"] += shooter.current_roll_count

    def print_statistics(self):
        """Print the simulation statistics."""
        logging.info("\n=== Simulation Statistics ===")
        logging.info(f"Table Minimum: ${self.table_minimum}")
        logging.info(f"Number of Shooters: {self.num_shooters}")
        logging.info(f"Number of Players: {self.num_players}")
        logging.info(f"Number of Rolls: {self.num_rolls}")
        logging.info(f"Total House Win/Loss: ${self.total_house_win_loss}")
        logging.info(f"Total Player Win/Loss: ${self.total_player_win_loss}")
        logging.info(f"Player Bankrolls: {self.player_bankrolls}")
        logging.info(f"Highest Player Bankroll: ${self.highest_bankroll}")
        logging.info(f"Lowest Player Bankroll: ${self.lowest_bankroll}")

    def print_shooter_report(self):
        """Print a report summarizing each shooter's performance."""
        logging.info("\n=== Shooter Performance Report ===")
        for shooter_name, stats in self.shooter_stats.items():
            total_points_rolled = stats["points_rolled"]
            total_rolls = stats["total_rolls"]
            rolls_before_7_out = stats["rolls_before_7_out"]
            avg_rolls_before_7_out = sum(rolls_before_7_out) / len(rolls_before_7_out) if rolls_before_7_out else 0

            logging.info(f"\nShooter: {shooter_name}")
            logging.info(f"  Total Points Rolled: {total_points_rolled}")
            logging.info(f"  Total Rolls: {total_rolls}")
            logging.info(f"  Average Rolls Before 7-Out: {avg_rolls_before_7_out:.2f}")
            logging.info(f"  Rolls Before 7-Out: {rolls_before_7_out}")

# File: .\craps\table.py

# File: craps/table.py
class Table:
    def __init__(self, house_rules):
        """
        Initialize the table.
        
        :param house_rules: The HouseRules object for payout rules and limits.
        """
        self.house_rules = house_rules
        self.bets = []
        self.unit = self.house_rules.table_minimum // 5

    def place_bet(self, bet):
        """Place a bet on the table."""
        if bet.amount < self.house_rules.table_minimum:
            raise ValueError(f"Bet amount ${bet.amount} is below the table minimum of ${self.house_rules.table_minimum}.")
        if bet.amount > self.house_rules.table_maximum:
            raise ValueError(f"Bet amount ${bet.amount} exceeds the table maximum of ${self.house_rules.table_maximum}.")
        self.bets.append(bet)

    def check_bets(self, outcome, phase, point):
        """Check and resolve all bets on the table based on the dice outcome, phase, and point."""
        for bet in self.bets:
            bet.resolve(outcome, phase, point)

    def get_minimum_bet(self, number):
        """
        Get the minimum bet for a Place bet on a specific number.
        
        :param number: The number being bet on (4, 5, 6, 8, 9, or 10).
        :return: The minimum bet amount.
        """
        if number in [6, 8]:
            # For 6 and 8, the minimum bet is table minimum + unit
            return self.house_rules.table_minimum + self.unit
        else:
            # For other numbers, the minimum bet is the table minimum
            return self.house_rules.table_minimum

# File: .\craps\view_log.py

import subprocess
from abc import ABC, abstractmethod
import os
import sys

class LogViewer(ABC):
    """
    Abstract base class for log viewers.
    """

    @abstractmethod
    def view(self, log_file: str):
        """
        View the log file.
        
        :param log_file: Path to the log file.
        """
        pass


class InteractiveLogViewer(LogViewer):
    """
    Concrete class for interactive log viewing.
    """

    def view(self, log_file: str):
        """
        Open the log file interactively.
        
        :param log_file: Path to the log file.
        """
        # Check if the log file exists
        if not os.path.exists(log_file):
            print(f"Log file '{log_file}' not found.")
            return

        # Handle Windows and Unix-like systems differently
        if sys.platform == "win32":
            # Windows: Use Python to print the file contents
            try:
                with open(log_file, 'r', encoding='utf-8') as f:
                    for line in f:
                        print(line, end='')
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")
        else:
            # Unix-like systems: Use `less -R`
            try:
                subprocess.run(['less', '-R', log_file])
            except FileNotFoundError:
                print("'less' command not found. Falling back to plain text viewing.")
                self._view_plain_text(log_file)
            except Exception as e:
                print(f"An error occurred while trying to view the log file: {e}")

    def _view_plain_text(self, log_file: str):
        """
        Fallback method to view the log file as plain text.
        
        :param log_file: Path to the log file.
        """
        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")


class PlainTextLogViewer(LogViewer):
    """
    Concrete class for plain text log viewing.
    """

    def view(self, log_file: str):
        """
        Print the log file to the console.
        
        :param log_file: Path to the log file.
        """

        try:
            with open(log_file, 'r', encoding='utf-8') as f:
                for line in f:
                    print(line, end='')
        except Exception as e:
            print(f"An error occurred while trying to view the log file: {e}")

# File: .\craps\visualizer.py

# File: .\craps\visualizer.py

import matplotlib.pyplot as plt

class Visualizer:
    def __init__(self, stats):
        self.stats = stats

    def visualize_bankrolls(self):
        """Visualize player bankrolls over time."""
        plt.figure(figsize=(12, 6))

        # Plot each player's bankroll
        for player, bankrolls in self.stats.bankroll_history.items():
            # Ensure bankrolls and roll_numbers have the same length
            if len(bankrolls) != len(self.stats.roll_numbers):
                # Trim the longer list to match the shorter one
                min_length = min(len(bankrolls), len(self.stats.roll_numbers))
                bankrolls = bankrolls[:min_length]
                roll_numbers = self.stats.roll_numbers[:min_length]
            else:
                roll_numbers = self.stats.roll_numbers
            plt.plot(roll_numbers, bankrolls, label=player)

        # Add red vertical lines for 7-out events
        for roll in self.stats.seven_out_rolls:
            plt.axvline(x=roll, color='red', linestyle='--', alpha=0.5, label='7-Out' if roll == self.stats.seven_out_rolls[0] else "")

        # Add green dashed lines for point number rolls
        for roll in self.stats.point_number_rolls:
            plt.axvline(x=roll, color='green', linestyle=':', alpha=0.5, label='Point Number Rolled' if roll == self.stats.point_number_rolls[0] else "")

        # Set x-axis limits to start at 0 and end at the last roll
        last_roll = self.stats.roll_numbers[-1]
        plt.xlim(left=0, right=last_roll)

        # Customize x-axis ticks to include the last roll number
        x_ticks = list(range(0, last_roll + 1, 10))  # Major ticks every 10 rolls

        # Remove the next-to-last tick if it is within 3 of the last roll and the last roll is not a multiple of 10
        if len(x_ticks) >= 2:
            next_to_last_tick = x_ticks[-2]
            if (last_roll - next_to_last_tick) <= 3 and (last_roll % 10 != 0):
                x_ticks.pop(-2)  # Remove the next-to-last tick

        # Add the last roll number if it's not already included
        if last_roll not in x_ticks:
            x_ticks.append(last_roll)

        plt.xticks(x_ticks)

        # Add labels and title
        plt.xlabel("Roll Number")
        plt.ylabel("Bankroll")
        plt.title("Player Bankrolls Over Time")
        plt.legend()
        plt.grid(True)
        plt.show()

# File: .\craps\__init__.py



# File: .\craps\bets\field_bet.py

# File: craps/bets/field_bet.py
from . import Bet  # Import the base Bet class

class FieldBet(Bet):
    """Class representing a Field bet."""
    def __init__(self, amount, owner):
        super().__init__("Field", amount, owner, payout_ratio=(1, 1), locked=False)

    def resolve(self, outcome, phase, point):
        """Resolve the Field bet based on the dice outcome."""
        total = sum(outcome)

        # Field bet wins on 2, 3, 4, 9, 10, 11, 12
        if total in [2, 3, 4, 9, 10, 11, 12]:
            if total in [2, 12]:  # Special payouts for 2 and 12
                self.payout_ratio = (2, 1)  # 2:1 payout for 2 and 12 (adjust as needed)
            self.status = "won"  # Field bet wins
        else:
            self.status = "lost"  # Field bet loses

# File: .\craps\bets\free_odds.py

# File: craps/bets/free_odds.py

from . import Bet

class FreeOddsBet(Bet):
    """Class representing a Free Odds bet (for Pass Line Odds or Place Bets)."""
    def __init__(self, bet_type, amount, owner, number=None):
        """
        Initialize a Free Odds bet.
        
        :param bet_type: The type of bet (e.g., "Pass Line Odds", "Place Odds").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param number: The number being bet on (for Place Odds).
        """
        super().__init__(bet_type, amount, owner, payout_ratio=(1, 1), locked=False)
        self.number = number  # Only used for Place Odds

    def resolve(self, outcome, phase, point):
        """Resolve the Free Odds bet based on the dice outcome, phase, and point."""
        total = sum(outcome)
        
        if phase == "point":
            if self.bet_type == "Pass Line Odds":
                # Pass Line Odds logic
                if total == point:
                    if point in [4, 10]:
                        self.payout_ratio = (2, 1)  # 2:1 payout for 4 and 10
                    elif point in [5, 9]:
                        self.payout_ratio = (3, 2)  # 3:2 payout for 5 and 9
                    elif point in [6, 8]:
                        self.payout_ratio = (6, 5)  # 6:5 payout for 6 and 8
                    self.status = "won"  # Pass Line Odds bet wins
                elif total == 7:
                    self.status = "lost"  # Pass Line Odds bet loses
                else:
                    self.status = "active"  # Bet remains active
            elif self.bet_type == "Place Odds":
                # Place Odds logic
                if total == self.number:
                    if self.number in [4, 10]:
                        self.payout_ratio = (2, 1)  # 2:1 payout for 4 and 10
                    elif self.number in [5, 9]:
                        self.payout_ratio = (3, 2)  # 3:2 payout for 5 and 9
                    elif self.number in [6, 8]:
                        self.payout_ratio = (7, 6)  # 7:6 payout for 6 and 8
                    self.status = "won"  # Place Odds bet wins
                elif total == 7:
                    self.status = "lost"  # Place Odds bet loses
                else:
                    self.status = "active"  # Bet remains active

# File: .\craps\bets\pass_line.py

# File: craps/bets/pass_line.py
from . import Bet  # Import the base Bet class

class PassLineBet(Bet):
    """Class representing a Pass Line bet."""
    def __init__(self, amount, owner):
        super().__init__("Pass Line", amount, owner, payout_ratio=(1, 1), locked=True)

    def resolve(self, outcome, phase, point):
        """Resolve the Pass Line bet based on the dice outcome, phase, and point."""
        total = sum(outcome)
        
        if phase == "come-out":
            if total in [7, 11]:
                self.status = "won"  # Pass Line bet wins
            elif total in [2, 3, 12]:
                self.status = "lost"  # Pass Line bet loses
            else:
                self.status = "active"  # Point is set; bet remains active
        else:  # Point phase
            if total == point:
                self.status = "won"  # Pass Line bet wins
            elif total == 7:
                self.status = "lost"  # Pass Line bet loses
            else:
                self.status = "active"  # Bet remains active

# File: .\craps\bets\place_bet.py

# File: .\craps\bets\place_bet.py

from . import Bet  # Import the base Bet class from the bets package

class PlaceBet(Bet):
    """Class representing a Place bet."""
    def __init__(self, amount, owner, number):
        super().__init__(f"Place {number}", amount, owner, locked=False)
        self.number = number

    def resolve(self, outcome, phase, point):
        """Resolve the Place bet based on the dice outcome, phase, and point."""
        total = sum(outcome)
        
        if phase == "come-out":
            self.status = "inactive"  # Place bets are inactive during the come-out phase
            return
        
        if phase == "point":
            if total == self.number:
                if self.number in [4, 10]:
                    self.payout_ratio = (9, 5)  # 9:5 payout for 4 and 10
                elif self.number in [5, 9]:
                    self.payout_ratio = (7, 5)  # 7:5 payout for 5 and 9
                elif self.number in [6, 8]:
                    self.payout_ratio = (7, 6)  # 7:6 payout for 6 and 8
                self.status = "won"  # Place bet wins
            elif total == 7:
                self.status = "lost"  # Place bet loses on 7-out
            else:
                self.status = "active"  # Bet remains active

# File: .\craps\bets\place_odds.py

# File: craps/bets/place_odds.py
from . import Bet

class PlaceOddsBet(Bet):
    """Class representing a Place Odds bet."""
    def __init__(self, amount, owner, number):
        """
        Initialize a Place Odds bet.
        
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param number: The number being bet on (e.g., 4, 5, 6, 8, 9, 10).
        """
        super().__init__(f"Place Odds on {number}", amount, owner, payout_ratio=(1, 1), locked=False)
        self.number = number

    def resolve(self, outcome, phase, point):
        """Resolve the Place Odds bet based on the dice outcome, phase, and point."""
        total = sum(outcome)
        
        if phase == "point":
            if total == self.number:
                # Set the payout ratio based on the number
                if self.number in [4, 10]:
                    self.payout_ratio = (2, 1)  # 2:1 payout for 4 and 10
                elif self.number in [5, 9]:
                    self.payout_ratio = (3, 2)  # 3:2 payout for 5 and 9
                elif self.number in [6, 8]:
                    self.payout_ratio = (6, 5)  # 6:5 payout for 6 and 8
                self.status = "won"  # Place Odds bet wins
            elif total == 7:
                self.status = "lost"  # Place Odds bet loses
            else:
                self.status = "active"  # Bet remains active

# File: .\craps\bets\__init__.py

# File: .\craps\bets\__init__.py

# Define the base Bet class
class Bet:
    """Base class for all bet types."""
    def __init__(self, bet_type, amount, owner, payout_ratio=(1, 1), locked=True, vig=0):
        """
        Initialize a bet.
        
        :param bet_type: The type of bet (e.g., "Pass Line", "Come").
        :param amount: The amount of the bet.
        :param owner: The player who placed the bet.
        :param payout_ratio: The payout ratio as a tuple (numerator, denominator).
        :param locked: Whether the bet is locked (cannot be taken down).
        :param vig: The vig (commission) as a percentage of the bet amount.
        """
        self.bet_type = bet_type
        self.amount = amount
        self.owner = owner
        self.payout_ratio = payout_ratio
        self.locked = locked
        self.vig = vig
        self.status = "active"  # Can be "active", "won", "lost", or "pushed"

    def calculate_profit(self):
        """Calculate the profit for the bet based on the payout ratio and vig."""
        numerator, denominator = self.payout_ratio
        profit = self.amount * numerator // denominator
        
        # Deduct the vig (if applicable)
        if self.vig > 0:
            vig_amount = self.amount * self.vig // 100
            profit -= vig_amount
        
        return profit

    def payout(self):
        """
        Calculate the payout for the bet.
        - For Pass-Line bets: Return the total payout (original bet + profit).
        - For Place bets: Return the profit only (original bet remains on the table).
        """
        if self.status != "won":
            return 0  # No payout if the bet is not won
        
        profit = self.calculate_profit()
        
        # Return the total payout for Pass-Line bets or profit only for Place bets
        if self.bet_type == "Pass Line":
            return self.amount + profit  # Total payout (original bet + profit)
        else:
            return profit  # Profit only (original bet remains on the table)

    def resolve(self, outcome, phase, point):
        """
        Resolve the bet based on the dice outcome, phase, and point.
        
        :param outcome: The result of the dice roll (e.g., [3, 4]).
        :param phase: The current game phase ("come-out" or "point").
        :param point: The current point number (if in point phase).
        """
        raise NotImplementedError("Subclasses must implement this method.")

    def is_resolved(self):
        """Check if the bet has been resolved (won, lost, or pushed)."""
        return self.status in ["won", "lost", "pushed"]

    def __str__(self):
        return f"{self.owner}'s ${self.amount} {self.bet_type} bet (Status: {self.status})"


# Import and re-export the bet classes
from .pass_line import PassLineBet
from .place_bet import PlaceBet
from .free_odds import FreeOddsBet

# Optionally, define __all__ to make it clear which classes are exported
__all__ = ["Bet", "PassLineBet", "PlaceBet", "PassLineOddsBet"]

# File: .\craps\strategies\field_bet.py

# File: craps/strategies/field_bet.py
from craps.bet_factory import BetFactory

class FieldBetStrategy:
    """Betting strategy for Field bets."""
    def __init__(self, min_bet):
        """
        Initialize the Field Bet strategy.
        
        :param min_bet: The minimum bet amount for the table.
        """
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place a Field bet if no active Field bet exists."""
        # Check if the player already has an active Field bet
        if any(b.bet_type == "Field" for b in player.active_bets):
            return None  # No new bet to place

        # Use the BetFactory to create a Field bet
        return BetFactory.create_field_bet(self.min_bet, player.name)

# File: .\craps\strategies\free_odds.py

from craps.bet_factory import BetFactory

class FreeOddsStrategy:
    """Betting strategy for Free Odds on any active bet."""
    def __init__(self, table, odds_multiple="1x"):
        """
        Initialize the Free Odds strategy.
        
        :param table: The table object to determine minimum bets.
        :param odds_multiple: The odds multiple (e.g., "1x", "2x", "3x", "1-2-3", "3-4-5").
        """
        self.table = table
        self.odds_multiple = odds_multiple

    def get_odds_amount(self, original_bet_amount):
        """Calculate the odds amount based on the original bet amount and the selected multiple."""
        if self.odds_multiple == "1x":
            return original_bet_amount
        elif self.odds_multiple == "2x":
            return original_bet_amount * 2
        elif self.odds_multiple == "3x":
            return original_bet_amount * 3
        elif self.odds_multiple == "1-2-3":
            # 1x on 4/10, 2x on 5/9, 3x on 6/8
            return original_bet_amount
        elif self.odds_multiple == "3-4-5":
            # 3x on 4/10, 4x on 5/9, 5x on 6/8
            return original_bet_amount
        else:
            raise ValueError(f"Invalid odds multiple: {self.odds_multiple}")

    def get_bet(self, game_state, player):
        """Place Free Odds bets on any active bets."""
        bets = []

        for active_bet in player.active_bets:
            if active_bet.bet_type in ["Pass Line", "Place"]:
                # Calculate the odds amount based on the original bet amount
                odds_amount = self.get_odds_amount(active_bet.amount)

                # Create a Free Odds bet
                if active_bet.bet_type == "Pass Line":
                    bets.append(BetFactory.create_pass_line_odds_bet(odds_amount, player.name))
                elif active_bet.bet_type == "Place":
                    bets.append(BetFactory.create_place_odds_bet(odds_amount, player.name, active_bet.number))

        return bets if bets else None

# File: .\craps\strategies\iron_cross.py

# File: craps/strategies/iron_cross.py
from craps.bet_factory import BetFactory

class IronCrossStrategy:
    """Betting strategy for Iron Cross."""
    def __init__(self, table, min_bet):
        """
        Initialize the Iron Cross strategy.
        
        :param table: The table object to determine minimum bets.
        :param min_bet: The minimum bet amount for the table.
        """
        self.table = table
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place bets for the Iron Cross strategy."""
        if game_state.phase == "come-out":
            # Place a Pass Line bet during the come-out roll if no active bet exists
            if not any(b.bet_type == "Pass Line" for b in player.active_bets):
                return BetFactory.create_pass_line_bet(self.min_bet, player.name)
        elif game_state.phase == "point":
            # Reactivate inactive Place bets
            for bet in player.active_bets:
                if bet.bet_type.startswith("Place") and bet.status == "inactive":
                    bet.status = "active"
                    print(f"{player.name}'s {bet.bet_type} bet is now ON.")

            # Place Place bets on 5, 6, and 8 during the point phase (excluding the point number)
            numbers = [5, 6, 8]  # Numbers for the Iron Cross

            # Exclude the point number
            if game_state.point in numbers:
                numbers.remove(game_state.point)

            # Filter out numbers already covered by a Place bet
            numbers = [
                num for num in numbers
                if not any(
                    b.bet_type.startswith("Place") and b.number == num
                    for b in player.active_bets
                )
            ]

            # Use the BetFactory to create Place bets
            bets = []
            for number in numbers:
                min_bet = self.table.get_minimum_bet(number)
                bets.append(BetFactory.create_place_bet(min_bet, player.name, number))

            # Add a Field bet if no active Field bet exists
            if not any(b.bet_type == "Field" for b in player.active_bets):
                bets.append(BetFactory.create_field_bet(self.min_bet, player.name))

            return bets if bets else None

        return None  # No bet to place

# File: .\craps\strategies\pass_line.py

# File: .\craps\strategies\pass_line.py

from craps.bets.pass_line import PassLineBet  # Import the PassLineBet class

class PassLineStrategy:
    """Betting strategy for Pass Line bets."""
    def __init__(self, min_bet):
        self.min_bet = min_bet

    def get_bet(self, game_state, player):
        """Place a Pass Line bet during the come-out roll if no active bet exists."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                # print(f"{player.name} already has an active Pass Line bet.")
                return None  # No new bet to place

            # Place a new Pass Line bet
            return PassLineBet(self.min_bet, player.name)  # Use PassLineBet instead of Bet
        return None  # No bet to place

# File: .\craps\strategies\pass_line_odds.py

# File: craps/strategies/pass_line_odds.py
from craps.bet_factory import BetFactory

class PassLineOddsStrategy:
    """Betting strategy for Pass Line with Odds bets."""
    def __init__(self, table, odds_multiple=1):
        """
        Initialize the Pass Line Odds strategy.
        
        :param table: The table object to determine minimum bets.
        :param odds_multiple: The multiple of the minimum bet to use for odds (e.g., 1x, 2x).
        """
        self.table = table
        self.odds_multiple = odds_multiple

    def get_bet(self, game_state, player):
        """Place a Pass Line or Pass Line Odds bet based on the game state."""
        if game_state.phase == "come-out":
            # Check if the player already has an active Pass Line bet
            if any(b.bet_type == "Pass Line" for b in player.active_bets):
                return None  # No new bet to place

            # Use the BetFactory to create a Pass Line bet
            return BetFactory.create_pass_line_bet(self.table.house_rules.table_minimum, player.name)
        
        elif game_state.phase == "point":
            # Check if the player already has an active Pass Line Odds bet
            if any(b.bet_type.startswith("Place Odds") for b in player.active_bets):
                return None  # No new bet to place

            # Use the BetFactory to create a Place Odds bet on the point number
            return BetFactory.create_place_odds_bet(
                self.table.house_rules.table_minimum * self.odds_multiple,  # Bet amount
                player.name,  # Owner
                game_state.point  # Point number
            )
        
        return None  # No bet to place

# File: .\craps\strategies\place_bet.py

# File: craps/strategies/place_bet.py
from craps.bet_factory import BetFactory

class PlaceBetStrategy:
    """Betting strategy for Place Bets."""
    def __init__(self, table, numbers_or_strategy):
        """
        Initialize the Place Bet strategy.
        
        :param table: The table object to determine minimum bets.
        :param numbers_or_strategy: A list of numbers (e.g., [5, 6, 8, 9]) or a strategy ("inside", "across").
        """
        self.table = table
        self.numbers_or_strategy = numbers_or_strategy

    def get_bet(self, game_state, player):
        """Place Place Bets based on the strategy and game state."""
        if game_state.phase != "point":
            return None  # Only place bets after the point is established

        # Determine which numbers to bet on
        if isinstance(self.numbers_or_strategy, str):
            if self.numbers_or_strategy == "inside":
                numbers = [5, 6, 8, 9]  # Inside numbers
            elif self.numbers_or_strategy == "across":
                numbers = [4, 5, 6, 8, 9, 10]  # Across numbers
            else:
                raise ValueError(f"Invalid strategy: {self.numbers_or_strategy}")
        else:
            numbers = self.numbers_or_strategy  # Specific numbers provided

        # Filter out numbers already covered by a Pass Line bet or a Place bet
        numbers = [
            num for num in numbers
            if not any(
                (b.bet_type == "Pass Line" and b.point == num) or  # Pass Line covers the point
                (b.bet_type.startswith("Place") and b.number == num)  # Place Bet covers the number
                for b in player.active_bets
            )
        ]

        # Use the BetFactory to create Place bets
        bets = []
        for number in numbers:
            min_bet = self.table.get_minimum_bet(number)
            bets.append(BetFactory.create_place_bet(min_bet, player.name, number))

        return bets if bets else None

# File: .\tests\test_dice.py

import sys
import os
import unittest
from craps.dice import Dice

class TestDice(unittest.TestCase):
    def test_roll(self):
        dice = Dice()
        num_rolls = 1_000_000  # Number of rolls to simulate
        tolerance = 0.001  # Tolerance for probability comparison

        # Initialize counters for single die outcomes
        single_die_counts = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0}

        # Initialize counters for total outcomes
        total_counts = {
            2: 0, 3: 0, 4: 0, 5: 0, 6: 0,
            7: 0, 8: 0, 9: 0, 10: 0, 11: 0, 12: 0
        }

        # Roll the dice 1 million times
        for _ in range(num_rolls):
            outcome = dice.roll()
            total = sum(outcome)

            # Count single die outcomes
            for die in outcome:
                single_die_counts[die] += 1

            # Count total outcomes
            total_counts[total] += 1

        # Calculate observed probabilities for single die outcomes
        single_die_probs = {
            die: count / (num_rolls * 2)  # Each roll involves 2 dice
            for die, count in single_die_counts.items()
        }

        # Calculate observed probabilities for total outcomes
        total_probs = {
            total: count / num_rolls
            for total, count in total_counts.items()
        }

        # Expected probabilities for single die outcomes
        expected_single_die_prob = 1 / 6

        # Expected probabilities for total outcomes
        expected_total_probs = {
            2: 1 / 36,
            3: 2 / 36,
            4: 3 / 36,
            5: 4 / 36,
            6: 5 / 36,
            7: 6 / 36,
            8: 5 / 36,
            9: 4 / 36,
            10: 3 / 36,
            11: 2 / 36,
            12: 1 / 36,
        }

        # Display results for single die outcomes
        print("\nSingle Die Outcomes:")
        print(f"{'Outcome':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for die in range(1, 7):
            actual = single_die_probs[die]
            expected = expected_single_die_prob
            deviation = actual - expected
            print(f"{die:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Display results for total outcomes
        print("\nTotal Outcomes:")
        print(f"{'Total':<10} {'Actual':<10} {'Expected':<10} {'Deviation':<10}")
        for total in range(2, 13):
            actual = total_probs[total]
            expected = expected_total_probs[total]
            deviation = actual - expected
            print(f"{total:<10} {actual:<10.6f} {expected:<10.6f} {deviation:<10.6f}")

        # Test single die outcomes
        for die, prob in single_die_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_single_die_prob,
                delta=tolerance,
                msg=f"Single die outcome {die} probability is not within tolerance."
            )

        # Test total outcomes
        for total, prob in total_probs.items():
            self.assertAlmostEqual(
                prob,
                expected_total_probs[total],
                delta=tolerance,
                msg=f"Total outcome {total} probability is not within tolerance."
            )

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_field_bet.py

import unittest
from craps.bets.field_bet import FieldBet
from craps.player import Player
from craps.table import Table
from craps.house_rules import HouseRules

class TestFieldBet(unittest.TestCase):
    def test_field_bet_outcomes(self):
        # Initialize house rules with custom payouts for 2 and 12
        house_rules = HouseRules()
        house_rules.set_field_bet_payouts((2, 1), (3, 1))  # 2:1 for 2, 3:1 for 12

        # Initialize player and table
        player = Player("Alice", 1000)
        table = Table(house_rules)

        # Define all possible dice totals and their expected outcomes
        test_cases = [
            # (dice_total, expected_status, expected_payout)
            (2, "won", 20),  # Field Bet wins 2:1 on 2 (house rules: 2:1)
            (3, "won", 10),  # Field Bet wins 1:1 on 3
            (4, "won", 10),  # Field Bet wins 1:1 on 4
            (5, "lost", 0),  # Field Bet loses on 5
            (6, "lost", 0),  # Field Bet loses on 6
            (7, "lost", 0),  # Field Bet loses on 7
            (8, "lost", 0),  # Field Bet loses on 8
            (9, "won", 10),  # Field Bet wins 1:1 on 9
            (10, "won", 10),  # Field Bet wins 1:1 on 10
            (11, "won", 10),  # Field Bet wins 1:1 on 11
            (12, "won", 30),  # Field Bet wins 3:1 on 12 (house rules: 3:1)
        ]

        # Print table header
        print("\nField Bet Test Results (House Rules: 2:1 for 2, 3:1 for 12)")
        print("=" * 70)
        print(f"{'Dice Total':<12} {'Expected Status':<16} {'Expected Payout':<16} {'Actual Status':<16} {'Actual Payout':<16} {'Result'}")

        # Test each dice total
        for dice_total, expected_status, expected_payout in test_cases:
            # Create a new Field Bet for each test case
            field_bet = FieldBet(10, player.name)
            player.place_bet(field_bet, table)

            # Simulate the dice roll
            dice_outcome = self._get_dice_outcome(dice_total)
            field_bet.resolve(dice_outcome, "come-out", None)

            # Resolve the bet and calculate the payout
            player.resolve_bets(table, None, dice_outcome, "come-out", None)

            # Get the actual status and payout
            actual_status = field_bet.status
            actual_payout = field_bet.payout()

            # Compare expected vs. actual
            status_match = actual_status == expected_status
            payout_match = actual_payout == expected_payout
            result = "✔" if status_match and payout_match else "✗"

            # Print the results in a table format
            print(f"{dice_total:<12} {expected_status:<16} ${expected_payout:<15} {actual_status:<16} ${actual_payout:<15} {result}")

    def _get_dice_outcome(self, total):
        """Helper method to generate a dice outcome for a given total."""
        if total < 2 or total > 12:
            raise ValueError("Invalid dice total. Must be between 2 and 12.")
        for die1 in range(1, 7):
            for die2 in range(1, 7):
                if die1 + die2 == total:
                    return [die1, die2]
        return None

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_player.py

import unittest
from craps.player import Player
from craps.table import Table
from craps.bet import Bet

class TestPlayer(unittest.TestCase):
    def test_place_bet(self):
        player = Player("Alice", 1000)
        table = Table()
        player.place_bet("Pass Line", 100, table)
        self.assertEqual(player.balance, 900)
        self.assertEqual(len(player.bets), 1)
        self.assertEqual(len(table.bets), 1)

    def test_resolve_bets(self):
        player = Player("Alice", 1000)
        table = Table()
        bet = Bet("Pass Line", 100, "Alice")
        table.place_bet(bet)
        player.bets.append(bet)

        # Simulate a win
        bet.status = "won"
        player.resolve_bets(table)
        self.assertEqual(player.balance, 1100)
        self.assertEqual(len(player.bets), 0)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_puck.py

import unittest
from craps.puck import Puck

class TestPuck(unittest.TestCase):
    def test_puck(self):
        puck = Puck()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

        puck.set_point(4)
        self.assertEqual(puck.position, "On")
        self.assertEqual(puck.point, 4)

        puck.reset()
        self.assertEqual(puck.position, "Off")
        self.assertIsNone(puck.point)

if __name__ == "__main__":
    unittest.main()

# File: .\tests\test_shooter.py

import unittest
from craps.shooter import Shooter

class TestShooter(unittest.TestCase):
    def test_roll_dice(self):
        shooter = Shooter("Alice")
        outcome = shooter.roll_dice()
        self.assertIsInstance(outcome, list)
        self.assertEqual(len(outcome), 2)
        self.assertTrue(1 <= outcome[0] <= 6)
        self.assertTrue(1 <= outcome[1] <= 6)

if __name__ == "__main__":
    unittest.main()

